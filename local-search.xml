<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>git开发场景中的问题及解决</title>
    <link href="/2023/10/10/git%E5%BC%80%E5%8F%91%E5%9C%BA%E6%99%AF%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3/"/>
    <url>/2023/10/10/git%E5%BC%80%E5%8F%91%E5%9C%BA%E6%99%AF%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3/</url>
    
    <content type="html"><![CDATA[<h1 id="git如何删除提交记录中的大文件？"><a href="#git如何删除提交记录中的大文件？" class="headerlink" title="git如何删除提交记录中的大文件？"></a>git如何删除提交记录中的大文件？</h1>]]></content>
    
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>B站上的有趣面试题</title>
    <link href="/2023/10/10/B%E7%AB%99%E4%B8%8A%E7%9A%84%E6%9C%89%E8%B6%A3%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/2023/10/10/B%E7%AB%99%E4%B8%8A%E7%9A%84%E6%9C%89%E8%B6%A3%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><h2 id="1-JVM出现OOMError，还能处理请求吗？"><a href="#1-JVM出现OOMError，还能处理请求吗？" class="headerlink" title="1. JVM出现OOMError，还能处理请求吗？"></a>1. JVM出现OOMError，还能处理请求吗？</h2><p>分两种情况，</p><ol><li>系统层面的OOM：当jvm的-Xmx和-Xms设置的很高，占用大量操作系统内存，当操作系统本身可用内存变得很低时，linux的OOM killer可能会杀掉占用内存最多的进程（这种情况下可能是Jvm进程）。如果jvm被杀掉，则无法处理任何进一步的请求。</li><li>JVM层面的OOM：对于运行在jvm中的应用，如果-Xmx的限制达到，即jvm可以使用的最大堆内存已经达到，当jvm尝试分配更多内存无法做到时，就会抛出OOM。这时，如果有其他请求的内存需求非常小，仍能在现有的可用堆内存中分配，理论上他可能仍可以被处理。</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>面经</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>万得-秋招-java开发-二面</title>
    <link href="/2023/10/09/%E4%B8%87%E5%BE%97-%E7%A7%8B%E6%8B%9B-java%E5%BC%80%E5%8F%91-%E4%BA%8C%E9%9D%A2/"/>
    <url>/2023/10/09/%E4%B8%87%E5%BE%97-%E7%A7%8B%E6%8B%9B-java%E5%BC%80%E5%8F%91-%E4%BA%8C%E9%9D%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>问的问题比较简单，答的还行。</p><p><strong>难度</strong>：⭐☆☆☆☆<br><strong>学到的知识</strong>：⭐☆☆☆☆</p><h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><h2 id="1-重写和重载的区别？"><a href="#1-重写和重载的区别？" class="headerlink" title="1. 重写和重载的区别？"></a>1. 重写和重载的区别？</h2><p>重写：子类重写父类方法，运行时多态<br>重载：同名方法，不同参数列表，编译时多态</p><h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h2 id="1-不可重复度和幻读的区别？"><a href="#1-不可重复度和幻读的区别？" class="headerlink" title="1. 不可重复度和幻读的区别？"></a>1. 不可重复度和幻读的区别？</h2><p>不可重复读：事务A在执行过程中读取到了事务B已提交的修改。<br>幻读：事务A在执行过程中，因事务B的修改，前后读到的行数不一致。</p><h2 id="2-写sql语句。题目如下"><a href="#2-写sql语句。题目如下" class="headerlink" title="2. 写sql语句。题目如下"></a>2. 写sql语句。题目如下</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 有两张表</span><br><span class="hljs-comment">-- 学生表 tb_stu：主键 id, 学生名 username</span><br><span class="hljs-comment">-- 课程成绩表 tb_score: 主键 id, 学生 stu_id, 课程 c_id, 分数 score</span><br><br><span class="hljs-comment">-- 题目要求：查询平均分在80以上的学生姓名。</span><br></code></pre></td></tr></table></figure><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="1-对万得了解多少？"><a href="#1-对万得了解多少？" class="headerlink" title="1. 对万得了解多少？"></a>1. 对万得了解多少？</h2><h1 id="笔试题目"><a href="#笔试题目" class="headerlink" title="笔试题目"></a>笔试题目</h1>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>中期答辩进展</title>
    <link href="/2023/10/07/%E4%B8%AD%E6%9C%9F%E7%AD%94%E8%BE%A9%E8%BF%9B%E5%B1%95/"/>
    <url>/2023/10/07/%E4%B8%AD%E6%9C%9F%E7%AD%94%E8%BE%A9%E8%BF%9B%E5%B1%95/</url>
    
    <content type="html"><![CDATA[<h1 id="PPT"><a href="#PPT" class="headerlink" title="PPT"></a>PPT</h1><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>这一次ppt希望做完之后的底板，之后不会进行大改。</p><h2 id="包含的要点"><a href="#包含的要点" class="headerlink" title="包含的要点"></a>包含的要点</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>要简洁明了，最好让老师一眼就能看出来在做啥，不然后面可能没兴趣听。</p><h3 id="选题背景"><a href="#选题背景" class="headerlink" title="选题背景"></a>选题背景</h3><p>要体现专业程度和需求。<br>专业程度可以通过数据和手绘图来体现，需求其实也是在数据中，最好能体现出紧迫感。</p><h3 id="问题定义"><a href="#问题定义" class="headerlink" title="问题定义"></a>问题定义</h3><p>清晰，带有技术性，最好有公式。</p><h3 id="相关工作-难点"><a href="#相关工作-难点" class="headerlink" title="相关工作&amp;&amp;难点"></a>相关工作&amp;&amp;难点</h3><p>最好能深入算法层面，不要归类后侃侃而谈<br>接着相关工作做个总结，既是难点，也和我后面提出的方法紧密相关。</p><h3 id="当前进展"><a href="#当前进展" class="headerlink" title="当前进展"></a>当前进展</h3><ol><li>数据分析的内容 + 上一篇论文</li><li>论文中存在的问题，重点讲，和周一的组会也高度相关</li><li>收集系统和用户系统，一笔带过</li></ol><h3 id="后续研究计划"><a href="#后续研究计划" class="headerlink" title="后续研究计划"></a>后续研究计划</h3><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3>]]></content>
    
    
    
    <tags>
      
      <tag>未完结</tag>
      
      <tag>毕设</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IO多路复用</title>
    <link href="/2023/10/06/BIO-NIO/"/>
    <url>/2023/10/06/BIO-NIO/</url>
    
    <content type="html"><![CDATA[<h1 id="五种IO模型"><a href="#五种IO模型" class="headerlink" title="五种IO模型"></a>五种IO模型</h1><ul><li>blockingIO - 阻塞IO</li><li>nonblockingIO - 非阻塞IO</li><li>signaldrivenIO - 信号驱动IO</li><li>asynchronousIO - 异步IO</li><li>IOmultiplexing - IO多路复用</li></ul><p><strong>什么是多路复用？</strong><br>首先，linux中“一切皆文件”，所有的IO设备：磁盘、网络数据、终端、甚至进程间通信工具管道都被当做文件。</p><ul><li>多路：指多个socket网络连接（可以看成是文件）。</li><li>复用：使用一个线程来检查多个文件描述符（网络连接）的就绪状态。</li><li>多路复用目前的技术：select、poll、epoll</li></ul><h1 id="BlockingIO"><a href="#BlockingIO" class="headerlink" title="BlockingIO"></a>BlockingIO</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>进程或线程从调用revcfrom开始到返回数据，整段时间都是阻塞的，recvfrom成功返回后，进程或线程开始处理数据。<br>即一个进程&#x2F;线程（后仅用线程代替）处理一个IO请求，当无数据时，则线程阻塞挂起，不消耗CPU资源。<br>不适高并发应用，因为要为每个请求去分配一个线程去响应，系统开销大。</p><h1 id="NonBlockingIO"><a href="#NonBlockingIO" class="headerlink" title="NonBlockingIO"></a>NonBlockingIO</h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><p>线程发起IO系统调用后，如何内核缓冲区中没有数据，需要到IO设备中读取，进程会返回错误，而不会被阻塞；如果内核缓冲区中有数据，则会将数据返回进程。<br>一个线程可以处理多个请求，虽然线程持续消耗CPU资源，但是提高了并发量，并且减少了线程切换的开销。<br>缺点就是通过轮询来检查IO状态的方式，会消耗比较多的CPU资源。</p><h1 id="SignaldrivenIO"><a href="#SignaldrivenIO" class="headerlink" title="SignaldrivenIO"></a>SignaldrivenIO</h1><h2 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h2><p>当线程发起IO请求，会向内核注册一个信号处理函数，线程返回不阻塞；当内核数据准备就绪，会发送信号给线程，线程在信号处理函数中调用IO读取数据。<br>这种方式相对于原始的NonBlockingIO来说，使用异步信号取代轮询，减少了因为检查IO状态而导致CPU占用过多的情况。<br>但是在应用程序接收信号后，应用程序主动发起IO操作来处理数据，所以在实际IO操作（read&#x2F;write）阶段会发生阻塞。</p><h1 id="AsynchronousIO"><a href="#AsynchronousIO" class="headerlink" title="AsynchronousIO"></a>AsynchronousIO</h1><h2 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h2><p>异步IO会在整个IO操作完成后通知应用程序，所以相对SignaldrivenIO，其不需要应用程序去阻塞来等待实际的IO操作，IO操作由内核在后台进行，适合于高并发、需要非阻塞处理的场景，特别是对响应时间比较敏感的应用。</p><h1 id="IOmultiplexing"><a href="#IOmultiplexing" class="headerlink" title="IOmultiplexing"></a>IOmultiplexing</h1><h2 id="IO多路复用相对异步IO的好处？"><a href="#IO多路复用相对异步IO的好处？" class="headerlink" title="IO多路复用相对异步IO的好处？"></a>IO多路复用相对异步IO的好处？</h2><p>这个没看出来。可能就是场景不同？希望IO操作谁来接管的问题？</p><h2 id="几种系统调用"><a href="#几种系统调用" class="headerlink" title="几种系统调用"></a>几种系统调用</h2><h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><p>将用户态中被监控的文件描述符集合拷贝到内核态，在内核态做遍历，若某个socket上有数据可读，则调用select的线程会被唤醒，然后select遍历文件描述符集合，挨个收集可读事件返回给用户。<br>减少了系统调用的开销。<br>但是存在两个问题：</p><ol><li>每次调用select，都要把被监控的fds集合从用户态拷贝到内核态空间，高并发场景下消耗资源很大。（文件描述符采用bitmap来记录）</li><li>能监听的端口数量有限，单个进程能打开的最大连接树由FD_SETSIZE宏定义。虽然可以修改该值，并对内核重新编译，但是会影响性能。该值和系统内存有关，32位默认1024,64位默认2048。</li><li>只要有一个数据可读，就要遍历整个文件描述符，所以随着管理的socket请求增多，效率会降低。</li></ol><p>总结一下（不精准）：<br>select的好处是，通过一个线程来管理多个socket请求，减少线程创建和切换的开销，也在达到系统线程数量上线的请求来处理更多的请求，这一块是所有涉及复用、线程池等技术的优势；其次，通过一个select系统调用，同时将多个文件描述符交由内核处理，减少了系统调用的次数，降低开销。<br>但是存在的问题就是，每次select调用需要将大量的文件描述符拷贝到内核态，其次，内核态发出数据可用的通知时，并不知道是哪个文件描述符的对应的数据可读，需要遍历所有的文件描述符，以收集可读的数据，返回给应用，这会造成O(n)的时间复杂度。还有一个早期实现上的问题，select中使用FD_SETSIZE来定义的bitmap的最大大小，也限制了其能够处理的socket的数量，除非你愿意修改FD_SETSIZE的值，并重新编译内核。</p><h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><p><strong>关心其如何解决select的问题？</strong><br>poll在调用时，可以指定数组的大小，而非像select一样是一个固定大小的bitmap，该数组的大小仅受限于系统资源。<br>其他暂时没看出来比较大的优势。</p><h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><p>前面提到，随着监听的文件描述符的增多，select和poll采用轮询的方式，效率比较低，这会降低其在高并发场景下的效率。<br>epoll使用红黑树rbr来管理fd，并在有数据到达时，将其放入链表rdllist中，这样应用程序只需要判断链表是否为空，就能知道是否有需要处理的IO操作，而无需对整个文件描述符进行遍历。<br>使用红黑树的目的：降低查找，插入和删除的时间复杂度。</p><p>总结一下：<br>epoll可以理解为主要使用了两个“队列”来管理IO请求，一个队列使用红黑树，因为他需要频繁的插入和删除操作，红黑树能提供较低的时间度。另一个队列，用来存放就绪IO事件，应用程序只需读取该队列，而无需对所有的IO请求进行遍历，减少了时间开销，使得其在IO请求增多的情况下，不会向select和poll一样，因为需要轮询所有的IO请求，导致开销比较大。<br>同时向用户态的拷贝，也只需要拷贝该就绪队列，不需要拷贝整个文件描述符集合，降低了数据拷贝的开销。<br>同时epoll和poll都没有使用有宏定义位数量上限的bitmap结构，使得其理论上处理的连接数无限制。（当然受到系统资源的限制）</p><h1 id="5种IO模型的总结"><a href="#5种IO模型的总结" class="headerlink" title="5种IO模型的总结"></a>5种IO模型的总结</h1><ol><li>阻塞IO，一个线程处理一个请求，在等待IO时会阻塞，无法处理大量请求的情况。</li><li>非阻塞IO，基础版的非阻塞IO，在等待IO时，不阻塞，一个线程处理多个请求，通过轮询来检查数据是否就绪，会占用大量CPU资源。</li><li>信号驱动IO，也是非阻塞IO，通过异步信号，而非轮询，可以降低CPU资源的消耗，但是一旦数据到达后，会向应用程序发出信息，应用程序会阻塞来处理实际的IO操作。</li><li>异步IO，非阻塞IO，相比较信号驱动，甚至IO处理都无需应用处理，而是等待数据传输完成后，通知应用，应用不阻塞。</li><li>多路复用IO，这种情况下应用在处理数据传输，还是会阻塞的，这种场景实际上是想一个应用管理多个IO请求，快速的判断需要处理哪个请求。常见的系统调用用select，poll，epoll。select主要通过固定大小的bitmap来处理文件描述符，有内核遍历文件描述符来判断是否有数据到达，并通知用户态，用户再次遍历文件描述符集合，来读取数据。epoll扩展了就绪队列，当数据到达后，用户仅需通过遍历较小规模的就绪队列来处理数据请求，降低了数据拷贝开销和时间开销。</li></ol><h1 id="Java模拟5种IO模型"><a href="#Java模拟5种IO模型" class="headerlink" title="Java模拟5种IO模型"></a>Java模拟5种IO模型</h1><blockquote><p>mark，以后再写</p></blockquote><h2 id="BIOServer"><a href="#BIOServer" class="headerlink" title="BIOServer"></a>BIOServer</h2><p>accept时会阻塞，等待客户端连接，但是后续处理使用了新的线程，故不会阻塞。但是会对于数千数万个请求分别创建线程开销过大。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.BufferedReader;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.InputStreamReader;<br><span class="hljs-keyword">import</span> java.io.PrintWriter;<br><span class="hljs-keyword">import</span> java.net.ServerSocket;<br><span class="hljs-keyword">import</span> java.net.Socket;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BIOServer</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//创建ServerSocket，监听8080</span><br>            <span class="hljs-type">ServerSocket</span> <span class="hljs-variable">serverSocket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>(<span class="hljs-number">8080</span>);<br>            System.out.println(<span class="hljs-string">&quot;Server started,waiting for connections...&quot;</span>);<br><br>            <span class="hljs-comment">//无限循环，等待客户端链接</span><br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-comment">//阻塞，等待客户端连接，当有新的客户端连接，返回一个新的socket对象</span><br>                <span class="hljs-type">Socket</span> <span class="hljs-variable">clientSocket</span> <span class="hljs-operator">=</span> serverSocket.accept();<br>                System.out.println(<span class="hljs-string">&quot;Client connected:&quot;</span> + clientSocket.getRemoteSocketAddress());<br><br>                <span class="hljs-comment">//为每个新连接的客户端创建一个新线程来处理</span><br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; handleClient(clientSocket)).start();<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//处理客户端请求</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleClient</span><span class="hljs-params">(Socket clientSocket)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//从socket中获取输入流，用于读取客户端发送的数据</span><br>            <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(clientSocket.getInputStream()));<br>            <span class="hljs-comment">//从socket中获取输出流，用于向客户端发送数据</span><br>            <span class="hljs-type">PrintWriter</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintWriter</span>(clientSocket.getOutputStream(), <span class="hljs-literal">true</span>);<br><br>            String request, response;<br>            <span class="hljs-comment">//循环读取客户端发送的每一行数据</span><br>            <span class="hljs-keyword">while</span> ((request = in.readLine()) != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;exit&quot;</span>.equals(request)) <span class="hljs-keyword">break</span>;<br>                response = <span class="hljs-string">&quot;Received:&quot;</span> + request;<br>                out.println(response);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>使用线程池优化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAX_THREADS</span> <span class="hljs-operator">=</span> <span class="hljs-number">50</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">threadPool</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(MAX_THREADS);<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">//...</span><br><br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-comment">//...</span><br><br>            <span class="hljs-comment">//使用线程池</span><br>            threadPool.execute(()-&gt;handleClient(clientSocket));<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="BIOClient"><a href="#BIOClient" class="headerlink" title="BIOClient"></a>BIOClient</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.BufferedReader;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.InputStreamReader;<br><span class="hljs-keyword">import</span> java.io.PrintWriter;<br><span class="hljs-keyword">import</span> java.net.Socket;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BIOClient</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">serverAddress</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;localhost&quot;</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">serverPort</span> <span class="hljs-operator">=</span> <span class="hljs-number">8080</span>;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Socket</span>(serverAddress, serverPort);<br><br>            <span class="hljs-comment">//从socket中获取输入输出流</span><br>            <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">stdIn</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(System.in));<br>            <span class="hljs-type">PrintWriter</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintWriter</span>(socket.getOutputStream(), <span class="hljs-literal">true</span>);<br>            <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(socket.getInputStream()));<br><br><br>            String userInput, serverResponse;<br>            <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>                System.out.println(<span class="hljs-string">&quot;Enter Message (type &#x27;exit&#x27; to quit):&quot;</span>);<br>                userInput = stdIn.readLine();<br>                <span class="hljs-keyword">if</span>(userInput==<span class="hljs-literal">null</span>||<span class="hljs-string">&quot;exit&quot;</span>.equalsIgnoreCase(userInput))<span class="hljs-keyword">break</span>;<br>                out.println(userInput);<br>                serverResponse = in.readLine();<br>                System.out.println(<span class="hljs-string">&quot;Server Response:&quot;</span> + serverResponse);<br><br>            &#125;<br>            socket.close();<br>            in.close();<br>            out.close();<br>            stdIn.close();<br><br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h1><h2 id="NIOServer"><a href="#NIOServer" class="headerlink" title="NIOServer"></a>NIOServer</h2><h2 id="NIOClient"><a href="#NIOClient" class="headerlink" title="NIOClient"></a>NIOClient</h2><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://zhuanlan.zhihu.com/p/367591714">https://zhuanlan.zhihu.com/p/367591714</a>   –只要参考这个</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>JAVA</tag>
      
      <tag>代码练习</tag>
      
      <tag>未完结</tag>
      
      <tag>多路复用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记一次修改数据库中百万条数据的经历？</title>
    <link href="/2023/10/06/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E4%BF%AE%E6%94%B9%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E7%99%BE%E4%B8%87%E6%9D%A1%E6%95%B0%E6%8D%AE%EF%BC%9F/"/>
    <url>/2023/10/06/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E4%BF%AE%E6%94%B9%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E7%99%BE%E4%B8%87%E6%9D%A1%E6%95%B0%E6%8D%AE%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>公司有一个单独的翻译程序，会针对指定的数据库中的字段进行批量翻译，生成json文件，后续去修改数据库中的不同语言的字段。<br>一次生成的数据量在50w-200w不等，因为需要人工抽查，所以没有在翻译完成后直接导入，同时也避免导入数据时造成的数据库负担。（可以在流量低谷进行导入）。<br>数据库中数据量在2kw左右。</p><h1 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h1><p>导入的所需json文件在本地机器上。预期使用pymysql导入，比较简单，代码量小。<br>需要满足的要点：</p><ol><li>记录哪些数据行被修改了。</li><li>程序异常中止时，需要保存上一次处理到的位置，可以从该位置重启。</li><li>记录插入失败的数据行，以及对应的原因。</li></ol><h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><p>希望引入最小的外部依赖，故未使用数据库或redis来进行记录。<br>成功和失败的数据行分别使用txt文件来写入。<br>每1w条读入内存，大约100MB，会执行多次数据库批量更新操作。此时会更新程序执行的位置，也是记录在txt文件中。<br>考虑到输入的文件夹在执行过程中并不会删除或新增文件，直接使用文件的位置（处理过的文件数量）作为再次重试时的开始位置。</p><p>存在问题：</p><ol><li>插入速度较慢，每1w条大约在3分钟左右。监控数据库发现，cpu利用率在1%以下，内存利用率在80%以上，使用多线程并行插入可能会造成数据库崩溃。这也反应了这种更新方式存在的问题，对数据库压力很大，压力来源于哪里，目前还不明白。</li><li>失败后没有自主重试的策略。</li><li>批量插入失败后，会将整个批次都插入失败的txt。</li></ol><h1 id="问题排查"><a href="#问题排查" class="headerlink" title="问题排查"></a>问题排查</h1><h2 id="针对内存占用高的问题"><a href="#针对内存占用高的问题" class="headerlink" title="针对内存占用高的问题"></a>针对内存占用高的问题</h2><p>实际上该数据库内存占用一直很高，只在10月4日，骤降了一天。<br>情况如下：<br><img src="https://vip.helloimg.com/images/2023/10/06/oHrtZ9.png" alt="oHrtZ9.png"><br>内存占用高的原因是因为，设置较高的<code>innodb_buffer_pool_size</code>,为6442450944B，6G，而总内存为8G。所以内存占用并不因为这次插入程序引起。<br><strong>至于为什么“骤降一天”？</strong><br>数据库重启过，而在MySQL启动时，Innodb会先分配一部分Buffer pool的大小，随着数据的访问和使用，Buffer Pool的实际占用内存会逐渐增加，直到到达配置上限。</p><h2 id="数据库写入速度慢"><a href="#数据库写入速度慢" class="headerlink" title="数据库写入速度慢"></a>数据库写入速度慢</h2><p>针对该更新语句（实际是批量执行）：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">UPDATE</span> teng_supplier <span class="hljs-keyword">SET</span> description_cn <span class="hljs-operator">=</span> &quot;xxxx&quot; <span class="hljs-keyword">WHERE</span> s_id <span class="hljs-operator">=</span> <span class="hljs-number">4582303985804775425</span>;<br></code></pre></td></tr></table></figure><p>其中s_id是一个唯一性索引。<br>预期命中的索引是<code>eq_ref</code>:MySQL能够在表中通过唯一性索引或主键索引找到一行。<br>通过explain查看执行计划，其type是<code>range</code>：只检索给定的范围，使用一个索引来选择行。实际进行了范围查询。<br>如果使用以下语句，则type为const，因为无论是B+树或者哈希索引都能在常数时间内找到该条记录。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain  <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> teng_supplier  <span class="hljs-keyword">WHERE</span> s_id<span class="hljs-operator">=</span><span class="hljs-number">4548511110629691393</span>;<br></code></pre></td></tr></table></figure><p>但是对于update语句来说，为了保证数据修改操作的安全性和一致性，数据库需要锁定一定范围内的行来保证，所以最后的type是一个范围查询。（猜测）<br>而且针对单条update语句，测得执行时间约为0.016s,执行1w条插入约为2.6分钟，似乎也没什么问题，并非由索引失效导致。</p><p>加上实际上对数据库的负载高只是个乌龙，所以可以使用多线程大胆的插入来解决该问题。</p>]]></content>
    
    
    
    <tags>
      
      <tag>开发</tag>
      
      <tag>未完结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记一次应用迁移</title>
    <link href="/2023/10/05/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%BA%94%E7%94%A8%E8%BF%81%E7%A7%BB/"/>
    <url>/2023/10/05/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%BA%94%E7%94%A8%E8%BF%81%E7%A7%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>两个Django应用与Nginx服务放在了同一台服务器上，希望迁移其中一个应用来到其他服务器上来降低资源的竞争。</p><h1 id="迁移准备"><a href="#迁移准备" class="headerlink" title="迁移准备"></a>迁移准备</h1><p><strong>过去的部署策略</strong>：Nginx + uWSGi + 两个应用服务 + 裸机<br><strong>理想状态</strong>：nginx集群 + 两个服务不同的集群<br><strong>此次的目标</strong>：仅仅希望将后台应用拆出来，不做其他处理，Nginx与应用1仍共享一台服务器。<br><strong>需要做的事情有</strong>：</p><ol><li>在新的服务器上，准备新的环境，使用docker来运行后台应用，以未来可能的迁移或集群操作。</li><li>修改nginx配置，使得其可以在<a href="http://www.xxx.com时路由到应用1，www.xxx.com:port时路由到应用2。">www.xxx.com时路由到应用1，www.xxx.com:port时路由到应用2。</a></li></ol><h1 id="操作流程"><a href="#操作流程" class="headerlink" title="操作流程"></a>操作流程</h1><h2 id="1-使用git克隆代码"><a href="#1-使用git克隆代码" class="headerlink" title="1. 使用git克隆代码"></a>1. 使用git克隆代码</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git clone xxx<br></code></pre></td></tr></table></figure><h2 id="2-更新requirements"><a href="#2-更新requirements" class="headerlink" title="2. 更新requirements"></a>2. 更新requirements</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">进入项目目录</span><br>cd /home/qxy/code/<br><span class="hljs-meta prompt_"># </span><span class="language-bash">覆盖更新requirements.txt</span><br>pipreqs . --force<br></code></pre></td></tr></table></figure><h2 id="3-准备Dockerfile"><a href="#3-准备Dockerfile" class="headerlink" title="3. 准备Dockerfile"></a>3. 准备Dockerfile</h2><p>dockerfile里需要做几件事。</p><ol><li>准备环境，python环境 + requirements.txt中所需要的依赖</li><li>将项目代码copy到镜像中</li><li>将uwsgi配置copy到镜像中</li><li>启动uWSGI</li></ol><p>Dockerfile如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs shell">FROM python:3.9<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">设置工作目录</span><br>WORKDIR /home/qxy/code/back-stage-management<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">复制并安装依赖项，然后清理不需要的文件</span><br>COPY requirements.txt ./<br>RUN pip install --no-cache-dir -r requirements.txt &amp;&amp; \<br>    apt-get autoremove -y &amp;&amp; \<br>    apt-get clean &amp;&amp; \<br>    rm -rf /var/lib/apt/lists/*<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">复制代码</span><br>COPY . .<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">配置uWSGI</span><br>COPY uwsgi.ini ./<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">定义存储uWSGI日志的卷</span><br>VOLUME /var/log/uwsgi<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">启动uWSGI服务器</span><br>CMD [&quot;uwsgi&quot;, &quot;--ini&quot;, &quot;uwsgi.ini&quot;]<br></code></pre></td></tr></table></figure><p>uWSGI如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">[uwsgi]<br>http-timeout = 300<br>http = :8000<br>chdir = /home/qxy/code/back-stage-management<br>wsgi-file = soAdmin/wsgi.py<br>processes = 4<br>threads = 2<br>logto = /var/log/uwsgi/uwsgi.log<br></code></pre></td></tr></table></figure><h2 id="4-构造镜像"><a href="#4-构造镜像" class="headerlink" title="4. 构造镜像"></a>4. 构造镜像</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker build -t your_image_name .<br></code></pre></td></tr></table></figure><h2 id="5-启动容器"><a href="#5-启动容器" class="headerlink" title="5. 启动容器"></a>5. 启动容器</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">指定暴露的端口,uwsgi日志挂载的位置,生产or开发环境</span><br>docker run -p 8000:8000 -v /home/qxy/logs/uwsgi-log:/var/log/uwsgi -e ENV=develop -e DEBUG=True your_image_name<br></code></pre></td></tr></table></figure><p>到这里为止，配置中存在三个问题：</p><ol><li>每次更新代码都要重新build镜像。<br>有两种做法，<ul><li>一种是将宿主机上的代码映射到容器内部，代码更新后重启容器即可。这在开发环境中推荐，但在生产环境中不推荐，生产环境通常将代码设置为只读，来提高安全性和降低未知因素的干扰。</li><li>通过构建pipeline，将git pull -&gt; build -&gt; run -&gt; 错误回滚（回滚至之前的镜像）流水线化。</li></ul></li><li>没有托管静态文件。-&gt; 后续通过Nginx配置来托管</li></ol><h2 id="6-配置Nginx"><a href="#6-配置Nginx" class="headerlink" title="6. 配置Nginx"></a>6. 配置Nginx</h2><p>主要要做两件事：–这里可能是伪需求，多给个域名就不需要通过网络来配置静态文件了。</p><ol><li>配置不同服务器上的Nginx和uWSGI的连接</li><li>处理Nginx托管静态文件的问题。</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>运维</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何回答面试官:你是否有过JVM调优经验？</title>
    <link href="/2023/10/05/%E5%A6%82%E4%BD%95%E5%9B%9E%E7%AD%94%E9%9D%A2%E8%AF%95%E5%AE%98-%E4%BD%A0%E6%98%AF%E5%90%A6%E6%9C%89%E8%BF%87JVM%E8%B0%83%E4%BC%98%E7%BB%8F%E9%AA%8C%EF%BC%9F/"/>
    <url>/2023/10/05/%E5%A6%82%E4%BD%95%E5%9B%9E%E7%AD%94%E9%9D%A2%E8%AF%95%E5%AE%98-%E4%BD%A0%E6%98%AF%E5%90%A6%E6%9C%89%E8%BF%87JVM%E8%B0%83%E4%BC%98%E7%BB%8F%E9%AA%8C%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<blockquote><p>通过本篇来回答以下问题</p><ol><li>是否做过JVM调优，做了哪些调整？</li><li>有没有遇到经常出现full gc的情况？</li><li>在查看JVM内存使用时，发现实际使用内存超出了你设定的内存范围，这是什么原因？</li></ol></blockquote><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>本人大多数时间都在写python，而且实际工作也偏向CRUD的一些需求，但是经常会被面试官问到：你是否有JVM调优经验？回答有吧，我作为一个校招生，也没有遇到过实际的场景；回答没有吧，又把面试官噎住了，无话可说。<br>所以，本篇文章想要整理下JVM调优常见的步骤。这样在面对面试官时可以说：“我并没有遇到过实际的场景，但是如果让我来排查调优，我会这么做…”</p><h1 id="什么情况下需要JVM调优？"><a href="#什么情况下需要JVM调优？" class="headerlink" title="什么情况下需要JVM调优？"></a>什么情况下需要JVM调优？</h1><p>从整个系统层面，首先考虑的是关系型数据库是否遇到了瓶颈（索引是否合理、是否需要引入缓存、是否需要）。<br>其次考虑的是，是否需要横向或纵向扩容（系统压力过大？系统硬件能力不足？）<br>其次是应用代码层面上的排查（代码是否存在资源浪费？逻辑上是否可优化？是否可以并行处理某些请求？）</p><p>这三步排查完，一般就结束，一般运维团队设置的JVM和机器参数，已经可以满足大多数的需求了。<br>考虑遇到大促等场景下的接口处理超时，首先考虑的是加机器，而非JVM调优。</p><p>后续会考虑以下两步：</p><ol><li>JVM层面排查并优化（主要观察JVM是否存在多次GC问题）</li><li>网络和操作系统层面排查（查看内存&#x2F;CPU&#x2F;网络、硬盘读写指标是否正常等等）</li></ol><h1 id="JVM排查优化的过程"><a href="#JVM排查优化的过程" class="headerlink" title="JVM排查优化的过程"></a>JVM排查优化的过程</h1><h2 id="调优在做什么？"><a href="#调优在做什么？" class="headerlink" title="调优在做什么？"></a>调优在做什么？</h2><p>一般是在理解JVM内存结构和各种垃圾收集器的前提下，结合现有业务来调整参数，使自己的应用能够正常稳定运行。</p><h2 id="参考的指标"><a href="#参考的指标" class="headerlink" title="参考的指标"></a>参考的指标</h2><ul><li>吞吐量</li><li>停顿时间</li><li>垃圾回收频率</li></ul><h2 id="需要调整的参数"><a href="#需要调整的参数" class="headerlink" title="需要调整的参数"></a>需要调整的参数</h2><h3 id="内存区域大小及相关策略"><a href="#内存区域大小及相关策略" class="headerlink" title="内存区域大小及相关策略"></a>内存区域大小及相关策略</h3><table><thead><tr><th>关注内容</th><th>作用</th><th>参数</th></tr></thead><tbody><tr><td>堆大小</td><td>根据应用需求调整堆的初始大小和最大大小。</td><td>-Xms<size>:设置初始堆大小，-Xmx<size>：设置最大堆大小。</td></tr><tr><td>年轻代大小</td><td>年轻代大小会影响Minor GC频率。</td><td>-Xmn<size>设置年轻代大小；-XX：NewRatio：设置老年代和年轻代的大小比例，例如-XX：NewRatio&#x3D;3代表老年代占3&#x2F;4;-XX:SurviorRatio</td></tr><tr><td>Survivor空间大小</td><td>会影响对象晋升老年代的速度</td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td>GC线程数</td><td>可以调整GC线程数以充分利用硬件资源。</td><td></td></tr><tr><td>-XX：ParallelGCThreads：设置并行垃圾回收器的线程数，通常建议设置成与逻辑处理器数量相同；-XX：ConcGCThreads：设置并发垃圾回收器线程数。</td><td></td><td></td></tr></tbody></table><h4 id="一般调整有哪些规律？"><a href="#一般调整有哪些规律？" class="headerlink" title="一般调整有哪些规律？"></a>一般调整有哪些规律？</h4><p>IO密集型可以把年轻代加大些，因为大多数对象在年轻代就会灭亡。<br>内存密集型可以把老年代加大写，因为对象存活时间会长些。</p><h3 id="垃圾回收器的选择和参数调整"><a href="#垃圾回收器的选择和参数调整" class="headerlink" title="垃圾回收器的选择和参数调整"></a>垃圾回收器的选择和参数调整</h3><table><thead><tr><th>调整内容</th><th>参数</th></tr></thead><tbody><tr><td>指定垃圾收集器</td><td>-XX：+UseG1GC：指定jvm使用垃圾收集器G1</td></tr><tr><td>停顿时间</td><td>-XX:MaxGCPauseMillis</td></tr><tr><td>全局并发标记的条件</td><td>-XX:InitiatingHeapOccupancyPercent</td></tr></tbody></table><h4 id="一般调整有哪些规律？-1"><a href="#一般调整有哪些规律？-1" class="headerlink" title="一般调整有哪些规律？"></a>一般调整有哪些规律？</h4><p><strong>先看不同垃圾回收器的特点</strong></p><ul><li>serial GC：适用于单线程或小型多线程应用，内存占用小，简单快速。</li><li>Parallel GC：默认垃圾回收器，适合多线程引用和中大型数据量的场景。</li><li>CMS：针对低延迟应用，停顿时间较短。</li><li>G1：适合于大内存的系统，可以预测停顿时间。</li></ul><p>所以：</p><ol><li>吞吐量优先：Parallel GC</li><li>低延迟优先：CMS和G1</li></ol><h2 id="遇到问题有哪些工具用来排查"><a href="#遇到问题有哪些工具用来排查" class="headerlink" title="遇到问题有哪些工具用来排查"></a>遇到问题有哪些工具用来排查</h2><p><strong>jps</strong><br>查看java进程基础信息：进程号+主类<br><strong>jstat</strong><br>统计信息：类加载、编译相关信息统计，各个内存区域GC概况和统计<br><strong>jinfo</strong><br>查看和调整java进程的运行参数<br><strong>jmap</strong><br>查看java进程的内存信息，用于将jvm的内存信息dump到文件，然后使用Memory Analyzer tool分析文件。<br><strong>jstack</strong><br>查看jvm线程信息，用于排查死锁。<br><strong>Arthas</strong><br>阿里开源诊断工具。自带图形化界面。</p><h2 id="频繁full-gc的排查优化场景"><a href="#频繁full-gc的排查优化场景" class="headerlink" title="频繁full gc的排查优化场景"></a>频繁full gc的排查优化场景</h2><h2 id="在查看JVM内存使用时，发现实际使用内存超出了设定的内存范围，这是什么原因？"><a href="#在查看JVM内存使用时，发现实际使用内存超出了设定的内存范围，这是什么原因？" class="headerlink" title="在查看JVM内存使用时，发现实际使用内存超出了设定的内存范围，这是什么原因？"></a>在查看JVM内存使用时，发现实际使用内存超出了设定的内存范围，这是什么原因？</h2><p>一般可以通过-Xms和-Xmx来设置堆大小，其中-Xmx用于表示最大堆内存大小。<br>虽然堆内存占据了jvm最大一块内存空间，但是-Xmx并不限制非堆内存，如直接内存（包括元空间）、JVM自身占用的内存（用于垃圾回收、线程管理、JIT编译）。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://www.zhihu.com/question/506566085/answer/2300951174">https://www.zhihu.com/question/506566085/answer/2300951174</a></li><li><a href="https://www.zhihu.com/question/40840626/answer/2055259142">https://www.zhihu.com/question/40840626/answer/2055259142</a>  记录了一次jvm调优的过程，推荐</li><li><a href="https://c6.y.qq.com/base/fcgi-bin/u?__=oaJGtnE4n9HT">https://c6.y.qq.com/base/fcgi-bin/u?__=oaJGtnE4n9HT</a></li><li><a href="https://www.zhihu.com/question/595741780/answer/3039384280">https://www.zhihu.com/question/595741780/answer/3039384280</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>面经</tag>
      
      <tag>未完结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一文打尽MySQL中各种锁</title>
    <link href="/2023/10/04/MySQL%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E9%94%81/"/>
    <url>/2023/10/04/MySQL%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E9%94%81/</url>
    
    <content type="html"><![CDATA[<blockquote><p>希望通过本篇回答以下问题：</p><ul><li>不同锁的适用场景，加锁、释放锁的方式？</li><li>不同锁在具体情况下会锁定哪些数据？</li><li>什么样的生产环境下会产生死锁，如何解决？</li></ul></blockquote><h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>锁的引入通常是为了处理并发问题，保证数据安全。<br><strong>MySQL中有哪些锁？</strong><br>需要分不同维度来回答。</p><ul><li>按照使用方式上：排它锁、共享锁</li><li>按照加锁粒度上：全局锁、表级锁、行级锁</li><li>按照思想上：乐观锁、悲观锁</li></ul><h1 id="按使用方式划分"><a href="#按使用方式划分" class="headerlink" title="按使用方式划分"></a>按使用方式划分</h1><h2 id="共享锁"><a href="#共享锁" class="headerlink" title="共享锁"></a>共享锁</h2><p><strong>概念</strong><br>Share lock，也叫读锁。当对象被锁定时，允许其他事务读取该对象，也允许其他事务从该对象上获取共享锁，但是不能写入。<br><strong>适用场景</strong><br>说是优势更合适：允许多个事务同时读数据，提高系统的并发读能力。<br><strong>加锁、释放锁方式</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 加锁的两种方式</span><br><span class="hljs-comment">-- 方式1</span><br><span class="hljs-keyword">select</span> ... lock <span class="hljs-keyword">in</span> share mode;<br><span class="hljs-comment">-- 方式2</span><br><span class="hljs-keyword">select</span> ... <span class="hljs-keyword">for</span> share;<br><br><span class="hljs-comment">-- 释放锁的方式</span><br><span class="hljs-comment">-- 1. 事务提交 commit;</span><br><span class="hljs-comment">-- 2. 事务回滚 rollback;</span><br><span class="hljs-comment">-- 3. 断开连接，会释放该连接中所有的锁;</span><br></code></pre></td></tr></table></figure><p>共享锁和排它锁不讨论其实际会锁定那些行,这个放到粒度里去讨论。</p><h2 id="排它锁"><a href="#排它锁" class="headerlink" title="排它锁"></a>排它锁</h2><p><strong>概念</strong><br>Extention Lock，写锁、独占锁。阻塞其他事务对当前对象的读写操作。<br><strong>适用场景</strong></p><ul><li>防止并发修改</li><li>保证唯一性约束</li><li>避免幻读</li></ul><p><strong>加锁、释放锁方式</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 加锁</span><br><span class="hljs-keyword">select</span> ... <span class="hljs-keyword">for</span> <span class="hljs-keyword">update</span>;<br><br><span class="hljs-comment">-- 释放锁的方式</span><br><span class="hljs-comment">-- 1. 事务提交 commit;</span><br><span class="hljs-comment">-- 2. 事务回滚 rollback;</span><br><span class="hljs-comment">-- 3. 断开连接，会释放该连接中所有的锁;</span><br></code></pre></td></tr></table></figure><h1 id="按粒度划分"><a href="#按粒度划分" class="headerlink" title="按粒度划分"></a>按粒度划分</h1><h2 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h2><p><strong>概念</strong><br>对整个数据库实例加锁，最大粒度的锁。<br><strong>适用场景</strong><br>谨慎使用，必须绝对必要才使用，以下情况不一定非要用全局锁，除非你需要确保完全无外界写入操作干扰。</p><ul><li>全库备份</li><li>全库导出</li></ul><p><strong>加锁、释放锁方式</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 方式1</span><br><span class="hljs-comment">-- 加锁</span><br>flush tables <span class="hljs-keyword">with</span> read lock; <span class="hljs-comment">-- FYWRL 执行完毕后，整个数据库就处于只读状态了。</span><br><span class="hljs-comment">-- 释放锁</span><br>unlock tables;<br><br><span class="hljs-comment">-- 方式2</span><br><span class="hljs-comment">-- 加锁</span><br><span class="hljs-keyword">SET</span> <span class="hljs-keyword">GLOBAL</span> READ_ONLY <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-comment">-- 释放锁</span><br><span class="hljs-keyword">SET</span> <span class="hljs-keyword">GLOBAL</span> READ_ONLY <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><p><strong>锁定的数据</strong><br>锁定数据库内所有的表，上的是读锁。</p><h2 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h2><p>包含两种：表锁和元数据锁。</p><h3 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h3><p><strong>概念</strong><br>对整张表上锁，包括读锁和写锁，需要显式加锁和释放。</p><p><strong>适用场景</strong></p><ul><li>并发要求低的场景，表锁相对来说开销小。</li><li>批量数据写入时，也可以使用表锁保证数据的一致性和完整性。</li><li>防止死锁</li><li>高并发读的场景</li></ul><p><strong>加锁、释放锁方式</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">--默认加写锁</span><br>lock tables tablenmae; <br><span class="hljs-comment">-- 加写锁</span><br>lock tables tablename write;<br><span class="hljs-comment">-- 加读锁</span><br>lock tables tablename read;<br><span class="hljs-comment">-- 释放锁</span><br>unlock tables;<br></code></pre></td></tr></table></figure><p><strong>锁定的数据</strong><br>锁定表内的所有行。</p><h3 id="MDL元数据锁"><a href="#MDL元数据锁" class="headerlink" title="MDL元数据锁"></a>MDL元数据锁</h3><p>Metadata Lock，简称MDL，为了防止对一个正在使用的数据库对象（例如，表和触发器）进行结构性更改。<br>上MDL读锁时，其他线程能够进行增删改查。<br>上MDL写锁（DDL操作时触发）时，对读锁和写锁都互斥，用来保证变更表结构操作的安全性。<br>但是，DDL语句未必一定阻塞DML语句，这里不展开说明。</p><p><strong>加锁、释放锁方式</strong><br>并非显式加锁和释放锁，而是在访问表时<strong>自动加上</strong>。</p><p><strong>锁定的数据</strong><br>一个数据库对象：一张表、视图、存储过程或其他数据库对象。</p><h3 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h3><p><strong>概念</strong><br>Innodb引擎支持多粒度锁定，允许行锁和表锁共存，为了快速判断表中是否存在行锁，InnoDB推出了意向锁。意向锁本身是一种表锁。<br>通常有两种类型：</p><ul><li>意向排他锁(IX)：接下来要在表中某些行上加排它锁</li><li>意向共享锁(IS)：接下来要在表中某些行上加共享锁</li></ul><p><strong>适用场景</strong><br>实际是好处：</p><ul><li>减少锁冲突：在事务开始时声明其意向，帮助系统判断哪些事务可能产生锁冲突。</li><li>优化锁定检查：在判断是否可以安全为一个事务分配锁时，可以快速检查表级意向锁，而无需扫描所有行锁。</li></ul><p><strong>为什么意向锁可以有以上好处？</strong></p><p><strong>加锁、释放锁方式</strong><br>Innodb自动加上。<br>加锁需要满足：</p><ul><li>获取表中行的共享锁之前，必须先获得表上的IS锁，或是更强的锁。</li><li>获取表中行的排他锁之前，必须先获取表中的IX锁。</li></ul><h3 id="AUTO-INC锁"><a href="#AUTO-INC锁" class="headerlink" title="AUTO-INC锁"></a>AUTO-INC锁</h3><p><strong>概念</strong><br>特殊的表级锁，在表中有自增列时，如果向该表插入数据，Innodb会首先获取这张表的AUTO-INC锁，等待插入完成后释放。用于保护自增列的生成值，保证唯一性和防止冲突。<br>可以使用Innodb_autoinc_lock_mode变量来配置自增锁的算法。</p><table><thead><tr><th>value</th><th>含义</th></tr></thead><tbody><tr><td>0</td><td>传统锁模式，使用AUTO-INC锁</td></tr><tr><td>1</td><td>连续锁模式，采用轻量级锁</td></tr><tr><td>2</td><td>交错锁模式（MySQL8默认），AUTO-INC和轻量级锁之间灵活切换</td></tr></tbody></table><p>如果在insert执行期间都持有锁，会降低并发度，这是传统锁模式。<br>可以在生成id后，但是insert未执行完成前，立刻释放锁，使得其他事务可以去生成新的自增id，这是轻量级锁。但是如果批量插入时，可能会导致批量插入的数据id并不自增。<br>在单行insert语句使用轻量级锁，在批量插入语句使用AUTO-INC锁，这是交错锁模式。</p><h2 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h2><p>MySQL行锁在引擎层实现，不是所有引擎都支持行锁，Innodb指出，MyISAM不支持。<br>行锁主要有四类：</p><ul><li>Record lock</li><li>Gap lock</li><li>Next-key lock</li><li>插入意向锁</li></ul><h3 id="Record-lock"><a href="#Record-lock" class="headerlink" title="Record lock"></a>Record lock</h3><p><strong>概念</strong><br>记录锁，针对索引记录的锁，锁定索引记录。</p><p><strong>锁定范围</strong><br>这要分情况讨论：<br>以以下语句为例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">WHERE</span> username<span class="hljs-operator">=</span><span class="hljs-string">&#x27;qxy&#x27;</span> <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">UPDATE</span>;<br></code></pre></td></tr></table></figure><ul><li>如果有索引：<ul><li>且该索引唯一，那么直接在该索引上Record lock。</li><li>如果索引不唯一，可能会增加间隙锁，确保事务处理期间，不会插入新的username&#x3D;’qxy’</li></ul></li><li>如果没有索引：<ul><li>升级锁的粒度，如表锁</li></ul></li></ul><h3 id="Gap-Lock"><a href="#Gap-Lock" class="headerlink" title="Gap Lock"></a>Gap Lock</h3><p><strong>概念</strong><br>间隙锁，锁定两个索引记录之间的间隙上，但是不包含该范围内的实际记录。</p><p><strong>适用场景</strong><br>用于防止其他事务插入记录到被锁定的范围内。</p><p><strong>加锁、释放锁方式</strong><br>Innodb隐式添加。</p><p><strong>锁定范围</strong><br>分情况讨论：<br>对于以下语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> employees <span class="hljs-keyword">WHERE</span> salary <span class="hljs-keyword">BETWEEN</span> <span class="hljs-number">50000</span> <span class="hljs-keyword">AND</span> <span class="hljs-number">100000</span> <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">UPDATE</span>;<br></code></pre></td></tr></table></figure><ul><li>有索引<ul><li>锁定索引记录（Record Lock），锁定索引之间的间隙</li></ul></li><li>无索引<ul><li>锁定全表扫描过程中的每一个间隙，锁定符合条件的记录。（可能会升级为表锁）</li></ul></li></ul><p>对于特殊的场景</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- id主键自增，且最大为40</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> employees <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">&gt;</span> <span class="hljs-number">50</span> <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">UPDATE</span>; <br></code></pre></td></tr></table></figure><p>不会上Record Lock，会对&gt;50的范围上锁，阻止其他事务在这个范围内插入。</p><h3 id="Next-key-Lock"><a href="#Next-key-Lock" class="headerlink" title="Next-key Lock"></a>Next-key Lock</h3><p><strong>概念</strong><br>临键锁，Record Lock + Gap Lock，用于锁定一个范围和记录本身，左开右闭。</p><p><strong>锁定范围</strong><br>以以下为例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- id有索引</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> table_name <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">5</span> <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">UPDATE</span>;<br></code></pre></td></tr></table></figure><p>会锁定id&#x3D;5记录本身，和id&lt;5的间隙，如果id&lt;5的最大记录是4，则会锁定(4,5),最终的效果是锁定（4,5]</p><h1 id="乐观锁-悲观锁"><a href="#乐观锁-悲观锁" class="headerlink" title="乐观锁&amp;悲观锁"></a>乐观锁&amp;悲观锁</h1><p>概念上的抽象，与java中思想一致。<br>乐观锁：认为不会出现竞争，不上锁，但是通过CAS+版本号等对数据进行确认。<br>悲观锁：认为一定会发生竞争，对数据修改前，上排它锁。</p><h1 id="死锁的发生和处理"><a href="#死锁的发生和处理" class="headerlink" title="死锁的发生和处理"></a>死锁的发生和处理</h1><p><strong>死锁发生的场景</strong><br>典型的是：AB商品上单修改库存的场景，且两个商品有优惠折扣绑定，需要在同时发生或者均失败，如果userA的顺序是先扣除A的库存，后扣除B的库存，userB则相反。在并发执行下可能导致死锁。<br>如果是在外贸检索平台的场景下，可能有多个程序需要去对商家的信息进行批量更新，考虑两个服务：1. 批量将商家升级为高级用户 2. 批量降低一些降低一些商家的活跃度指数。<br>将场景简化为就两个商家。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 服务1</span><br><span class="hljs-keyword">start</span> transaction;<br><span class="hljs-keyword">update</span> suppliers <span class="hljs-keyword">set</span> grade <span class="hljs-operator">=</span> &quot;Premium&quot; <span class="hljs-keyword">where</span> sid <span class="hljs-operator">=</span> <span class="hljs-number">1</span>；<span class="hljs-comment">-- 执行顺序 1</span><br><span class="hljs-keyword">update</span> suppliers <span class="hljs-keyword">set</span> grade <span class="hljs-operator">=</span> &quot;Premium&quot; <span class="hljs-keyword">where</span> sid <span class="hljs-operator">=</span> <span class="hljs-number">2</span>；<span class="hljs-comment">-- 执行顺序 3</span><br><span class="hljs-keyword">commit</span>;<br><br><span class="hljs-comment">-- 服务2</span><br><span class="hljs-keyword">start</span> transaction;<br><span class="hljs-keyword">update</span> suppliers <span class="hljs-keyword">set</span> active_level <span class="hljs-operator">=</span> <span class="hljs-number">2</span> <span class="hljs-keyword">where</span> sid <span class="hljs-operator">=</span> <span class="hljs-number">2</span>；<span class="hljs-comment">-- 执行顺序 2</span><br><span class="hljs-keyword">update</span> suppliers <span class="hljs-keyword">set</span> active_level <span class="hljs-operator">=</span> <span class="hljs-number">2</span> <span class="hljs-keyword">where</span> sid <span class="hljs-operator">=</span> <span class="hljs-number">1</span>；<span class="hljs-comment">-- 执行顺序 4</span><br><span class="hljs-keyword">commit</span>;<br></code></pre></td></tr></table></figure><p>如果交替请求资源，发生持有并请求，则会发生死锁。</p><p><strong>解决方法</strong><br>以下是一些依赖数据库管理系统自动检测和解决死锁的方法：</p><ol><li>设置超时时间innodb_lock_wait_timeout,默认是50s，当超时后，陷入死锁的事务回滚。 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SET</span> SESSION innodb_lock_wait_timeout <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure></li><li>发起死锁检测，主动回滚死锁链表中的一个事务，让其它事务可以继续执行，需要将innodb_deadlock_detect设置为on。</li></ol><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://zhuanlan.zhihu.com/p/570570330">https://zhuanlan.zhihu.com/p/570570330</a></li><li><a href="https://www.zhihu.com/search?type=content&q=%E6%95%B0%E6%8D%AE%E5%BA%93%E6%AD%BB%E9%94%81">https://www.zhihu.com/search?type=content&amp;q=%E6%95%B0%E6%8D%AE%E5%BA%93%E6%AD%BB%E9%94%81</a></li><li><a href="https://www.bilibili.com/video/BV1ah4y1d7jN/?spm_id_from=333.337.search-card.all.click&vd_source=0de7a910c6389bd641e5d95811407d7d">https://www.bilibili.com/video/BV1ah4y1d7jN/?spm_id_from=333.337.search-card.all.click&amp;vd_source=0de7a910c6389bd641e5d95811407d7d</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>不同数据库比较</title>
    <link href="/2023/10/04/%E4%B8%8D%E5%90%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E6%AF%94%E8%BE%83/"/>
    <url>/2023/10/04/%E4%B8%8D%E5%90%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E6%AF%94%E8%BE%83/</url>
    
    <content type="html"><![CDATA[<h1 id="MySQL为代表的关系型数据库"><a href="#MySQL为代表的关系型数据库" class="headerlink" title="MySQL为代表的关系型数据库"></a>MySQL为代表的关系型数据库</h1><p>先看MySQL本身，支持事务，是单机的，不考虑分库分表的情况下，能存储的数据量取决于服务器的硬盘大小。<br>如果是日增1T这种需求的数据，不适合存数据。</p><h1 id="Redis为代表的内存数据库"><a href="#Redis为代表的内存数据库" class="headerlink" title="Redis为代表的内存数据库"></a>Redis为代表的内存数据库</h1><p>读写都在内存，快，可以通过AOF和RDB进行持久化，但是最终数据都要加载到内存中，内容容量有限，不适合存储大量数据。</p><h1 id="ES为代表的分布式搜索引擎"><a href="#ES为代表的分布式搜索引擎" class="headerlink" title="ES为代表的分布式搜索引擎"></a>ES为代表的分布式搜索引擎</h1><p>主要是用于检索，但是因为其分布式，也能存储海量数据，且检索性能也好。<br>但是如果不是经常进行检索，ES会比较贵，因为数据写入ES，会进行分词。</p><h1 id="HDFS"><a href="#HDFS" class="headerlink" title="HDFS"></a>HDFS</h1><p>可以存储海量数据，但是不支持随机修改，查询效率差。mark</p><h1 id="HBase"><a href="#HBase" class="headerlink" title="HBase"></a>HBase</h1><p>NoSQL数据库，可以存储海量数据，查询和插入效率都还行，可修改。</p><h1 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h1>]]></content>
    
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis的集群模式</title>
    <link href="/2023/10/03/Redis%E7%9A%84%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F/"/>
    <url>/2023/10/03/Redis%E7%9A%84%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>参考：<a href="https://www.zhihu.com/question/590914180/answer/2976459561">https://www.zhihu.com/question/590914180/answer/2976459561</a> </p><h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>提起Redis的高可用，一般包含两层含义：</p><ol><li>数据不能丢失，或者尽量减少丢失</li><li>Redis服务不可中断</li></ol><p>前者可以通过AOF和RDB持久化保证，后者则要求Redis服务不能单点部署，这也是本文要介绍的集群模式。</p><h1 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h1><h2 id="主从模式"><a href="#主从模式" class="headerlink" title="主从模式"></a>主从模式</h2><ul><li>部署多台Redis服务器，分为主库和从库，他们之间通过主从复制，保证数据副本的一致。</li><li>读写分离：主数据库负责读写，从数据库仅负责读。</li><li>主库挂了，需要选举出从库成为主库。</li></ul><h2 id="主从同步的过程"><a href="#主从同步的过程" class="headerlink" title="主从同步的过程"></a>主从同步的过程</h2><ul><li>第一阶段：建立连接，协商同步<ul><li>从库向主库发送psync命令，要求进行数据同步</li><li>主库收到命令，响应fullresync命令，表示进行全量复制</li></ul></li><li>第二阶段：主库同步数据给从库<ul><li>主库执行bgsave，生成RDB文件，发给从库。</li><li>从库接收到RDB后，清空当前数据库，加载RDB文件</li></ul></li><li>第三阶段：主库发送新写的命令给从库<ul><li>主库发送完RDB，会把replication buffer中的修改操作发给从库，从库重新执行这些操作，实现同步。</li></ul></li></ul><h2 id="可能产生的问题"><a href="#可能产生的问题" class="headerlink" title="可能产生的问题"></a>可能产生的问题</h2><h3 id="数据不一致"><a href="#数据不一致" class="headerlink" title="数据不一致"></a>数据不一致</h3><p>主从复制是异步进行，从库如果滞后执行（网络延迟、正在执行阻塞性命令，如hgetall），则会导致主从数据不一致。</p><h3 id="读取过期数据"><a href="#读取过期数据" class="headerlink" title="读取过期数据"></a>读取过期数据</h3><p>Redis版本低于3.2时，读从库并不判断数据是否过期，导致返回过期数据。3.2滞后，若从库读到数据已经过期，从库不删除（从数据库不进行写操作），但是返回空值。</p><h3 id="多从库全量复制下主库的开销"><a href="#多从库全量复制下主库的开销" class="headerlink" title="多从库全量复制下主库的开销"></a>多从库全量复制下主库的开销</h3><p>在一主多从的模式下，很多从库要和主库进行全量复制。产生两个大的开销：1. fork进程生成RDB，会阻塞主线程的正常请求 2. 传输大的RDB文件会占用主库带宽。<br>解决：可以采用主-从-从模式</p><h3 id="主从网络中断的全量复制问题"><a href="#主从网络中断的全量复制问题" class="headerlink" title="主从网络中断的全量复制问题"></a>主从网络中断的全量复制问题</h3><p>全量复制后，会维护网络长连接，用于主库后续写命令的传输，避免频繁建立连接的开销。<br><strong>网络断开重连后，是否会再次全量复制？</strong><br>2.8版本前需要，2.8之后，重连后采用增量复制，将断连期间的写命令同步给从库。使用repl_backlog_buffer缓冲区实现。主库会记录自己写的位置，从库会记录自己读的位置。</p><h3 id="主节点故障"><a href="#主节点故障" class="headerlink" title="主节点故障"></a>主节点故障</h3><p>如果主节点故障，使用人工来将从节点晋升为主节点，并且通知应用方更新主节点地址，这个是不能被接受的。Redis2.8开始提供了哨兵机制来解决这个问题。</p><h4 id="哨兵作用"><a href="#哨兵作用" class="headerlink" title="哨兵作用"></a>哨兵作用</h4><p>特殊模式下的Redis进程，三个作用：监控、选主、通知。<br>监控：哨兵运行期间，监视所有主从结点，周期性的发送ping命令，检测主从库是否挂了，若是主从没有在规定时间内响应ping命令，则哨兵认为其下线。<br>选主：当主库下线时，需要按照一定规则选出主库。<br>通知：选出主库后，将新主库的连接信息发送给其他从库 + 客户端。</p><p><strong>哨兵本身是一个redis进程，若是哨兵挂了怎么办？</strong><br>一个哨兵对Redis节点进行监控，会出现单点问题，所以一般使用多个哨兵来监控Redis节点，哨兵之间也会互相监控。<br>哨兵之间通过发布订阅模式组成集群？（怎么理解）</p><p><strong>哨兵如何判定主库下线？</strong><br>主观下线：当一个哨兵无法在规定时间内获得目标实例的响应，该哨兵会认为该实例主观下线。<br>客观下线：当足够数量的哨兵（看配置）同意一个节点是主观下线状态，这个节点会被标记为客观下线。</p><p>若没有足够数量的哨兵同意主库已经进入主观下线，则主库主观下线状态移除。</p><p><strong>哨兵如何选主？</strong><br>主库客观下线后，会进入选主模式。<br>包含过滤和打分两个过程。<br>过滤：下线、网络不好<br>打分：从库优先级（通过slave-Priority配置）、复制进度、ID号</p><p><strong>由哪个哨兵执行主从切换呢？</strong><br>一个哨兵标记主库为主观下线，会向其他哨兵发送is-master-down-by-addr，其他哨兵会根据自己和主库的连接情况恢复Y或N，住过该哨兵获得足够多赞成票，则主库被标记为客观下线。<br>其紧接着再次发起投票，希望它可以来执行主从切换，称为leader选取。<br>哨兵称为leader需要满足两个条件</p><ul><li>拿到 n&#x2F;2 + 1的赞成票</li><li>票数需要大于等于配置文件中的quorum值</li></ul><p>如果因为网络故障等原因，没有哨兵获得足够的票数，那哨兵集群会等待一段时间（一般是哨兵故障转移超时时间的2倍），再重新进行选举。</p><p><strong>如何进行主从切换（故障转移）？</strong><br>通知选主后的节点升级为新主库，通知到其他节点（包括原主库）成为新主库的从节点。<br>通知客户端新主节点的地址。</p><h2 id="Redis-Cluster集群"><a href="#Redis-Cluster集群" class="headerlink" title="Redis Cluster集群"></a>Redis Cluster集群</h2><p>前面的哨兵模式，实现了读写分离、故障转移，保证了可用性。但是每个节点的数据是一样，浪费内存，并且不容易在线扩容。于是Redis 3.0引入了Redis Cluster集群（切片集群），对数据进行分片，每个redis上存储不同的内容，来解决在线扩容。</p><p><strong>客户端如何确定访问的数据在哪个实例上？</strong><br>mark 几种策略</p><p>主从保证的是读写分离、数据备份，哨兵保证的是可用，redis cluster为了解决的是单一主节点带来的性能瓶颈。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://zhuanlan.zhihu.com/p/647505284">https://zhuanlan.zhihu.com/p/647505284</a></li><li><a href="https://zhuanlan.zhihu.com/p/351437609">https://zhuanlan.zhihu.com/p/351437609</a>  –思路清晰</li><li><a href="https://www.zhihu.com/question/590914180/answer/2976459561">https://www.zhihu.com/question/590914180/answer/2976459561</a> 重点参考</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>Redis</tag>
      
      <tag>未完结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MQ如何保证顺序性？</title>
    <link href="/2023/10/03/MQ%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E9%A1%BA%E5%BA%8F%E6%80%A7%EF%BC%9F/"/>
    <url>/2023/10/03/MQ%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E9%A1%BA%E5%BA%8F%E6%80%A7%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="为什么需要保证MQ的顺序？"><a href="#为什么需要保证MQ的顺序？" class="headerlink" title="为什么需要保证MQ的顺序？"></a>为什么需要保证MQ的顺序？</h1><p>一般MQ被用于三种场景：</p><ul><li>削峰填谷。防止服务器被高流量打挂。</li><li>流程的异步或解耦。</li><li>Mysql通过Cannal订阅binlog，发送给MQ，进行后续的数据同步。</li></ul><p>三个场景中，只有第三个场景需要严格保证消息顺序。考虑如果两个更新请求，更换了顺序，可能结果就与预期不一致了。</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><h2 id="单线程消费"><a href="#单线程消费" class="headerlink" title="单线程消费"></a>单线程消费</h2><p>一个topic，一个partition，一个consumer，一个线程<br>例如kafka中，同一分区内保证的有序，消费者同一组内只有有一个消费者消费，并且该消费者使用单线程，则可以保证顺序。<br>存在两个问题：</p><ol><li>一旦一条消息出现问题，整个broker都被卡住。</li><li>并发度低。</li></ol><h2 id="多线程多内存（阻塞）队列"><a href="#多线程多内存（阻塞）队列" class="headerlink" title="多线程多内存（阻塞）队列"></a>多线程多内存（阻塞）队列</h2><p>主要解决并发度低的问题。<br>kafka端不做修改，将消费者改为多线程执行，创建多个内存队列。根据数据的key值将其分配到不同的队列，每个线程专门负责一个队列的数据处理，这样在保证相同key处理顺序性的同时提高了消息处理的并发度。</p><p><strong>如何是将MySQL的增量变更同步到ES中，如何设置key呢？</strong><br>使用主键ID作为KEY。<br>Cannal解析数据时，即使给出的语句没有直接操作主键，仍可以从变更的数据中提取出主键ID。</p><p>样例：<br>执行的sql语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">UPDATE</span> users <span class="hljs-keyword">SET</span> email <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;alice_new@example.com&#x27;</span> <span class="hljs-keyword">WHERE</span> username <span class="hljs-operator">=</span> &quot;qxy&quot;;<br></code></pre></td></tr></table></figure><p>Cannal解析的json：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;data&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;before&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">123</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;email&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;alice_old@example.com&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;username&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;qxy&quot;</span><br>      <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;after&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">123</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;email&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;alice_new@example.com&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;username&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;qxy&quot;</span><br>      <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;database&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;your_database_name&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;table&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;users&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;UPDATE&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;ts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1629876543210</span><span class="hljs-punctuation">,</span> <br>  <span class="hljs-attr">&quot;sql&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span> <br>  <span class="hljs-attr">&quot;sqlType&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;INTEGER&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;email&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;VARCHAR&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;username&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;VARCHAR&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;mysqlType&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;int(11)&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;email&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;varchar(255)&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;username&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;varchar(255)&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;primaryKeys&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;id&quot;</span><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br><br></code></pre></td></tr></table></figure><p>不过实际情况下，对于一张需要增量同步的大表来说，几乎不存在不携带主键或唯一索引情况下增删改操作。对于我们场景下的商家表来说，增删改操作几乎都是带着id（主键）或者sid（唯一索引）。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://www.zhihu.com/question/436381554/answer/1653179400">https://www.zhihu.com/question/436381554/answer/1653179400</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>MQ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Cannal同步MySQL增量数据至ES/MeiliSearch/Milvus</title>
    <link href="/2023/10/03/Cannal%E5%90%8C%E6%AD%A5MySQL%E5%A2%9E%E9%87%8F%E6%95%B0%E6%8D%AE%E8%87%B3ES-MeiliSearch/"/>
    <url>/2023/10/03/Cannal%E5%90%8C%E6%AD%A5MySQL%E5%A2%9E%E9%87%8F%E6%95%B0%E6%8D%AE%E8%87%B3ES-MeiliSearch/</url>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>网站使用MeiliSearch(可以理解为ES)作为搜索引擎，数据来源是MySQL中的一张大表，目前需要MeiliSearch同步MySQL的增量数据。准备选取Cannal监听binlog的方案来完成。</p><h1 id="Canal"><a href="#Canal" class="headerlink" title="Canal"></a>Canal</h1><p><strong>介绍</strong><br>基于MySQL的数据库增量日志解析，提供增量数据订阅和消费。早期诞生于阿里巴巴国内国外跨机房同步的业务需求。<br><strong>使用场景</strong></p><ul><li>数据实时备份</li><li>异构数据源（ES，Hbase）与数据库数据增量同步</li><li>业务Cache刷新（Redis），保证缓存一致性</li><li>带业务逻辑的增量数据处理，如监听某个数据的变化做一定的逻辑处理。</li></ul><p><strong>原理</strong><br>借助于MySQL主从复制原理。</p><p>主从复制分三步：</p><ol><li>master将改变记录写入binlog。</li><li>slave将master的binary log events拷贝到其中继日志（relay log）</li><li>slave重做中继日志中的事件</li></ol><p>Canal则是把自己伪装成slave结点，想master发送dump协议，等待master推送binlog。</p><p><strong>优势</strong><br>对业务逻辑无入侵，可以解决增量同步的问题。</p><p><strong>缺点</strong></p><ul><li>只能监听MySQL。</li><li>准实时同步</li><li>顺序问题</li></ul><h1 id="使用Canal同步数据至MeiliSearch"><a href="#使用Canal同步数据至MeiliSearch" class="headerlink" title="使用Canal同步数据至MeiliSearch"></a>使用Canal同步数据至MeiliSearch</h1><ul><li><p>技术：canal+kafka+springboot+终端数据库</p></li><li><p>基本的思路：</p><ul><li>开启多个canal来读取数据库同步数据库binlog文件，分发到kafka的不同主题的同一分区中。</li><li>Kafka负责消息的持久化，以及消峰。</li><li>Springboot进行业务处理：筛选并处理数据，并将其推送至不同的数据终端。</li></ul></li><li><p>流程图</p><img id="canal_structure" src="https://z1.ax1x.com/2023/10/10/pPxLurj.png" width="550" height="450" /></li><li><p>几种常见场景</p><ul><li>增加终端：有将mysql数据同步到其他终端的需求<ol><li>新增binlog监听服务，增加kafka主题</li><li>springboot新增针对新服务的处理逻辑，接入新终端</li><li>重启springboot</li><li>第一次开启全量更新，之后开启增量更新</li></ol></li><li>服务宕机恢复（可能会有数据重写或漏写的情况，比较麻烦。）</li></ul></li><li><p>关注的要点</p><ul><li>错误处理？</li><li>消费的效率？</li><li>消费的顺序？</li><li>要对服务做监控，从而快速发现问题。</li></ul></li></ul><p>–流程表有无</p><h2 id="step-1-Springboot接入canal-sever"><a href="#step-1-Springboot接入canal-sever" class="headerlink" title="step-1 Springboot接入canal-sever"></a>step-1 Springboot接入canal-sever</h2><h3 id="安装-修改MySQL配置"><a href="#安装-修改MySQL配置" class="headerlink" title="安装&#x2F;修改MySQL配置"></a>安装&#x2F;修改MySQL配置</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">已有mysql则直接调到修改配置部分</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">拉去镜像</span><br>docker pull mysql:8.0.22<br><span class="hljs-meta prompt_"># </span><span class="language-bash">运行容器</span><br>docker run --name mysql-8 -p 3306:3306 -e MYSQL_ROOT_PASSWORD=admin -d mysql:8.0.22<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">修改配置</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">进入容器</span><br>docker exec -it mysql-8 /bin/bash<br><span class="hljs-meta prompt_"># </span><span class="language-bash">下载工具</span><br>apt-get update<br>apt-get install vim<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">修改配置</span><br>vim /etc/mysql/my.cnf<br><span class="hljs-meta prompt_"># </span><span class="language-bash">修改内容如下</span><br>···<br>[mysqld]<br><span class="hljs-meta prompt_">#</span><span class="language-bash">binlog setting</span> <br>log-bin=mysql-bin  // 开启logbin<br>binlog-format=ROW  // binlog日志格式<br>server-id=1  // mysql主从备份serverId,canal中不能与此相同<br>···<br><span class="hljs-meta prompt_"># </span><span class="language-bash">重启mysql使配置生效</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">直接重启整个容器即可</span><br>docker restart mysql-8<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">进入docker和mysql，查看配置是否开启</span><br>SHOW VARIABLES LIKE &#x27;log_bin&#x27;; # 应该显示&#x27;ON&#x27;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">也可以插入一条记录，看看binlog是否记录了插入语句。</span><br></code></pre></td></tr></table></figure><h3 id="安装-配置ES"><a href="#安装-配置ES" class="headerlink" title="安装&#x2F;配置ES"></a>安装&#x2F;配置ES</h3><p>这里也可以配置MeiliSearch</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">拉取镜像</span><br>docker pull elasticsearch:7.16.2<br><span class="hljs-meta prompt_"># </span><span class="language-bash">运行es</span><br>sudo docker run -p 9200:9200 -p 9300:9300  -e discovery.type=single-node --name es-7 -d elasticsearch:7.16.2<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">进入容器修改配置</span><br>sudo docker exec -it es-7 /bin/bash<br>vim config/elasticsearch.yml<br><span class="hljs-meta prompt_"># </span><span class="language-bash">配置修改如下：</span><br>···<br>cluster.name: es-cluster<br>network.host: 0.0.0.0<br><br>node.name: node-1<br>http.port: 9200<br>http.cors.enabled: true<br>http.cors.allow-origin: &quot;*&quot;<br>node.master: true<br>node.data: true<br>···<br><span class="hljs-meta prompt_"># </span><span class="language-bash">测试</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">访问：http://127.0.0.1:9200/_mapping?pretty=<span class="hljs-literal">true</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">在线安装分词器</span><br>docker exec -it es-7<br>./bin/elasticsearch-plugin install https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v7.16.2/elasticsearch-analysis-ik-7.16.2.zip<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">网速慢，可以离线安装</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">宿主机上线下载好zip文件</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">拷贝到容器中</span><br>docker cp elasticsearch-analysis-ik-7.16.2.zip  es-7:/usr/share/elasticsearch/plugins<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">进入容器，解压</span><br>docker exec -it es-7 /bin/bash<br>cd /usr/share/elasticsearch/plugins/<br>unzip elasticsearch-analysis-ik-7.16.2.zip -d ik<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">重启容器</span><br>docker restart es-7<br></code></pre></td></tr></table></figure><h3 id="配置canal-server"><a href="#配置canal-server" class="headerlink" title="配置canal-server"></a>配置canal-server</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker pull canal/canal-server:v1.1.5<br>docker run --name canal-1.5 -p 11111:11111 --link mysql-8:mysql-8 -id canal/canal-server:v1.1.5<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">修改配置文件</span><br>docker exec -it canal-1.5 /bin/bash<br>vi canal-server/conf/example/instance.properties<br><span class="hljs-meta prompt_"># </span><span class="language-bash">配置文件修改部分如下：</span><br>···<br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># mysql serverId , v1.0.26+ will autoGen</span></span><br>canal.instance.mysql.slaveId=10<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">position info</span><br>canal.instance.master.address=mysql-8:3306<br>canal.instance.dbUsername=yourUsername<br>canal.instance.dbPassword=yourPSW<br>···<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">重启容器</span><br>docker restart canal-1.1.7<br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看日志</span><br>docker exec -it canal-1.1.7 /bin/bash<br>tail -100f canal-server/logs/example/example.log <br></code></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://www.zhihu.com/question/442830673/answer/3189925821">https://www.zhihu.com/question/442830673/answer/3189925821</a></li><li><a href="https://www.zhihu.com/question/442830673/answer/3202016337">https://www.zhihu.com/question/442830673/answer/3202016337</a></li><li><a href="https://zhuanlan.zhihu.com/p/465614745">https://zhuanlan.zhihu.com/p/465614745</a></li><li><a href="https://www.jianshu.com/p/60349ba1ceec">https://www.jianshu.com/p/60349ba1ceec</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>开发</tag>
      
      <tag>Cannal</tag>
      
      <tag>MQ</tag>
      
      <tag>未完结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>应用性能监控</title>
    <link href="/2023/10/01/%E5%BA%94%E7%94%A8%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7/"/>
    <url>/2023/10/01/%E5%BA%94%E7%94%A8%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>最近想学习下Prometheus的相关知识，正好上线的django项目没有监控，故拿该项目试试。</p><h1 id="django下配置Prometheus"><a href="#django下配置Prometheus" class="headerlink" title="django下配置Prometheus"></a>django下配置Prometheus</h1><h2 id="django应用程序端"><a href="#django应用程序端" class="headerlink" title="django应用程序端"></a>django应用程序端</h2><p>目标是提供可以Prometheus格式的数据的接口。</p><ol><li>安装库<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pip install django-prometheus<br></code></pre></td></tr></table></figure></li><li>修改django的settings的文件<br>修改installed_apps<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">INSTALLED_APPS = [<br>    <span class="hljs-comment"># ...其他的apps</span><br>    <span class="hljs-string">&#x27;django_prometheus&#x27;</span>,<br>]<br></code></pre></td></tr></table></figure>更改数据库配置<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">DATABASES = &#123;<br>    <span class="hljs-string">&quot;default&quot;</span>: &#123;<br>        <span class="hljs-comment"># &quot;ENGINE&quot;: &quot;django.db.backends.mysql&quot;, 以前的配置</span><br>        <span class="hljs-string">&quot;ENGINE&quot;</span>: <span class="hljs-string">&quot;django_prometheus.db.backends.mysql&quot;</span>, <span class="hljs-comment"># 新的配置</span><br>        <span class="hljs-comment"># ...你的其他设置，如NAME, USER等...</span><br>    &#125;,<br>&#125;<br></code></pre></td></tr></table></figure>添加中间件<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">Before中间件要放在其他中间件之前</span><br><span class="hljs-string">After中间件放在其他中间件之后</span><br><span class="hljs-string">这样可以准确地测量从请求开始到结束的整个过程，包括其他中间件和视图处理的时间。</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>MIDDLEWARE = [<br>    <span class="hljs-string">&#x27;django_prometheus.middleware.PrometheusBeforeMiddleware&#x27;</span>, <br>    <span class="hljs-comment"># ...其他中间件...</span><br>    <span class="hljs-string">&#x27;django_prometheus.middleware.PrometheusAfterMiddleware&#x27;</span>,<br>]<br></code></pre></td></tr></table></figure></li><li>使用url暴露指标<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 实际的路径是 http://127.0.0.1:8000/metrics</span><br><span class="hljs-comment"># 该url会输出Prometheus格式的指标</span><br>path(<span class="hljs-string">&quot;&quot;</span>, include(<span class="hljs-string">&#x27;django_prometheus.urls&#x27;</span>)),<br></code></pre></td></tr></table></figure></li></ol><h2 id="Prometheus端"><a href="#Prometheus端" class="headerlink" title="Prometheus端"></a>Prometheus端</h2><p>目标是定期拉取数据，并提供可视化。</p><ol><li>下载对应的版本的Prometheus</li><li>修改prometheus.yml配置文件<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">简单的一些配置</span><br>global:<br>  scrape_interval: 15s <br>  evaluation_interval: 15s <br><br>scrape_configs:<br>  - job_name: &quot;django&quot;<br><br>    # scheme defaults to &#x27;http&#x27;.<br><br>    static_configs:<br>      - targets: [&quot;127.0.0.1:8000&quot;] # 监听的服务<br><br>    # 实际上不配置，默认也是这个<br>    metrics_path: &#x27;/metrics&#x27;<br>      <br><br></code></pre></td></tr></table></figure></li><li>运行Prometheus，会提供一个Web UI<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">windows</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">默认监听9090端口</span><br>.\prometheus.exe --config.file=prometheus.yml<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">如果想修改端口</span><br>.\prometheus.exe --config.file=prometheus.yml --web.listen-address=:8080<br></code></pre></td></tr></table></figure></li></ol><p>配置很方便，但是通过实际上很多指标看不懂其意思，暂时不能帮助理解系统的运行状态。<br>另外一方面，Prometheus的数据解读和可视化并不够好，可以配合Grafana来使用。<br>后面应该单独出出一篇介绍Prometheus指标含义的。</p><h2 id="Prometheus-Grafana监控Django应用"><a href="#Prometheus-Grafana监控Django应用" class="headerlink" title="Prometheus+Grafana监控Django应用"></a>Prometheus+Grafana监控Django应用</h2><p>实际上Prometheus也还可以按照之前的方式配置，这里为了方便，使用docker来部署Prometheus和Grafana。</p><h3 id="docker-compose-yml"><a href="#docker-compose-yml" class="headerlink" title="docker-compose.yml"></a>docker-compose.yml</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3&#x27;</span><br><br><span class="hljs-attr">services:</span><br><br>  <span class="hljs-attr">prometheus:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">prom/prometheus:latest</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">prometheus</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">./prometheus.yml:/etc/prometheus/prometheus.yml</span> <span class="hljs-comment"># Prometheus.yml放在docker-compose同一个目录下</span><br>    <span class="hljs-attr">command:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;--config.file=/etc/prometheus/prometheus.yml&#x27;</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;9090:9090&quot;</span><br>    <span class="hljs-attr">networks:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">monitoring-network</span><br><br>  <span class="hljs-attr">grafana:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">grafana/grafana:latest</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">grafana</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">grafana-storage:/var/lib/grafana</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">GF_SECURITY_ADMIN_USER=user</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">GF_SECURITY_ADMIN_PASSWORD=psw</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;3000:3000&quot;</span><br>    <span class="hljs-attr">networks:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">monitoring-network</span><br>    <span class="hljs-attr">depends_on:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">prometheus</span><br><br><span class="hljs-attr">networks:</span><br>  <span class="hljs-attr">monitoring-network:</span><br>    <span class="hljs-attr">driver:</span> <span class="hljs-string">bridge</span><br><br><span class="hljs-attr">volumes:</span><br>  <span class="hljs-attr">grafana-storage:</span><br><br></code></pre></td></tr></table></figure><h3 id="prometheus-yml"><a href="#prometheus-yml" class="headerlink" title="prometheus.yml"></a>prometheus.yml</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">global:</span><br>  <span class="hljs-attr">scrape_interval:</span> <span class="hljs-string">15s</span><br><br><span class="hljs-attr">scrape_configs:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">job_name:</span> <span class="hljs-string">&#x27;prometheus&#x27;</span><br>    <span class="hljs-attr">scheme:</span> <span class="hljs-string">https</span><br>    <span class="hljs-attr">static_configs:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">targets:</span> [<span class="hljs-string">域名</span>] <span class="hljs-comment"># 目前是直接使用域名可以，ip+端口号不行，暂不知道原因</span><br></code></pre></td></tr></table></figure><h3 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker-compose -f docker-compose-monitoring.yml up -d<br></code></pre></td></tr></table></figure><h3 id="Grafana网页端配置"><a href="#Grafana网页端配置" class="headerlink" title="Grafana网页端配置"></a>Grafana网页端配置</h3><p>参考：<a href="https://blog.csdn.net/redrose2100/article/details/126970271">https://blog.csdn.net/redrose2100/article/details/126970271</a></p><h3 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h3><ul><li>通过 http:&#x2F;&#x2F;<your-host-ip>:9090 来查看 Prometheus 的 UI，</li><li>通过 http:&#x2F;&#x2F;<your-host-ip>:3000 来查看 Grafana 的 UI。<br>如果是云服务器，需要配置相应的安全组。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>运维</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM基础知识</title>
    <link href="/2023/09/30/JVM%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <url>/2023/09/30/JVM%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h1 id="Java内存区域"><a href="#Java内存区域" class="headerlink" title="Java内存区域"></a>Java内存区域</h1><h2 id="介绍下Jvm运行时数据区？"><a href="#介绍下Jvm运行时数据区？" class="headerlink" title="介绍下Jvm运行时数据区？"></a>介绍下Jvm运行时数据区？</h2><p>JDK1.7时，JVM的内存区域分为堆，方法区，java虚拟机栈，本地方法栈，程序计数器。还有不被jvm管理的本地内存。</p><h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>其中程序计数器不会出现OOM，其生命周期随线程创建而创建，随线程死亡而死亡。</p><h3 id="java虚拟机栈"><a href="#java虚拟机栈" class="headerlink" title="java虚拟机栈"></a>java虚拟机栈</h3><p>Java虚拟机栈和程序计数器一样，生命周期也随线程，除了native方法调用是通过本地方法栈以外，其他所有java方法调用都是通过栈来实现的。（需要其他运行时数据区域比如程序计数器的配合）<br>方法调用数据需要通过栈传递，每一次方法调用都会有一个对应的栈帧压入栈，方法调用结束，都会有一个栈帧被弹出。<br>每个栈帧包含：</p><ul><li>局部变量表：编译期可知的各种数据类型以及对象引用</li><li>操作数栈：用于存放方法执行过程中产生的中间计算结果</li><li>动态链接：服务一个方法要调用其他方法的场景，将常量池中指向方法的符号引用转化为其在内存地址中的直接引用</li><li>方法返回地址</li></ul><p>栈空间不是无限的，但是一般正常调用不会出问题，如果函数调用陷入无限循环，会导致栈中被压入太多栈帧，以致于深度超过java虚拟机栈的最大深度，会抛出StackOverFlowError。<br>小概率会出现OOM异常，如果栈的内存可以动态扩展，则虚拟机在动态扩展栈时无法申请到足够的内存空间，会抛出OOM异常。<br>java方法的返回方式有两种，一种是return语句正常返回，一种是抛出异常。不论哪种返回方式，都会导致栈帧被弹出。</p><h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>与虚拟机栈相似，虚拟机栈为虚拟机执行java方法服务，本地方法栈为虚拟机用到的native方法服务。其他类似栈帧的元素，可能出现的错误都参考虚拟机栈。<br>hotspot中二者合二为一。</p><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>线程共享，在虚拟机启动时创建，唯一目的是存放对象实例。<br><strong>Java的所有对象都在堆中分配？</strong><br><strong>几乎</strong>所有的对象都在堆中分配。但是有例外。<br>JDK1.7开始，默认开始逃逸分析，如果某些方法中的对象引用没有被返回或者未被外面使用（即未逃逸），那么对象可以直接在栈上分配。</p><p>Java堆是垃圾回收的主要区域，现在的收集器基本都采用分代垃圾收集算法，一般分为新生代和老年代。进一步划分的目的是更好的回收内存，或更快地分配内存。<br>JDK7及以前，堆内存通常被分为新生代、老年代、永久代。JDK8及以后，永久代被元空间取代，而元空间使用的是本地内存。<br>堆容易出现的是OOM错误，原因可能是以下几种</p><ul><li>GC Overhead Limit Exceeded：当jvm花太多时间执行垃圾回收并且只能回收很少的堆空间时，就会发生此错误。</li><li>Java heap space：创建新对象时，堆内存中的空间不足以存放新创建的对象时，就会引起此错误。（和配置的最大堆内存有关，且受制于物理内存大小。最大堆内存可通过-Xmx参数配置。）</li></ul><h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>各线程共享，《java虚拟机规范》只规定了有方法区这个概念和他的作用，方法区到底如何使用就是虚拟机自己考虑的事情。<br>当虚拟机使用一个类时，他需要读取并解析Class文件获取相关信息，再将信息存入到方法区。<br>方法区会存储已被虚拟机加载的类信息、字段信息、方法信息、常量、静态变量、即时编译器编译后的代码缓存等。<br><strong>方法区、永久代、元空间之间的关系？</strong><br>永久代和元空间是方法区的两种具体实现方式。<br>**JDK 1.8以后为什么将永久代替换为元空间呢？ –mark不太懂</p><ul><li>内存限制：永久代有一个固定的大小，当超出这个大小时， 即使本地内存仍有可用空间，仍会导致OOM错误，而元空间使用的本地内存，不受jvm内部特定上限限制。当然，受到物理内存和系统配置的限制。</li><li>自动大小调整：永久代设计中，开发者需要手动设计永久代的大小，元空间可以根据应用实际需求进行动态调整。</li></ul><p><strong>运行时常量池</strong><br>用于存放编译期生成的各种字面量和符号引用的常量池表。<br>字面量：源代码中固定值的表示法，通过字面就能知道其值的含义，字面量包括整数、浮点数和字符串字面量。<br>符号引用包括：类符号引用、字段符号引用、方法符号引用、接口方法符号。<br>常量池表在类加载后会放到方法区的运行时常量池中，运行时常量池的功能类似于传统编程语言的符号表。</p><p><strong>为什么JDK1.7之后字符串常量池和静态变量移动到了堆中？</strong><br>永久代的GC回收效率太低，只有在full gc时才执行，java程序中通常有大量被创建的字符串等待回收，将字符串常量池放到堆中，能够更高效及时回收字符串内存。</p><h2 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h2><p>特殊的内存缓冲区，通过jni在本地内存上分配。<br>不是jvm运行时数据区的一部分。但是也频繁使用，并且可能导致OOM错误。</p><h1 id="对象创建的过程"><a href="#对象创建的过程" class="headerlink" title="对象创建的过程"></a>对象创建的过程</h1><h2 id="类检查"><a href="#类检查" class="headerlink" title="类检查"></a>类检查</h2><p>首先检查new指令的参数能够在常量池中定位到这个类的符号引用，并检查符号引用代表的类是否已被加载过、解析和初始化过，如果没有，首先要进行类加载。</p><h2 id="分配内存"><a href="#分配内存" class="headerlink" title="分配内存"></a>分配内存</h2><p>对象所需的内存在类加载完成后即可确定，为对象分配空间的任务等同于把一块确定大小的内存从java堆中划分出来，有指针碰撞和空闲列表两种，分配方式由java堆是否规整决定，而java堆是否规整又由采用的GC是否带有压缩整理功能决定。<br>指针碰撞：Serial，ParNew<br>空闲列表：CMS<br>内存分配并发问题的解决</p><ul><li>CAS+失败重试</li><li>TLAB：Thread-local Allocation Buffers。通过为每个线程提供一个局部的分配空间TLAB，大大减少线程之间的竞争，从而提高对象分配的性能。</li></ul><h2 id="初始化零值"><a href="#初始化零值" class="headerlink" title="初始化零值"></a>初始化零值</h2><h2 id="设置对象头"><a href="#设置对象头" class="headerlink" title="设置对象头"></a>设置对象头</h2><p>设置对象是哪个类的实例，如何能找到类的元数据，对象的哈希码，对象的GC年龄等信息，这些信息放入对象头</p><h2 id="执行init方法"><a href="#执行init方法" class="headerlink" title="执行init方法"></a>执行init方法</h2><p>按照程序员的意愿进行初始化</p>]]></content>
    
    
    
    <tags>
      
      <tag>JAVA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java集合</title>
    <link href="/2023/09/29/Java%E9%9B%86%E5%90%88/"/>
    <url>/2023/09/29/Java%E9%9B%86%E5%90%88/</url>
    
    <content type="html"><![CDATA[<h1 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h1><p>总体分为Collection和Map两类，其中Collection存储单一元素，Map存储键值对。<br>Collection下则主要分为三类：List，Set，Queue。</p><h1 id="List"><a href="#List" class="headerlink" title="List"></a>List</h1><h2 id="常见集合"><a href="#常见集合" class="headerlink" title="常见集合"></a>常见集合</h2><p>ArrayList、LinkedList、Vector</p><h2 id="ArrayList和Array的区别？"><a href="#ArrayList和Array的区别？" class="headerlink" title="ArrayList和Array的区别？"></a>ArrayList和Array的区别？</h2><ul><li>一个是动态数组，一个是静态数组，array无法动态扩容，需要指定长度，只能按照下标访问，不具备动态添加和删除元素的能力。</li><li>ArrayList只能存储对象（基本数据类型只能使用包装类），Array既可以存储基本数据类型，又可以存储对象。</li><li>ArrayList可以使用泛型来保证类型安全，Array不行。</li></ul><h2 id="ArrayList和Vector的区别？"><a href="#ArrayList和Vector的区别？" class="headerlink" title="ArrayList和Vector的区别？"></a>ArrayList和Vector的区别？</h2><p>Vector是List的古老实现类，线程安全，因为方法使用synchronized修饰。<br>但是由于其api设计问题（不丰富，且有些方法与List方法有命名不一致的问题），所以不推荐使用。<br>需要线程安全时可以使用Collection.synchronizedList，不需要线程安全时直接使用ArrayList。<br>Collection.synchronizedList的用法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>List&lt;String&gt; synchronizedArr = Collections.synchronizedList(arr);<br>synchronizedArr.add(<span class="hljs-string">&quot;1&quot;</span>);<br>synchronizedArr.add(<span class="hljs-string">&quot;2&quot;</span>);<br>synchronizedArr.add(<span class="hljs-string">&quot;3&quot;</span>);<br></code></pre></td></tr></table></figure><h2 id="ArrayList可以添加null值吗？"><a href="#ArrayList可以添加null值吗？" class="headerlink" title="ArrayList可以添加null值吗？"></a>ArrayList可以添加null值吗？</h2><p>可以，但不建议。</p><h2 id="ArrayList和LinkedList的区别？"><a href="#ArrayList和LinkedList的区别？" class="headerlink" title="ArrayList和LinkedList的区别？"></a>ArrayList和LinkedList的区别？</h2><p>关于各种操作的复杂度，根据数组和链表来看就可以。<br>内存占用上：ArrayList的浪费存在于需要预留一定空间，LinkedList的浪费在于每个Node的开销更大（数据本身，前驱，后继）。<br>随机快速访问：ArrayList底层结构是数组，支持随机快速访问，其实现了RandomAccess(虽然是个表示，什么也没做)。<br>项目中直接使用ArrayList就行，性能更好。<br>就算是个增删场景下，LinkedList也是要找到节点后（O(n)），再执行增删(O(1)).</p><h2 id="ArrayList的扩容机制？"><a href="#ArrayList的扩容机制？" class="headerlink" title="ArrayList的扩容机制？"></a>ArrayList的扩容机制？</h2><p>因为ArrayList是动态数组，且是事先分配空间的，那么当空间不足时，则需要进行扩容。<br>扩容机制：</p><ol><li>使用无参构造方法时，初始化空数组。</li><li>当向数组中添加第一个元素，数组扩容为10（默认大小）。</li><li>当添加第11个元素时，会扩容至1.5倍左右。</li></ol><h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><h2 id="常见集合-1"><a href="#常见集合-1" class="headerlink" title="常见集合"></a>常见集合</h2><p>HashSet、LinkedHashSet、TreeSet</p><h2 id="三者有何区别？"><a href="#三者有何区别？" class="headerlink" title="三者有何区别？"></a>三者有何区别？</h2><p>HashSet底层是哈希表，无序。<br>LinkedHashSet底层是哈希表+链表，保持了元素的插入顺序。（如果插入了已有的元素，不会移动到末尾。）<br>TreeSet底层是红黑树，元素有序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//HashSet</span><br>HashSet&lt;Integer&gt; hashSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>hashSet.add(<span class="hljs-number">2</span>);<br>hashSet.add(<span class="hljs-number">1</span>);<br>hashSet.add(<span class="hljs-number">3</span>);<br>System.out.println(hashSet.toString()); <span class="hljs-comment">// [1,2,3] 不保证插入顺序</span><br><br><span class="hljs-comment">//LinkedHashSet</span><br>LinkedHashSet&lt;Integer&gt; linkedSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashSet</span>&lt;&gt;();<br>linkedSet.add(<span class="hljs-number">2</span>);<br>linkedSet.add(<span class="hljs-number">1</span>);<br>linkedSet.add(<span class="hljs-number">3</span>);<br>System.out.println(linkedSet.toString()); <span class="hljs-comment">//[2,1,3]</span><br>linkedSet.add(<span class="hljs-number">1</span>);<br>System.out.println(linkedSet.toString()); <span class="hljs-comment">//[2,1,3] 不会改变顺序</span><br><br><span class="hljs-comment">//TreeSet</span><br>TreeSet&lt;Integer&gt; treeSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeSet</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Integer&gt;() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Integer integer, Integer t1)</span> &#123;<br>        <span class="hljs-keyword">return</span> t1 - integer;<br>    &#125;<br>&#125;); <span class="hljs-comment">// 设定顺序为逆序</span><br>treeSet.add(<span class="hljs-number">2</span>);<br>treeSet.add(<span class="hljs-number">1</span>);<br>treeSet.add(<span class="hljs-number">3</span>);<br>System.out.println(treeSet.toString()); <span class="hljs-comment">//[3,2,1]</span><br></code></pre></td></tr></table></figure><h1 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h1><h2 id="常见集合-2"><a href="#常见集合-2" class="headerlink" title="常见集合"></a>常见集合</h2><p>ArrayDeque,PriorityQueue<br>其中Deque指双端队列</p><h2 id="ArrayDeque和LinkedList的区别？"><a href="#ArrayDeque和LinkedList的区别？" class="headerlink" title="ArrayDeque和LinkedList的区别？"></a>ArrayDeque和LinkedList的区别？</h2><p>都有队列的功能。</p><ol><li>底层实现不一样，ArrayDeque使用可变长数组和双指针，LinkedList使用链表。</li><li>ArrayDeque不支持存储null值，LinkedList可以。</li><li>ArrayDeque插入时可能存在扩容，到那时平均时间复杂度还是O(1),LinkedList无需扩容，但是每次插入需要申请新的堆空间，均摊性能更慢。</li></ol><h2 id="介绍下PriorityQueue？"><a href="#介绍下PriorityQueue？" class="headerlink" title="介绍下PriorityQueue？"></a>介绍下PriorityQueue？</h2><ol><li>使用二叉堆实现，底层是可变长数组</li><li>插入元素和删除堆顶元素的时间复杂度是O(logn)</li><li>非线程安全，不支持存储null和non-comparable对象</li><li>默认小顶堆，可以通过Comparator来自定义优先级。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java">PriorityQueue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Integer&gt;() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Integer integer, Integer t1)</span> &#123;<br>        <span class="hljs-keyword">return</span> t1 - integer;<br>    &#125;<br>&#125;);<br>queue.offer(<span class="hljs-number">2</span>); <br>queue.offer(<span class="hljs-number">1</span>);<br>queue.offer(<span class="hljs-number">3</span>);<br><br>System.out.println(queue.poll()); <span class="hljs-comment">// 3</span><br>System.out.println(queue.poll()); <span class="hljs-comment">// 2</span><br>System.out.println(queue.poll()); <span class="hljs-comment">// 1</span><br><br>System.out.println(queue.poll()); <span class="hljs-comment">// null</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="介绍下BlockingQueue？"><a href="#介绍下BlockingQueue？" class="headerlink" title="介绍下BlockingQueue？"></a>介绍下BlockingQueue？</h2><p>是继承自Queue的接口，特点是当队列没有元素时阻塞读请求，队列已满则阻塞写请求。<br>实现类有</p><ul><li>ArrayBlockingQueue：有界阻塞队列，需要指定容量，有公平和非公平模式</li><li>LinkedBlockingQueue：有界（指定容量大小）或无界（实际上是Integer.MAX_VALUE）</li><li>PriorityBlockingQueue: 支持优先级排序的无界阻塞队列，元素必须实现Comparable接口或在构造函数中传入Comparator对象。</li><li>SynhronousQueue：同步队列，不存储元素，每个插入操作必须等待对应的删除操作，反之删除也需要等待插入操作，用于线程间直接传递数据。</li><li>DelayQueue: 延迟队列，其中的元素只有到了指定的延迟时间，才能从队列中出队。</li></ul><p><strong>ArrayBlockingQueue和LinkedBlockingQueue的区别？</strong><br>底层实现就不说了，数组和链表的区别，内存占用上也是这两个的区别。<br>ArrayBlockingQueue必须有界，但是LinkedBlockingQueue有界无界均可。<br>ArrayBlockingQueue消费和生产使用同一把锁，LinkedBlockingQueue是锁分离的，防止生产和消费者线程之间的锁争夺。</p><p><strong>实现一个LinkedBlockingQueue？</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyBlockingQueue</span>&lt;E&gt; &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> LinkedList&lt;E&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">CAPACITY</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">empty</span> <span class="hljs-operator">=</span> lock.newCondition();<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">full</span> <span class="hljs-operator">=</span> lock.newCondition();<br><br>  MyBlockingQueue(<span class="hljs-type">int</span> capacity) &#123;<br>      <span class="hljs-built_in">this</span>.CAPACITY = capacity;<br>  &#125;<br><br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(E e)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>      lock.lock();<br>      <span class="hljs-keyword">try</span> &#123;<br>          <span class="hljs-keyword">while</span> (size == CAPACITY) &#123; <span class="hljs-comment">//满了</span><br>              full.await();<br>          &#125;<br>          queue.offer(e);<br>          size++;<br>          <span class="hljs-keyword">if</span> (size == <span class="hljs-number">1</span>) &#123;<br>              empty.signal();<br>          &#125;<br><br>      &#125; <span class="hljs-keyword">finally</span> &#123;<br>          lock.unlock();<br>      &#125;<br>  &#125;<br><br>  E <span class="hljs-title function_">take</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>      lock.lock();<br>      <span class="hljs-keyword">try</span> &#123;<br>          <span class="hljs-keyword">while</span> (size == <span class="hljs-number">0</span>) &#123;<br>              empty.await();<br>          &#125;<br><br>          <span class="hljs-type">E</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> queue.poll();<br>          size--;<br>          <span class="hljs-keyword">if</span> (size == CAPACITY - <span class="hljs-number">1</span>) &#123;<br>              full.signal();<br>          &#125;<br>          <span class="hljs-keyword">return</span> e;<br>      &#125; <span class="hljs-keyword">finally</span> &#123;<br>          lock.unlock();<br>      &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>题外话：signal和notify的使用？</strong><br>signal和await是<code>java.util.concurrent.locks.Condition</code>接口的一部分，通常与ReentrantLock结合使用。<br>notify和wait组合使用，是java对象的内建方法，与synchronized块结合使用。</p><h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><h2 id="常见集合-3"><a href="#常见集合-3" class="headerlink" title="常见集合"></a>常见集合</h2><p>HashMap,LinkedHashMap,Hashtable(废弃),TreeMap</p><h2 id="HashMap和HashTable的区别？"><a href="#HashMap和HashTable的区别？" class="headerlink" title="HashMap和HashTable的区别？"></a>HashMap和HashTable的区别？</h2><ul><li>线程安全：HashMap线程不安全，HashTable方法基本都经过Synchronized修饰，线程安全，但是更推荐使用ConcurrentHashMap。</li><li>支持null值：HashMap允许存储null的键值对，但是作为键值，null只能有一个。HashTable不允许。</li><li>初始容量：HashTable不指定容量，初始为11，每次扩充为原来的2n+1；HashMap不指定容量，初始为16，每次扩容为直接的2倍。如果指定容量，HashMap会经过特殊处理，将其扩充为2的幂次方大小。</li><li>底层数据大小：JDK1.8以后，若HashMap哈希冲突导致链表长度大于阈值（默认为8），则先判断当前数组长度，若小于64，则先进行数组扩容，若大于64，则将链表转为红黑树。HashTable无该机制。</li></ul><p><strong>为什么HashMap指定初始容量后，要将其扩充至2的幂次方？</strong><br>hash以后需要知道在数组中的位置，那么可以对数组长度做hash%length,但是如果length是2的幂次方的话，就可以利用按位与<code>&amp;</code>来提升运算效率，有以下规律：<br>hash%length &#x3D;&#x3D; hash&amp;(length-1)</p><h2 id="HashMap多线程操作导致死循环的问题？"><a href="#HashMap多线程操作导致死循环的问题？" class="headerlink" title="HashMap多线程操作导致死循环的问题？"></a>HashMap多线程操作导致死循环的问题？</h2><p>如果多个线程同时对链表进行操作，使用头插法可能会导致形成环型链表，使得查询元素的操作陷入死循环。<br>解决：JDK1.8使用尾插法来避免环型结构，但是多线程环境下，仍有数据覆盖问题，建议使用ConcurrentHashMap</p><h2 id="ConcurrentHashMap是如何解决线程安全问题的？"><a href="#ConcurrentHashMap是如何解决线程安全问题的？" class="headerlink" title="ConcurrentHashMap是如何解决线程安全问题的？"></a>ConcurrentHashMap是如何解决线程安全问题的？</h2><p>区分两个时间段：<br>JDK 1.7：底层使用分段数组+链表，对数组进行分段上锁，这样如果线程访问不同数据段的数据时，不存在锁竞争，提高了并发访问率。<br>JDK 1.8：底层使用数组+链表&#x2F;红黑树（与HashMap一样），使用node+cas+synchronized来保证并发安全，锁粒度更细，synchronized只锁定当前链表或红黑树的首结点，这样只要hash不冲突，就不会产生锁竞争。</p><p>题外话：HashTable直接对一整个数组上锁，效率低下。</p><h2 id="为什么HashMap允许null值，而ConcurrentMap不允许？–未理解"><a href="#为什么HashMap允许null值，而ConcurrentMap不允许？–未理解" class="headerlink" title="为什么HashMap允许null值，而ConcurrentMap不允许？–未理解"></a>为什么HashMap允许null值，而ConcurrentMap不允许？–未理解</h2><p>允许null值会出现二义性，比如get方法返回null，并不知道是value为null，还是该key不存在。<br>对于非并发环境下，使用null值没有问题，可以使用一个特定的桶来存储该键和值。<br>但是是并发环境下，ConcurrentHashMap有些操作需要键值对的存在性，如果允许null值，会导致操作复杂，并且多余的null检查会导致不必要的开销。</p><h1 id="Collections工具类"><a href="#Collections工具类" class="headerlink" title="Collections工具类"></a>Collections工具类</h1><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ol><li>排序</li><li>查找、替换</li><li>同步控制（不推荐，最好用juc下的并发集合）</li></ol><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><h2 id="判空"><a href="#判空" class="headerlink" title="判空"></a>判空</h2><p>判断集合内部元素是否为空，使用isEmtry()方法，而非size()&#x3D;0</p><h2 id="集合去重"><a href="#集合去重" class="headerlink" title="集合去重"></a>集合去重</h2><p>用set，而非list的contains方法。</p><h1 id="集合转数组-数组转集合"><a href="#集合转数组-数组转集合" class="headerlink" title="集合转数组&amp;&amp;数组转集合"></a>集合转数组&amp;&amp;数组转集合</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 集合转数组</span><br>List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>list.add(<span class="hljs-number">1</span>);<br>list.add(<span class="hljs-number">2</span>);<br>list.add(<span class="hljs-number">3</span>);<br><br><span class="hljs-comment">// int[] arr = list.toArray(); //错</span><br><span class="hljs-comment">// Integer[] arr = list.toArray(); //错</span><br>Integer[] arr = list.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>[<span class="hljs-number">0</span>]);<br><br><span class="hljs-comment">//数组转集合</span><br>Integer[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;; <span class="hljs-comment">//注意：需要传入对象数组，不能是基本数据类型，否则传入的是数组对象本身，而非其中的元素</span><br>List&lt;Integer&gt; list = Arrays.asList(arr);<br><br><span class="hljs-comment">//将数组转成ArrayList呢？</span><br><span class="hljs-comment">//方法1</span><br>List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(Arrays.asList(arr));<br><span class="hljs-comment">//方法2</span><br>List&lt;Integer&gt; list = List.of(arr);<br><span class="hljs-comment">// 其他使用Stream，CollectionUtils，Guava的方法暂时不考虑。</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>JAVA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java基础知识汇总</title>
    <link href="/2023/09/29/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB/"/>
    <url>/2023/09/29/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Maven入门</title>
    <link href="/2023/09/28/Maven%E5%85%A5%E9%97%A8/"/>
    <url>/2023/09/28/Maven%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>基于java平台的项目构建，依赖管理和项目信息管理。 </p><h1 id="项目构建工具"><a href="#项目构建工具" class="headerlink" title="项目构建工具"></a>项目构建工具</h1><p>Ant，Maven，Gradle</p><h1 id="四大特性"><a href="#四大特性" class="headerlink" title="四大特性"></a>四大特性</h1><ol><li>依赖管理</li><li>多模块构建</li><li>一致的项目结构</li><li>一致的构建模型和插件机制</li></ol><h1 id="ubuntu下安装maven"><a href="#ubuntu下安装maven" class="headerlink" title="ubuntu下安装maven"></a>ubuntu下安装maven</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">确保安装了java</span><br>java --version # 查看是否安装了java<br><span class="hljs-meta prompt_"># </span><span class="language-bash">下载maven压缩包</span><br>wget https://mirrors.aliyun.com/apache/maven/maven-3/3.9.4/binaries/apache-maven-3.9.4-bin.tar.gz # 使用了阿里云的镜像<br><span class="hljs-meta prompt_"># </span><span class="language-bash">解压</span><br>tar zxf apache-maven-3.9.4-bin.tar.gz<br><span class="hljs-meta prompt_"># </span><span class="language-bash">编辑环境变量</span><br>vim ~/.bashrc<br><span class="hljs-meta prompt_"># </span><span class="language-bash">在文件末尾加上</span><br>export MAVEN_HOME=/home/qxy/util/maven-3.9.4 # 改成自己的实际的路径<br>export PATH=$&#123;MAVEN_HOME&#125;/bin:$&#123;PATH&#125;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">使更改生效</span><br>source ~/.bashrc<br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看是否安装成功</span><br>mvn -v<br></code></pre></td></tr></table></figure><h1 id="maven的项目结构"><a href="#maven的项目结构" class="headerlink" title="maven的项目结构"></a>maven的项目结构</h1><table><thead><tr><th>目录</th><th>目的</th></tr></thead><tbody><tr><td>${basedir}</td><td>存放pom.xml和所有子目录</td></tr><tr><td>${basedir}&#x2F;src&#x2F;main&#x2F;java</td><td>项目java源代码</td></tr><tr><td>${basedir}&#x2F;src&#x2F;main&#x2F;resources</td><td>项目的资源，比如property文件</td></tr><tr><td>${basedir}&#x2F;src&#x2F;test&#x2F;java</td><td>项目的测试类，比如junit代码</td></tr><tr><td>${basedir}&#x2F;src&#x2F;test&#x2F;resources</td><td>测试使用的资源</td></tr></tbody></table><h1 id="maven依赖在ubuntu下的默认存储路径"><a href="#maven依赖在ubuntu下的默认存储路径" class="headerlink" title="maven依赖在ubuntu下的默认存储路径"></a>maven依赖在ubuntu下的默认存储路径</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">qxy改成实际的用户名</span><br>cd /home/qxy/.m2/repository<br></code></pre></td></tr></table></figure><h1 id="maven和java命令行工具的区别？"><a href="#maven和java命令行工具的区别？" class="headerlink" title="maven和java命令行工具的区别？"></a>maven和java命令行工具的区别？</h1><p>maven后台使用javac工具来编译java代码，但是maven处理了很多额外任务，如解析和下载依赖、运行测试、打包应用等。<br>使用maven时，不必担心手动管理项目的类路径，因为maven会自动处理，使用java命令行工具，需要手动指定路径。<br>java命令行工具本身不处理依赖管理，如果代码依赖于外部库，需要手动添加他们到类路径。<br>maven更适合于大型项目或处理复杂声明周期的项目。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">Maven</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">编译</span><br>mvn compile # 处理项目的全部依赖，并将源代码编译到target/classes下<br><span class="hljs-meta prompt_"># </span><span class="language-bash">运行</span><br>mvn exec:java -Dexec.mainClass=&quot;com.exmaple.MainClass&quot; <br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">java命令行</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">编译</span><br>javac YourClass.java # 会在当前目录下生成YourClass.class文件<br><span class="hljs-meta prompt_"># </span><span class="language-bash">运行</span><br>java YourClass # 运行编译后的程序<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>Maven</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>什么是网卡？</title>
    <link href="/2023/09/28/%E4%BB%80%E4%B9%88%E6%98%AF%E7%BD%91%E5%8D%A1/"/>
    <url>/2023/09/28/%E4%BB%80%E4%B9%88%E6%98%AF%E7%BD%91%E5%8D%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="网卡和IP地址"><a href="#网卡和IP地址" class="headerlink" title="网卡和IP地址"></a>网卡和IP地址</h1><p>网卡，又称网络适配器&#x2F;网络接口卡，作用是使计算机能够连接到网络。可以是物理设备（插在服务器上的扩展卡）或虚拟设备（在虚拟机中使用的虚拟网络适配器）。<br>IP地址是分配给网卡的，一个计算机可以有多个网卡，每个网卡有自己的IP。例如，一个计算机可以有一个以太网适配器和一个WiFi适配器，每个适配器会有自己的IP地址。<br>IP可以是静态分配（手动分配），也可以是动态分配（通过DHCP自动分配）。例如，家庭网络中的设备通常通过DHCP从路由器获得IP地址，而服务器通常使用静态IP地址来确保其地址不变。<br>总结：网络提供了计算机与网络之间的接口，而IP地址为网卡在网络上提供唯一的标识符，使其他设备可以与之通信。</p><h1 id="什么是DHCP？"><a href="#什么是DHCP？" class="headerlink" title="什么是DHCP？"></a>什么是DHCP？</h1><p>DHCP：允许服务器动态分配IP地址给客户端的网络协议。使用DHCP，设备可以在加入网络时自动获得一个IP地址，无需手动配置。</p><h1 id="家庭无线网络中谁来分配IP地址？"><a href="#家庭无线网络中谁来分配IP地址？" class="headerlink" title="家庭无线网络中谁来分配IP地址？"></a>家庭无线网络中谁来分配IP地址？</h1><p>家庭网络中通常有路由器充当DHCP服务器的角色。通常路由器使用192.168.1.1作为其IP地址，然后将192.168.1.2到192.168.1.254作为DHCP地址池，意味着路由器可以分配253个不同的IP地址。<br>简单过程：</p><ul><li>启动时请求：当一个设备连接到家庭网络时，会发送一个DHCP请求，询问一个IP地址。</li><li>分配IP地址：路由器收到请求后，会从其IP地址池中选择一个IP地址，并分配给这个设备。</li><li>租约时间：IP地址的分配不是永久的，而是有一个租期，当租期到期后，设备需要重新请求IP地址，或者请求续约当前的IP地址。</li></ul><h1 id="有多个网卡的服务器，在监听某一端口，他在监听哪个网卡上的端口呢？"><a href="#有多个网卡的服务器，在监听某一端口，他在监听哪个网卡上的端口呢？" class="headerlink" title="有多个网卡的服务器，在监听某一端口，他在监听哪个网卡上的端口呢？"></a>有多个网卡的服务器，在监听某一端口，他在监听哪个网卡上的端口呢？</h1><p>监听所有网卡或特定网卡都可以。</p><ol><li>监听所有网卡：服务器绑定到特殊地址<code>0.0.0.0</code>(IPv4)或<code>::</code>(IPv6),会监听计算机上所有网卡的指定端口。</li><li>监听特定网卡：服务器也可绑定到一个特定的ip地址，意味着只接收发往这个IP地址的连接。例如，只希望服务在内部网络上可用，并不对外部网络开放。<ul><li>比如说有两个网卡，一个连接到公共互联网<code>103.0.113.10</code>,一个连接到私有内部网络<code>10.0.0.10</code>,如果希望某个服务，比如数据库，只能从内部网络访问，可以让该服务绑定到IP<code>10.0.0.10</code>上，这样外部攻击者即使知道数据库正在运行，也无法通过公共互联网接口访问，因为服务器并没有在这个接口上监听。</li></ul></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>计算机扫盲篇</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kafka入门</title>
    <link href="/2023/09/28/Kafka%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    <url>/2023/09/28/Kafka%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="topic-主题"><a href="#topic-主题" class="headerlink" title="topic 主题"></a>topic 主题</h2><p>消息存在topic中，类似于数据库中表，通常将相同的类型的消息存储到同一个主题中。<br>半结构化的数据，某些情况下会将不同类型的消息放在同一个topic中，来满足特定的需求（如需要保证不同操作的顺序）。</p><h2 id="patition-分区"><a href="#patition-分区" class="headerlink" title="patition 分区"></a>patition 分区</h2><p>主题可以包含多个分区，使用分区实现的kafka的分布式需求，不同分区可放在不同的服务器上，可以通过调整节点的数量，来对kafka进行线性扩展。<br>分区是一个线性增长的不可变的线性日志，消息存储到分区中后不可变更，每个消息有一个offset，kafka可以通过offset来对消息进行提取，但是没法对消息的内容进行检索和查询，offset在一个分区内是递增的，且不可重复，不同分区的偏移量可以重复。</p><h1 id="record-消息"><a href="#record-消息" class="headerlink" title="record 消息"></a>record 消息</h1><p>kafka中的消息是以键值对的形式存在，键值可用于指定消息存放的分区。<br>当不指定key，key为空，kafka会以轮询的方式放到不同分区</p><h1 id="replication-副本"><a href="#replication-副本" class="headerlink" title="replication 副本"></a>replication 副本</h1><p>分区保证了kafka的可扩展性，但是分区损坏可能导致数据丢失，kafka通过副本机制保证其可靠性。<br>比如设置replication-factor&#x3D;3,则会存在3个副本，其中一个分区为主分支leader，负责数据的读写，另外两个副本follower，其仅用于数据同步。通过ISR（IN-Sync Replica list）来维护在同步的副本，若某个副本不能正常同步数据或落后较多，会从ISR中剔除，直到其赶上同步进度，再将其加入。</p><h1 id="broker-消息代理"><a href="#broker-消息代理" class="headerlink" title="broker 消息代理"></a>broker 消息代理</h1><p>负责消息的读写请求，并将数据写入到磁盘，一般一台服务器为一个broker。</p><p>下面这张图展示了Kafka cluster的相关概念。<br>该图是replication-factor&#x3D;3的情况，总共分为8个分区，每个分区有3个副本，每个broker上有一个leader结点，以及不同分区的follower结点。以brokder-0为例，他会处理p1分区的读写请求，处理p0和p2的数据同步。<br><a href="https://imgse.com/i/pPbBmgP"><img src="https://z1.ax1x.com/2023/09/28/pPbBmgP.png" alt="pPbBmgP.png"></a></p><h1 id="使用docker部署kafka"><a href="#使用docker部署kafka" class="headerlink" title="使用docker部署kafka"></a>使用docker部署kafka</h1><h2 id="1-安装docker-docker-compose"><a href="#1-安装docker-docker-compose" class="headerlink" title="1. 安装docker+docker-compose"></a>1. 安装docker+docker-compose</h2><h2 id="2-获取已经写好的docker-compose文件"><a href="#2-获取已经写好的docker-compose文件" class="headerlink" title="2. 获取已经写好的docker-compose文件"></a>2. 获取已经写好的docker-compose文件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">直接下载指定文件也行</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">克隆docker制作脚本</span><br>git clone https://github.com/wurstmeister/kafka-docker.git<br><span class="hljs-meta prompt_"># </span><span class="language-bash">进入目录查看目录文件</span><br>cd kafka-docker<br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看所有标签，找到最新版本</span><br>git tag<br><span class="hljs-meta prompt_"># </span><span class="language-bash">切换到最新版本</span><br>git checkout &lt;last_tag_name&gt;<br></code></pre></td></tr></table></figure><h2 id="3-修改docker-compose-yml的配置"><a href="#3-修改docker-compose-yml的配置" class="headerlink" title="3. 修改docker-compose.yml的配置"></a>3. 修改docker-compose.yml的配置</h2><p>修改后的版本</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">version:</span> <span class="hljs-string">&#x27;2&#x27;</span><br><span class="hljs-symbol">services:</span><br><span class="hljs-symbol">  zookeeper:</span><br><span class="hljs-symbol">    image:</span> wurstmeister/zookeeper<br><span class="hljs-symbol">    ports:</span><br>      - <span class="hljs-string">&quot;2181:2181&quot;</span><br><span class="hljs-symbol">  kafka1:</span><br><span class="hljs-symbol">    image:</span> wurstmeister/kafka:latest<br><span class="hljs-symbol">    ports:</span><br>      - <span class="hljs-string">&quot;9092:9092&quot;</span><br><span class="hljs-symbol">    environment:</span><br><span class="hljs-symbol">      KAFKA_ADVERTISED_HOST_NAME:</span> <span class="hljs-meta"># 使用自己的ip地址</span><br><span class="hljs-symbol">      KAFKA_ZOOKEEPER_CONNECT:</span> zookeeper:<span class="hljs-number">2181</span><br><span class="hljs-symbol">      KAFKA_BROKER_ID:</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">    volumes:</span><br>      - <span class="hljs-keyword">/var/</span>run/docker.sock:<span class="hljs-keyword">/var/</span>run/docker.sock<br></code></pre></td></tr></table></figure><h2 id="4-运行并测试"><a href="#4-运行并测试" class="headerlink" title="4. 运行并测试"></a>4. 运行并测试</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">启动zookeeper和kafka</span><br>docker-compose up -d<br><span class="hljs-meta prompt_"># </span><span class="language-bash">获取kafka容器的<span class="hljs-built_in">id</span></span><br>docker ps<br><span class="hljs-meta prompt_"># </span><span class="language-bash">进入kafka容器，为了方便测试可以打开两个窗口，都进入容器</span><br>docker exec -it kafka-docker-kafka1-1 /bin/bash # 其中kafka-docker-kafka1-1为容器名称<br><span class="hljs-meta prompt_"># </span><span class="language-bash">创建topic</span><br>kafka-topics.sh --create --topic test-topic --bootstrap-server localhost:9092 # 分区和副本使用了默认<br><span class="hljs-meta prompt_"># </span><span class="language-bash">生产者</span><br>kafka-console-producer.sh --topic test-topic --bootstrap-server localhost:9092 # 进入了交互页面<br><span class="hljs-meta prompt_"># </span><span class="language-bash">消费者</span><br>kafka-console-consumer.sh --topic test-topic --from-beginning --bootstrap-server localhost:9092<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">下面就可以从生产者发送消息，来让消费者消费。</span><br></code></pre></td></tr></table></figure><h1 id="消息模型"><a href="#消息模型" class="headerlink" title="消息模型"></a>消息模型</h1><p>分区是最小的并行单位。<br>一个消费者可以消费多个分区。<br>一个分区可以被多个消费者组里的消费者消费。<br>一个分区不能同时被同一个消费者组里的多个消费者消费。</p><p>发布-订阅：<br>消息需要被每个消费者都消费。（消费者分为不同组）</p><p>点对点：<br>消息仅需由一个消费者消费。（消费者放进同一个组。）</p><p>分区与消息顺序：<br>分区内的相对顺序可以保证，不同分区内的顺序无法保证。<br>可以通过设置消息的key，来确保相同的key的消息的顺序。</p><h1 id="消息传递语义"><a href="#消息传递语义" class="headerlink" title="消息传递语义"></a>消息传递语义</h1><table><thead><tr><th>语义</th><th>描述</th><th>实现</th></tr></thead><tbody><tr><td>最多一次</td><td>消息可能会丢失，永远不重复发送</td><td>消费者先提交消费位置，再读取信息；acks&#x3D;0或1</td></tr><tr><td>至少一次</td><td>消息不会丢失，但是可能会重复</td><td>消费者先读取信息，后提交消费的offset；ack&#x3D;-1或all，retries&#x3D;-1</td></tr><tr><td>精确一次</td><td>保证消息不重复不遗漏</td><td></td></tr></tbody></table><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>参数为isolation_level<br>kafka默认隔离级别为read_uncommitted</p><h1 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h1><p>序列化&amp;&amp;反序列化：将对象以二进制的方式在网络之间传输或保存到文件中，并可以根据特定的规则进行还原。</p><p>好处：</p><ul><li>节省空间，提高网络传输效率</li><li>跨语言</li><li>跨平台</li></ul><p><strong>Record header</strong><br>在某些情况下，为了保证消费的顺序，要将所有时间放在同一个主题的同一个分区中，来保证事件的顺序，使用用户ID作为分区的key，来使其位于相同分区。<br>在这种情况下，一个分区中就包含了不同类型的消息，通过主题来确定序列化的方法就不适用了。<br>可以在Record header中指定消息的类型。 </p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul><li><a href="https://www.bilibili.com/video/BV1h94y1Q7Xg/?p=14&spm_id_from=pageDriver&vd_source=0de7a910c6389bd641e5d95811407d7d">https://www.bilibili.com/video/BV1h94y1Q7Xg/?p=14&amp;spm_id_from=pageDriver&amp;vd_source=0de7a910c6389bd641e5d95811407d7d</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Kafka</tag>
      
      <tag>学习笔记</tag>
      
      <tag>MQ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>万得-秋招-java开发一面</title>
    <link href="/2023/09/26/%E4%B8%87%E5%BE%97-%E7%A7%8B%E6%8B%9B-java%E5%BC%80%E5%8F%91%E4%B8%80%E9%9D%A2/"/>
    <url>/2023/09/26/%E4%B8%87%E5%BE%97-%E7%A7%8B%E6%8B%9B-java%E5%BC%80%E5%8F%91%E4%B8%80%E9%9D%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>问的问题都很基础，没有深挖，没有问项目，但是答的也很差。<br><strong>难度</strong>：⭐☆☆☆☆<br><strong>学到的知识</strong>：⭐☆☆☆☆</p><h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><h2 id="1-java的基本数据类型？分别占几个字节？"><a href="#1-java的基本数据类型？分别占几个字节？" class="headerlink" title="1. java的基本数据类型？分别占几个字节？"></a>1. java的基本数据类型？分别占几个字节？</h2><table><thead><tr><th>基本数据类型</th><th>字节</th></tr></thead><tbody><tr><td>byte</td><td>1</td></tr><tr><td>short</td><td>2</td></tr><tr><td>int</td><td>4</td></tr><tr><td>long</td><td>8</td></tr><tr><td>float</td><td>4</td></tr><tr><td>double</td><td>8</td></tr><tr><td>char</td><td>2</td></tr><tr><td>boolean</td><td>1，不一定</td></tr></tbody></table><h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><h2 id="1-介绍下tcp三次握手？"><a href="#1-介绍下tcp三次握手？" class="headerlink" title="1. 介绍下tcp三次握手？"></a>1. 介绍下tcp三次握手？</h2><h2 id="2-tcp粘包问题？"><a href="#2-tcp粘包问题？" class="headerlink" title="2. tcp粘包问题？"></a>2. tcp粘包问题？</h2><p>从应用程序角度：TCP是基于流的协议，所以数据是作为无边界的连续流发送的，并非独立的包。<br>从网络传输角度：数据是被分段放入tcp包进行传输的，Nagle是一个性能优化算法，用于减少小的tcp段的数量，他的工作原理是等待足够的数据可供发送，从而组成一个更大的段，除非之前发送的段已经被确认。他在尝试减少网络上小tcp端的数量，因为大量的小段会导致网络拥塞和效率低下。但这种算法也同时造成了粘包问题，多个消息粘在一起。<br>同时接收端缓冲也会导致粘包，接收端对额缓冲区不是立即被读取，或者被部分读取时，多个包会累积在一起。<br><strong>如何解决粘包问题？</strong></p><ol><li>使用固定长度的包头，比如消息前4个字节用于表示消息长度。接收方先读取4字节，然后读取实际的数据。</li><li>在消息尾部加上特定换行符。</li><li>在应用层增加长度字段或其他类型的消息边界。</li><li>使用更高级协议，比如websocket或者http2</li><li>关闭Nagle算法，不推荐。</li></ol><h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h2 id="1-平时创建的索引类型有哪些？"><a href="#1-平时创建的索引类型有哪些？" class="headerlink" title="1. 平时创建的索引类型有哪些？"></a>1. 平时创建的索引类型有哪些？</h2><p>主键索引<br>唯一索引<br>复合索引<br>全文索引<br>外键索引<br>前缀索引</p><h2 id="2-sql书写优化的手段？"><a href="#2-sql书写优化的手段？" class="headerlink" title="2. sql书写优化的手段？"></a>2. sql书写优化的手段？</h2><ol><li>选择性使用字段，避免select *</li><li>使用索引+避免各种索引失效的情况</li><li>使用limit减少返回的数据。</li><li>其他关于join，or，子查询的问题并非绝对，可以单独整理一篇在不同场景下的sql书写。</li></ol><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h2 id="1-描述下什么是时间复杂度？"><a href="#1-描述下什么是时间复杂度？" class="headerlink" title="1. 描述下什么是时间复杂度？"></a>1. 描述下什么是时间复杂度？</h2><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="1-python和java的区别？"><a href="#1-python和java的区别？" class="headerlink" title="1. python和java的区别？"></a>1. python和java的区别？</h2><ol><li>语法和可读性上<br>python的语法简介明了，可读性更好。java的语法更详细和严格，并且python因为是动态语言，很多类型错误只在运行时被检测到，java可以在编译时就捕获，所以python写起来快，debug比java麻烦。</li></ol><h2 id="2-面向对象和面向过程的区别？"><a href="#2-面向对象和面向过程的区别？" class="headerlink" title="2. 面向对象和面向过程的区别？"></a>2. 面向对象和面向过程的区别？</h2><p>面向对象提高了模块化、封装、重用性和维护性，且更直观，更容易模拟现实世界的系统和流程，在大型、需要团队写作和长期维护的项目中尤其受欢迎。</p><h2 id="3-个人优缺点？"><a href="#3-个人优缺点？" class="headerlink" title="3. 个人优缺点？"></a>3. 个人优缺点？</h2>]]></content>
    
    
    
    <tags>
      
      <tag>一面</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>电信-秋招-一面</title>
    <link href="/2023/09/26/%E7%94%B5%E4%BF%A1-%E7%A7%8B%E6%8B%9B-%E4%B8%80%E9%9D%A2/"/>
    <url>/2023/09/26/%E7%94%B5%E4%BF%A1-%E7%A7%8B%E6%8B%9B-%E4%B8%80%E9%9D%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>总体难度比较简单，时间很短，20分钟不到,要补充docker和消息中间件的相关知识。</p><p><strong>难度</strong>：⭐☆☆☆☆<br><strong>学到的知识</strong>：⭐☆☆☆☆</p><h1 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h1><h2 id="1-介绍项目难点？"><a href="#1-介绍项目难点？" class="headerlink" title="1. 介绍项目难点？"></a>1. 介绍项目难点？</h2><h2 id="2-为什么使用RocketMQ？与其他消息中间件的对比？"><a href="#2-为什么使用RocketMQ？与其他消息中间件的对比？" class="headerlink" title="2. 为什么使用RocketMQ？与其他消息中间件的对比？"></a>2. 为什么使用RocketMQ？与其他消息中间件的对比？</h2><p>学生完成在线考试并提交答案时，考试数据会被发送到RocketMQ中，后台评分系统作为消费者，从RocketMQ中拉去数据并进行评分，分析学生答题情况，并生成报告。因为分析学生答题情况比较慢，并且可能出现大量学生同时提交的情况，所以使用RocketMQ来消峰，并用于异步处理。</p><h2 id="3-docker的使用场景？如何暴露端口？"><a href="#3-docker的使用场景？如何暴露端口？" class="headerlink" title="3. docker的使用场景？如何暴露端口？"></a>3. docker的使用场景？如何暴露端口？</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 运行web服务器，并将容器的80端口映射到主机的8080端口</span><br>docker run -p <span class="hljs-number">8080</span>:<span class="hljs-number">80</span> nginx<br><span class="hljs-comment">//映射多个端口，可多次使用-p</span><br>docker run -p <span class="hljs-number">8080</span>:<span class="hljs-number">80</span> -p <span class="hljs-number">8443</span>:<span class="hljs-number">443</span> nginx<br><span class="hljs-comment">//动态端口映射，不关心主机映射的具体端口，希望Docker为主机选择一个端口</span><br>docker run -p <span class="hljs-number">80</span> nginx<br><span class="hljs-comment">//使用docker port命令来查看docker为你选择的端口</span><br>docker port nginx <span class="hljs-number">80</span><br><br><span class="hljs-comment">//创建并启动容器</span><br>docker run [options] images [command] [arg...]<br><span class="hljs-comment">//启动/停止/重启一个或多个已经停止的容器</span><br>docker start/stop/restart [container_id]<br><span class="hljs-comment">//列出容器</span><br>docker ps  <span class="hljs-comment">//只显示运行的的</span><br>docker ps -a <span class="hljs-comment">//显示所有，包括已停止的</span><br><span class="hljs-comment">//删除容器</span><br>docker rm [container_id]<br><span class="hljs-comment">//查看日志</span><br>docker logs [container_id]<br><span class="hljs-comment">//在正在运行的容器中执行命令</span><br>docker exec -it [container_id] /bin/bash<br><br><span class="hljs-comment">//删除镜像</span><br>docker rmi [image_id]<br><span class="hljs-comment">//拉取镜像</span><br>docker pull [image_id]<br><span class="hljs-comment">//本地镜像推送到注册中心</span><br>docker push [image_name]<br><span class="hljs-comment">//从dockerfile创建镜像</span><br>docker build -t [image_name:tag] [path_to_dockerfile]<br><br><span class="hljs-comment">//网络，volume，docker-compose相关的暂不列出</span><br></code></pre></td></tr></table></figure><h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><h2 id="1-创建线程的方式？优缺点？"><a href="#1-创建线程的方式？优缺点？" class="headerlink" title="1. 创建线程的方式？优缺点？"></a>1. 创建线程的方式？优缺点？</h2><p>简写</p><ol><li>继承Thread：会占用继承的名额，Java是单继承的</li><li>实现Runnable</li><li>使用FutureTask和Callable：可以获取结果</li></ol><h2 id="2-线程池的参数？"><a href="#2-线程池的参数？" class="headerlink" title="2. 线程池的参数？"></a>2. 线程池的参数？</h2><p>简写</p><ol><li>核心线程数</li><li>最大线程数</li><li>阻塞队列</li><li>keepAliveTime和unit</li><li>线程工厂</li><li>拒绝策略</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>面经</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java异常处理</title>
    <link href="/2023/09/25/Java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    <url>/2023/09/25/Java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="异常的分类"><a href="#异常的分类" class="headerlink" title="异常的分类"></a>异常的分类</h1><p>均继承自Throwable。</p><table><thead><tr><th>类型</th><th>描述</th><th>常见类</th></tr></thead><tbody><tr><td>编译时异常</td><td>超出程序员控制的情况，例如试图打开不存在的文件，网络连接或数据库连接问题，通过强制程序员处理或声明这些异常，来确保这些问题被正确处理。编译器要求调用可以抛出编译时异常的方法和代码必须放在try-catch或在方法声明中使用后throws，否则无法编译通过</td><td>IOException,SQLException,FileNoeFoundException</td></tr><tr><td>运行时异常</td><td>编译器不强制捕获或声明，由编程错误导致，比如除0,或者访问null引用，意味着有代码要修复</td><td>NullPointerException,ArithmeticException,ArrayIndexOutOfBoundsException</td></tr><tr><td>错误</td><td>由Java虚拟机生成并抛出的异常，表示严重的问题，不是由应用程序正常操作引起的，通常指示有关java运行时环境的问题，比如说系统资源不足，类定义不兼容，程序不对其做处理</td><td>OutOfMemoryError，StackOverflowError，NoClassDefFoundError</td></tr></tbody></table><h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><h2 id="1-自己处理异常"><a href="#1-自己处理异常" class="headerlink" title="1. 自己处理异常"></a>1. 自己处理异常</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExceptionDemo</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;code 1&quot;</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>        <span class="hljs-type">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">3</span>];<br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(i / <span class="hljs-number">0</span>);<br>            System.out.println(arr[<span class="hljs-number">10</span>]);<br>            System.out.println(str.length());<br>        &#125; <span class="hljs-keyword">catch</span> (ArithmeticException e) &#123;<br>            System.out.println(<span class="hljs-string">&quot;除数为0&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (ArrayIndexOutOfBoundsException e) &#123;<br>            System.out.println(<span class="hljs-string">&quot;数组下标越界&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (NullPointerException e)&#123;<br>            System.out.println(<span class="hljs-string">&quot;空指针异常&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e)&#123; <span class="hljs-comment">// 捕捉前面忽略的异常类型</span><br>            e.printStackTrace();<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;code 2&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-将异常抛出"><a href="#2-将异常抛出" class="headerlink" title="2. 将异常抛出"></a>2. 将异常抛出</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExceptionDemo3</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(cal());<br>        &#125; <span class="hljs-keyword">catch</span> (ArithmeticException e) &#123;<br>            System.out.println(<span class="hljs-string">&quot;除数为0&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">cal</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ArithmeticException &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> a / b;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="throw，throws和Throwable"><a href="#throw，throws和Throwable" class="headerlink" title="throw，throws和Throwable"></a>throw，throws和Throwable</h1><table><thead><tr><th></th><th>描述</th><th>用途</th></tr></thead><tbody><tr><td>throw</td><td>关键字</td><td>显式地抛出异常</td></tr><tr><td>throws</td><td>关键字</td><td>用于声明方法可能会抛出异常，通知方法调用者可能需要进一步处理或抛出异常</td></tr><tr><td>Throwable</td><td>错误和异常的超类</td><td>用作异常和错误类的基类，在java中，只有Throwbale及其子类的实例可以被throw关键字抛出，被catch关键字捕获</td></tr></tbody></table><h1 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExceptionDemo4</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(test()); <span class="hljs-comment">// 2</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            x++;<br>            <span class="hljs-comment">// System.exit(0);</span><br>            <span class="hljs-keyword">return</span> x; <span class="hljs-comment">// return 2</span><br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            ++x;<br>            <span class="hljs-comment">// 不会改变try中返回的结果</span><br>            <span class="hljs-comment">// 一旦try中的代码块被执行，finally就会执行，除非出现了System.exit()</span><br>            System.out.println(x); <span class="hljs-comment">// 3</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>try中return和finally的执行顺序？</strong><br>return代码执行时会将局部变量保存在栈帧的顶部，然后finally修改的还是原来的栈帧位置的局部变量，最终返回的信息还是栈帧顶部的变量。所以finally在return关键字之后执行，但是不改变栈帧顶部信息。<br><strong>如何try和finally中都有return呢？</strong><br>finally中的return返回的是finally中的局部变量的信息，即finally中的return会覆盖掉try中的return。</p><table><thead><tr><th>相似概念</th><th>描述</th></tr></thead><tbody><tr><td>final</td><td>关键字，修饰的类不能被继承，修饰的方法不能被重写，修饰的变量变常量</td></tr><tr><td>finally</td><td>异常处理结构的一部分，与try-catch一起使用，表示最终执行的代码，常用来做资源的释放</td></tr><tr><td>finalize</td><td>Object类中的方法，用于垃圾回收。当GC决定回收摸一个对象时，该对象的finalize方法会被调用，给予对象在销毁前执行某些操作的机会。不被推荐使用</td></tr></tbody></table><h1 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h1><p>Java中的异常都是Throwable，Exception，RuntimeException的子类，创建自定义异常，就是创建对应的子类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExceptionDemo4</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            getScore();<br>        &#125; <span class="hljs-keyword">catch</span> (ScoreException e) &#123;<br>            System.out.println(e.getMessage());<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getScore</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ScoreException &#123;<br>        <span class="hljs-type">double</span> <span class="hljs-variable">score</span> <span class="hljs-operator">=</span> <span class="hljs-number">999</span>;<br>        <span class="hljs-keyword">if</span>(score&lt;<span class="hljs-number">0</span>||score&gt;<span class="hljs-number">100</span>)&#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ScoreException</span>(<span class="hljs-string">&quot;分数越界&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> score;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ScoreException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Exception</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ScoreException</span><span class="hljs-params">()</span>&#123;<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ScoreException</span><span class="hljs-params">(String message)</span>&#123;<br>        <span class="hljs-built_in">super</span>(message);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>JAVA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>牛客相关面经整理-0925</title>
    <link href="/2023/09/25/%E7%89%9B%E5%AE%A2%E7%9B%B8%E5%85%B3%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86-0925/"/>
    <url>/2023/09/25/%E7%89%9B%E5%AE%A2%E7%9B%B8%E5%85%B3%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86-0925/</url>
    
    <content type="html"><![CDATA[<h1 id="java"><a href="#java" class="headerlink" title="java"></a>java</h1><h2 id="1-jwt怎么实现单点登录？"><a href="#1-jwt怎么实现单点登录？" class="headerlink" title="1. jwt怎么实现单点登录？"></a>1. jwt怎么实现单点登录？</h2><h2 id="2-ArrayList和LinkedList的区别？"><a href="#2-ArrayList和LinkedList的区别？" class="headerlink" title="2. ArrayList和LinkedList的区别？"></a>2. ArrayList和LinkedList的区别？</h2><h2 id="3-java的并发机制，响应式编程？"><a href="#3-java的并发机制，响应式编程？" class="headerlink" title="3. java的并发机制，响应式编程？"></a>3. java的并发机制，响应式编程？</h2><h2 id="4-GC中cms和g1的比较"><a href="#4-GC中cms和g1的比较" class="headerlink" title="4. GC中cms和g1的比较"></a>4. GC中cms和g1的比较</h2><h2 id="5-CountDownLatch、CyclicBarrieer、Semaphore分别如何使用？"><a href="#5-CountDownLatch、CyclicBarrieer、Semaphore分别如何使用？" class="headerlink" title="5. CountDownLatch、CyclicBarrieer、Semaphore分别如何使用？"></a>5. CountDownLatch、CyclicBarrieer、Semaphore分别如何使用？</h2><h2 id="6-Xss的含义？线上项目是否有频繁full-gc？一个Springboot至少有几个线程？"><a href="#6-Xss的含义？线上项目是否有频繁full-gc？一个Springboot至少有几个线程？" class="headerlink" title="6.-Xss的含义？线上项目是否有频繁full gc？一个Springboot至少有几个线程？"></a>6.-Xss的含义？线上项目是否有频繁full gc？一个Springboot至少有几个线程？</h2><h2 id="7-元空间的收缩程度？"><a href="#7-元空间的收缩程度？" class="headerlink" title="7. 元空间的收缩程度？"></a>7. 元空间的收缩程度？</h2><h2 id="8-Spring注入-代理模式-事务注解-A调用被事务修饰的B过程？"><a href="#8-Spring注入-代理模式-事务注解-A调用被事务修饰的B过程？" class="headerlink" title="8. Spring注入-&gt;代理模式-&gt;事务注解-&gt;A调用被事务修饰的B过程？"></a>8. Spring注入-&gt;代理模式-&gt;事务注解-&gt;A调用被事务修饰的B过程？</h2><h2 id="9-Exception和Error的区别？可以抛出自制的Error吗，会被捕获吗？"><a href="#9-Exception和Error的区别？可以抛出自制的Error吗，会被捕获吗？" class="headerlink" title="9. Exception和Error的区别？可以抛出自制的Error吗，会被捕获吗？"></a>9. Exception和Error的区别？可以抛出自制的Error吗，会被捕获吗？</h2><p>Error通常由运行时环境导致，应用程序不需要捕获，也无法处理，常见的Error有StackOverflowError&#x2F;OutOfMemoryError&#x2F;NoClassFoundError。<br>异常通常需要由应用程序捕获并处理，分为编译时异常和运行时异常，其中编译时异常需要try-catch或throw显示抛出异常，一般超出程序员的控制范围，比如说网络连接、IO连接、文件不存在等；运行时异常不强制要求捕获，通常由编程错误导致，比如说空指针或者说除0错误。</p><h2 id="10-HashMap可以保存null-key或value吗？CocurrentHashMap可以存null值吗？"><a href="#10-HashMap可以保存null-key或value吗？CocurrentHashMap可以存null值吗？" class="headerlink" title="10. HashMap可以保存null key或value吗？CocurrentHashMap可以存null值吗？"></a>10. HashMap可以保存null key或value吗？CocurrentHashMap可以存null值吗？</h2><h2 id="11-Spring中事务的隔离传播方式默认为？"><a href="#11-Spring中事务的隔离传播方式默认为？" class="headerlink" title="11. Spring中事务的隔离传播方式默认为？"></a>11. Spring中事务的隔离传播方式默认为？</h2><h2 id="12-两个事务，事务A调用事务B，若事务B回滚了，事务A会回滚吗？"><a href="#12-两个事务，事务A调用事务B，若事务B回滚了，事务A会回滚吗？" class="headerlink" title="12. 两个事务，事务A调用事务B，若事务B回滚了，事务A会回滚吗？"></a>12. 两个事务，事务A调用事务B，若事务B回滚了，事务A会回滚吗？</h2><h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><h2 id="1-tcp三次握手可以减少为两次吗？"><a href="#1-tcp三次握手可以减少为两次吗？" class="headerlink" title="1. tcp三次握手可以减少为两次吗？"></a>1. tcp三次握手可以减少为两次吗？</h2><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="1-一致性哈希？"><a href="#1-一致性哈希？" class="headerlink" title="1. 一致性哈希？"></a>1. 一致性哈希？</h2><h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h2 id="1-MySql的隔离级别？如何实现？-mark，要仔细看，讲的不太对"><a href="#1-MySql的隔离级别？如何实现？-mark，要仔细看，讲的不太对" class="headerlink" title="1. MySql的隔离级别？如何实现？-mark，要仔细看，讲的不太对"></a>1. MySql的隔离级别？如何实现？-mark，要仔细看，讲的不太对</h2><p>默认隔离级别是可重复读。共有4个隔离级别：</p><ol><li>读未提交：不用处理</li><li>读已提交：短暂共享锁进行读操作，但是在读操作后立刻释放。</li><li>可重复读：<strong>事务</strong>过程中使用共享锁，事务结束后才释放。</li><li>串行化：使用范围锁锁定虽有被访问的行，直到事务结束。</li></ol><h2 id="2-Mysql单条insert语句是不是事务？"><a href="#2-Mysql单条insert语句是不是事务？" class="headerlink" title="2. Mysql单条insert语句是不是事务？"></a>2. Mysql单条insert语句是不是事务？</h2><p>是事务，在autocommit开启的情况下（默认开启），insert，update，delete都是隐式事务。<br>通过start transaction声明的是显式事务。</p><h2 id="3-where中有or，且包含索引，查询过程是怎样的？"><a href="#3-where中有or，且包含索引，查询过程是怎样的？" class="headerlink" title="3. where中有or，且包含索引，查询过程是怎样的？"></a>3. where中有or，且包含索引，查询过程是怎样的？</h2><p>需要分情况讨论，对于下面这个例子</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> students <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">5</span> <span class="hljs-keyword">or</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Alice&#x27;</span>;<br></code></pre></td></tr></table></figure><ol><li>如果id和name包含在联合索引中，查询优化器可能会使用这个联合索引来加速索引。</li><li>如果id和name有各自的索引，可能会使用index merge策略，会分别查询符合id和name查询条件的记录，然后合并结果集。</li><li>如果只有一个有索引，那么会进行全表扫描。</li></ol><p>对于各种情况下，查询优化器都可能基于多种因素，比如表的统计数据、查询选择性、涉及的数据量来决定不使用索引。</p><h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="1-僵尸进程是什么？如何排查？"><a href="#1-僵尸进程是什么？如何排查？" class="headerlink" title="1. 僵尸进程是什么？如何排查？"></a>1. 僵尸进程是什么？如何排查？</h2><p>僵尸进程是指进程已经结束，但其进程描述符仍保留在系统中，因为父进程尚未询问其终止状态，所以他仍然保留在进程表中。<br><strong>特点:</strong></p><ol><li>不占用物理资源，仅占用一个进程表项</li><li>不进行任何活动，只等待被其父进程收割</li><li>若父进程结束，则init进程（pid为1）成为其新的父进程，并很快收割他。</li></ol><p><strong>产生的原因：</strong><br>进程完成执行并终止后，会通过exit系统调用将其退出状态返回给其父进程，父进程通过wait系统的系统调用来获取这个状态。如果父进程不立即调用wait，那么终止的进程就会变成僵尸进程。<br><strong>如何排查僵尸进程？</strong></p><ol><li>ps aux | grep ‘Z’ &#x2F;&#x2F; 僵尸进程在状态列会被标记为’Z’</li></ol><p>僵尸进程不是大问题，因为他们几乎不消耗资源，但如果有大量的僵尸进程，可能会占用所有的进程标识符，以至于系统无法启动新的进程。</p><h1 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h1><h2 id="1-redis使用zset，遇到大key怎么处理？"><a href="#1-redis使用zset，遇到大key怎么处理？" class="headerlink" title="1. redis使用zset，遇到大key怎么处理？"></a>1. redis使用zset，遇到大key怎么处理？</h2><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="1-讲讲开闭原则？"><a href="#1-讲讲开闭原则？" class="headerlink" title="1. 讲讲开闭原则？"></a>1. 讲讲开闭原则？</h2><h1 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h1><h2 id="1-分布式Session？"><a href="#1-分布式Session？" class="headerlink" title="1. 分布式Session？"></a>1. 分布式Session？</h2><h1 id="场景题"><a href="#场景题" class="headerlink" title="场景题"></a>场景题</h1><h2 id="1-怎么实现用户断点上传视频？"><a href="#1-怎么实现用户断点上传视频？" class="headerlink" title="1. 怎么实现用户断点上传视频？"></a>1. 怎么实现用户断点上传视频？</h2><h2 id="2-1kw的数据，如何保证每次都快速找到想要的数据？"><a href="#2-1kw的数据，如何保证每次都快速找到想要的数据？" class="headerlink" title="2. 1kw的数据，如何保证每次都快速找到想要的数据？"></a>2. 1kw的数据，如何保证每次都快速找到想要的数据？</h2><h2 id="3-实现一个功能：用户搜索关键字，快速从全网找出他要搜索的这个关键字并整理返回给他？"><a href="#3-实现一个功能：用户搜索关键字，快速从全网找出他要搜索的这个关键字并整理返回给他？" class="headerlink" title="3. 实现一个功能：用户搜索关键字，快速从全网找出他要搜索的这个关键字并整理返回给他？"></a>3. 实现一个功能：用户搜索关键字，快速从全网找出他要搜索的这个关键字并整理返回给他？</h2><h2 id="4-如何用链表实现三个表连接？"><a href="#4-如何用链表实现三个表连接？" class="headerlink" title="4. 如何用链表实现三个表连接？"></a>4. 如何用链表实现三个表连接？</h2><h2 id="5-8G的文件，每行都是数字（可能为long），用2G内存统计所有重复出现过的数字，以及出现过的次数？"><a href="#5-8G的文件，每行都是数字（可能为long），用2G内存统计所有重复出现过的数字，以及出现过的次数？" class="headerlink" title="5. 8G的文件，每行都是数字（可能为long），用2G内存统计所有重复出现过的数字，以及出现过的次数？"></a>5. 8G的文件，每行都是数字（可能为long），用2G内存统计所有重复出现过的数字，以及出现过的次数？</h2><h1 id="代码题"><a href="#代码题" class="headerlink" title="代码题"></a>代码题</h1><h2 id="1-API限流器"><a href="#1-API限流器" class="headerlink" title="1. API限流器"></a>1. API限流器</h2><h2 id="2-多叉树遍历"><a href="#2-多叉树遍历" class="headerlink" title="2. 多叉树遍历"></a>2. 多叉树遍历</h2><h2 id="3-字典树"><a href="#3-字典树" class="headerlink" title="3. 字典树"></a>3. 字典树</h2><h2 id="4-LRU"><a href="#4-LRU" class="headerlink" title="4. LRU"></a>4. LRU</h2>]]></content>
    
    
    
    <tags>
      
      <tag>面经</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>华为-0920-笔试</title>
    <link href="/2023/09/25/%E5%8D%8E%E4%B8%BA-0920-%E7%AC%94%E8%AF%95/"/>
    <url>/2023/09/25/%E5%8D%8E%E4%B8%BA-0920-%E7%AC%94%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h2 id="题目要求："><a href="#题目要求：" class="headerlink" title="题目要求："></a>题目要求：</h2><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs excel">班级组织传球活动，男女同学随机排成m行<span class="hljs-built_in">n</span>列队伍，第一列中的任意一个男同学都可以作为传球的起点，要求最终将球传到最后一列的任意一个男同学手里，求所有能够完成任务的传球路线中的最优路线(传球次数最少的路线)的传球次数。<br>传球规则：<br><span class="hljs-number">1</span>.男同学只能将球传给男同学，不能传给女同学。<br><span class="hljs-number">2</span>.球只能传给身边前后左右相邻的同学。<br><span class="hljs-number">3</span>.如果游戏不能完成，返回-<span class="hljs-number">1</span>。<br>求最短的传球路线<br></code></pre></td></tr></table></figure><h2 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h2><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs dns">班级同学随机排成的m行n列队伍，<span class="hljs-number">1</span>代表男同学，<span class="hljs-number">0</span>代表女同学。<br>输入第一行包含两个用空格分开的整数m[<span class="hljs-number">1</span>,<span class="hljs-number">30</span>]和n [<span class="hljs-number">1</span>,<span class="hljs-number">30</span>]，表示m行n列的队伍<span class="hljs-comment">;</span><br>接下来是m行每行包含n个用空格分开的整数<span class="hljs-number">1</span>或<span class="hljs-number">0</span>。<br><span class="hljs-number">4</span> <span class="hljs-number">4</span><br><span class="hljs-number">1 1 1 0</span><br><span class="hljs-number">1 1 1 0</span><br><span class="hljs-number">0 0 1 0</span><br><span class="hljs-number">0 1 1 1</span><br></code></pre></td></tr></table></figure><h2 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">5<br></code></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>最短路问题，上BFS。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">getMinLength</span>(<span class="hljs-params">matrix, m, n</span>):<br>    step = <span class="hljs-number">0</span><br>    queue = [(row, <span class="hljs-number">0</span>) <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m) <span class="hljs-keyword">if</span> matrix[row][<span class="hljs-number">0</span>] == <span class="hljs-number">1</span>]<br>    visited = &#123;(row, <span class="hljs-number">0</span>) <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m) <span class="hljs-keyword">if</span> matrix[row][<span class="hljs-number">0</span>] == <span class="hljs-number">1</span>&#125;<br>    dirs = [[<span class="hljs-number">1</span>, <span class="hljs-number">0</span>], [-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>]]<br>    <span class="hljs-keyword">while</span> queue:<br>        size = <span class="hljs-built_in">len</span>(queue)<br>        <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(size):<br>            i, j = queue.pop(<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">if</span> j == n - <span class="hljs-number">1</span>:<br>                <span class="hljs-keyword">return</span> step<br>            <span class="hljs-keyword">for</span> <span class="hljs-built_in">dir</span> <span class="hljs-keyword">in</span> dirs:<br>                neigh_i, neigh_j = i + <span class="hljs-built_in">dir</span>[<span class="hljs-number">0</span>], j + <span class="hljs-built_in">dir</span>[<span class="hljs-number">1</span>]<br>                <span class="hljs-keyword">if</span> (neigh_i, neigh_j) <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> visited <span class="hljs-keyword">and</span> isValid(matrix, neigh_i, neigh_j):<br>                    queue.append((neigh_i, neigh_j))<br>                    visited.add((neigh_i, neigh_j))<br>        step += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">isValid</span>(<span class="hljs-params">matrix, i, j</span>):<br>    m, n = <span class="hljs-built_in">len</span>(matrix), <span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>])<br>    <span class="hljs-keyword">if</span> i &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> i &gt;= m <span class="hljs-keyword">or</span> j &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> j &gt;= n:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>    <span class="hljs-keyword">return</span> matrix[i][j] == <span class="hljs-number">1</span><br><br><br>m, n = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>matrix = [<span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m)]<br><span class="hljs-built_in">print</span>(getMinLength(matrix, m, n))<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>笔试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>b站-实习-微服务开发-三面</title>
    <link href="/2023/09/22/b%E7%AB%99-%E5%AE%9E%E4%B9%A0-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91-%E4%B8%89%E9%9D%A2/"/>
    <url>/2023/09/22/b%E7%AB%99-%E5%AE%9E%E4%B9%A0-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91-%E4%B8%89%E9%9D%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>难度较大，问的问题比较基础，但是很偏，各个专业课都覆盖到了，但是基础不牢，给面试官留的印象比较差。<br><strong>难度</strong>：⭐⭐⭐⭐⭐<br><strong>学到的知识</strong>：⭐⭐⭐⭐☆</p><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vbnet"><span class="hljs-type">String</span>转<span class="hljs-type">Long</span>，需要考虑各种异常情况。<br>设计测试用例。<br></code></pre></td></tr></table></figure><h2 id="一些要点"><a href="#一些要点" class="headerlink" title="一些要点"></a>一些要点</h2><p>Java中，int占4个字节，long占8个字节。以long为例，其取值范围为$$-2^{63}到2^{63}-1$$，不要轻易对下界取反，因为会溢出。<br>Java中提供了Long.MAX_VAlUE和Long.MIN_VALUE来获取long的上下界。<br>其他类型，byte(非bit)占1字节，short占2字节，float 4字节，double 8字节，char 2字节。<br><strong>对象占几个字节？</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Class MaNong &#123; <br>    <span class="hljs-type">int</span> count;<br>    <span class="hljs-type">boolean</span> flag;<br>    Object obj; <br>&#125;<br></code></pre></td></tr></table></figure><p>对象头（8字节&#x2F;16字节）+ int（4字节）+ boolean（1字节）+ 空引用（4字节&#x2F;8字节）&#x3D; 17字节。<br>Java对象内存分配时以8的整数分配（对齐填充，以提高访问速度），故会分配24字节。<br>其中空引用类型，32位jvm是4字节，64位jvm是8字节，如果启动了压缩oops（限制堆大小，最大让其寻址32G内存），仍可能是4字节。<br><strong>包装类占几个字节？</strong><br>和对象一样，对象头 + 基本数据类型 + 对齐填充。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs sql">public class BilibiliExamThree &#123;<br><br>    public <span class="hljs-keyword">static</span> void main(String[] args) &#123;<br>        try &#123;<br>            System.out.println(StringToLong(&quot;1234&quot;));<br>            System.out.println(StringToLong(&quot;-12233&quot;));<br>            System.out.println(StringToLong(&quot;9223372036854775807&quot;));<br>            System.out.println(StringToLong(&quot;9223372036854775809&quot;)); <span class="hljs-operator">/</span><span class="hljs-operator">/</span>溢出<br>            System.out.println(StringToLong(&quot;+&quot;));<br>            System.out.println(StringToLong(&quot;122c2234a&quot;));<br>            System.out.println(StringToLong(&quot;abc&quot;));<br>            System.out.println(StringToLong(&quot;&quot;));<br>        &#125; catch (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br>    &#125;<br><br>    public <span class="hljs-keyword">static</span> long StringToLong(String string) throws Exception &#123;<br>        if (string <span class="hljs-operator">=</span><span class="hljs-operator">=</span> <span class="hljs-keyword">null</span> <span class="hljs-operator">||</span> string.<span class="hljs-built_in">trim</span>().isEmpty()) &#123;<br>            throw <span class="hljs-keyword">new</span> NumberFormatException(&quot;输入的字符串为空，或仅包含空白字符&quot;);<br>        &#125;<br>        string <span class="hljs-operator">=</span> string.<span class="hljs-built_in">trim</span>();<br>        long res <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">boolean</span> isNegative <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-keyword">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        if (string.charAt(<span class="hljs-number">0</span>) <span class="hljs-operator">=</span><span class="hljs-operator">=</span> <span class="hljs-string">&#x27;-&#x27;</span> <span class="hljs-operator">||</span> string.charAt(<span class="hljs-number">0</span>) <span class="hljs-operator">=</span><span class="hljs-operator">=</span> <span class="hljs-string">&#x27;+&#x27;</span>) &#123;<br>            <span class="hljs-keyword">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>            if (string.charAt(<span class="hljs-number">0</span>) <span class="hljs-operator">=</span><span class="hljs-operator">=</span> <span class="hljs-string">&#x27;-&#x27;</span>) isNegative <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        if (<span class="hljs-keyword">start</span> <span class="hljs-operator">=</span><span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-operator">&amp;&amp;</span> string.length() <span class="hljs-operator">=</span><span class="hljs-operator">=</span> <span class="hljs-number">1</span>) &#123;<br>            throw <span class="hljs-keyword">new</span> Exception(&quot;输入的字符串仅包含正负号。&quot;);<br>        &#125;<br><br>        <span class="hljs-operator">/</span><span class="hljs-operator">/</span> MIN_VALUE的绝对值大于MAX_VALUE,不能对MIN_VALUE取反，否则会溢出<br>        long limit <span class="hljs-operator">=</span> isNegative ? Long.MIN_VALUE : <span class="hljs-operator">-</span>Long.MAX_VALUE;<br>        long multmin <span class="hljs-operator">=</span> limit <span class="hljs-operator">/</span> <span class="hljs-number">10</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i <span class="hljs-operator">=</span> <span class="hljs-keyword">start</span>; i <span class="hljs-operator">&lt;</span> string.length(); i<span class="hljs-operator">+</span><span class="hljs-operator">+</span>) &#123;<br>            <span class="hljs-type">char</span> ch <span class="hljs-operator">=</span> string.charAt(i);<br><br>            <span class="hljs-operator">/</span><span class="hljs-operator">/</span>判断是否是否合法<br>            if (ch <span class="hljs-operator">&lt;</span> <span class="hljs-string">&#x27;0&#x27;</span> <span class="hljs-operator">||</span> ch <span class="hljs-operator">&gt;</span> <span class="hljs-string">&#x27;9&#x27;</span>) &#123;<br>                throw <span class="hljs-keyword">new</span> NumberFormatException(&quot;输入的字符串不合法&quot;);<br>            &#125;<br><br>            <span class="hljs-operator">/</span><span class="hljs-operator">/</span> 判断是否超过long类型的界限<br>            if (res <span class="hljs-operator">&lt;</span> multmin) &#123;<br>                throw <span class="hljs-keyword">new</span> NumberFormatException(&quot;超过long类型的界限。&quot;);<br>            &#125;<br>            res <span class="hljs-operator">*</span><span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><br>            <span class="hljs-operator">/</span><span class="hljs-operator">/</span> 判断是否超过long类型的界限<br>            <span class="hljs-type">int</span> nextDigit <span class="hljs-operator">=</span> ch <span class="hljs-operator">-</span> <span class="hljs-string">&#x27;0&#x27;</span>;<br>            if (res <span class="hljs-operator">&lt;</span> limit <span class="hljs-operator">+</span> nextDigit) &#123;<br>                throw <span class="hljs-keyword">new</span> NumberFormatException(&quot;超过long类型的界限。&quot;);<br>            &#125;<br>            res <span class="hljs-operator">-</span><span class="hljs-operator">=</span> nextDigit;<br><br>        &#125;<br><br>        if (<span class="hljs-operator">!</span>isNegative) res <span class="hljs-operator">=</span> <span class="hljs-operator">-</span>res;<br>        <span class="hljs-keyword">return</span> res;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h2 id="1-写一段会让数据库死锁的代码？"><a href="#1-写一段会让数据库死锁的代码？" class="headerlink" title="1. 写一段会让数据库死锁的代码？"></a>1. 写一段会让数据库死锁的代码？</h2><p>在互相持有对方需要的资源，且资源独占时会死锁。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 会话1</span><br><span class="hljs-keyword">start</span> transaction;<br><span class="hljs-keyword">update</span> tableA <span class="hljs-keyword">set</span> id <span class="hljs-operator">=</span> <span class="hljs-number">2</span> <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">--会话2</span><br><span class="hljs-keyword">start</span> transaction;<br><span class="hljs-keyword">update</span> tableB <span class="hljs-keyword">set</span> id <span class="hljs-operator">=</span> <span class="hljs-number">2</span> <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">update</span> tableA <span class="hljs-keyword">set</span> id <span class="hljs-operator">=</span> <span class="hljs-number">3</span> <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; <span class="hljs-comment">-- 这里会等待，因为会话1已经将这行锁定</span><br><br><span class="hljs-comment">--回到会话1</span><br><span class="hljs-keyword">update</span> tableB <span class="hljs-keyword">set</span> id <span class="hljs-operator">=</span> <span class="hljs-number">3</span> <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; <span class="hljs-comment">--这里会产生死锁，因为会话2已经将这行锁定</span><br><span class="hljs-comment">-- </span><br>innodb有一个死锁检测机制，他在检测到死锁时，会中断其中一个事务，从而解决死锁。上述两个事务中，其中一个会收到死锁的错误消息。<br><br></code></pre></td></tr></table></figure><h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="1-什么是哲学家就餐问题？如何解决？–mark，看视频学习下"><a href="#1-什么是哲学家就餐问题？如何解决？–mark，看视频学习下" class="headerlink" title="1. 什么是哲学家就餐问题？如何解决？–mark，看视频学习下"></a>1. 什么是哲学家就餐问题？如何解决？–mark，看视频学习下</h2><p>并发和死锁问题。<br>解决方式：</p><ol><li>仲裁串行化：任何时候只有一个哲学家在尝试拿叉子</li><li>限制同时尝试的哲学家数量：每次最多4位哲学家就餐（总共5个），这样至少有一个哲学家会成功。</li><li>随机等待：如果不能拿到全部的叉子，则随机等待一段时间再尝试</li><li>资源分级</li></ol><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="1-如何设计一个哈希表？"><a href="#1-如何设计一个哈希表？" class="headerlink" title="1. 如何设计一个哈希表？"></a>1. 如何设计一个哈希表？</h2><ol><li>选择哈希函数</li></ol><ul><li>好的哈希函数是关键，将输入均匀地映射到哈希表的索引。</li><li>快速计算，保持哈希表操作的高效性</li></ul><ol start="2"><li>数组或桶来存储数据</li><li>处理哈希冲突</li></ol><ul><li>链地址法</li><li>开放寻址法（顺序，跳跃，双重哈希）</li></ul><ol start="4"><li>动态调整大小</li></ol><ul><li>在加载因子超过一定的阈值，需要进行扩容。</li></ul><ol start="5"><li>删除操作</li></ol><ul><li>如果在开放定址法中，会标记已删除，如果直接删除，会中断其他键的探测序列。</li></ul><ol start="6"><li>其他：</li></ol><ul><li>设计合理的加载因子阈值</li><li>安全性：使用加密哈希函数或其他安全措施来避免恶意攻击（例如故意制造哈希冲突）</li></ul><h2 id="2-如何解决哈希冲突？"><a href="#2-如何解决哈希冲突？" class="headerlink" title="2. 如何解决哈希冲突？"></a>2. 如何解决哈希冲突？</h2><ul><li>开放寻址</li><li>链地址法</li></ul><h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><h2 id="1-服务器发送rst的情况？"><a href="#1-服务器发送rst的情况？" class="headerlink" title="1. 服务器发送rst的情况？"></a>1. 服务器发送rst的情况？</h2><p>rst(reset)包是一种特殊的包，用于快速、无条件的终止连接，而无需tcp正常的终止序列（fin握手），在以下情况中使用。</p><ol><li>异常关闭：当一个端点检测到连接中的错误或异常，可能会发送一个rst包来立即终止连接。</li><li>非预期的数据：如果一个端点接收到它不期望的数据（比如，认为连接已经关闭，但突然收到了数据，半开问题），他会回应一个rst包。</li></ol><h2 id="2-tcp如何只允许单方面发送消息？"><a href="#2-tcp如何只允许单方面发送消息？" class="headerlink" title="2. tcp如何只允许单方面发送消息？"></a>2. tcp如何只允许单方面发送消息？</h2><p>通过tcp的半关闭或半开来实现，允许一个方向上的数据传输被关闭，另一个方向的数据传输保持打开。</p><ol><li>半关闭 - tcp的正常特性<br>四次挥手中，客户端发送了fin报文，但是接收端仍有数据要发送，不发送fin报文，来保持办关闭状态。</li><li>半开 - 异常状态<br>由网络问题或其他中断导致。<br>半开状态中，一方认为连接仍然是打开并尝试发送数据，而另一方认为连接已经关闭。<br>这种状态是由FIN或RST包在网络中丢失导致的。<br>半开连接会导致资源泄露或其他问题，因为其中一方会为它认为仍然打开的链接保持资源。<br>半开状态下，若客户端已经断开，服务器不知道连接关闭，服务器尝试向客户端发送数据时，客户端会响应一个RST包。<br>解决：许多服务器有超时机制，如果一段时间内没有从连接中接收到任何数据，会自动关闭连接。</li></ol><h1 id="python"><a href="#python" class="headerlink" title="python"></a>python</h1><h2 id="1-python多线程有什么问题？"><a href="#1-python多线程有什么问题？" class="headerlink" title="1. python多线程有什么问题？"></a>1. python多线程有什么问题？</h2><p>python的实现中，使用了GIL互斥锁，来防止多个线程同时执行python字节码，也就说在任何给定的时间点，只有一个线程可以在解释器中执行。<br>由于gil的存在，多线程在cpu密集型任务上不会提供的预期的性能提升，因为线程不能并行的在多个cpu核心上运行。</p><p><strong>python为什么要引入GIL呢？</strong></p><ul><li>取消复杂的锁机制，并提升了单线程程序的性能。</li><li>cpython的内存管理使用的是引用计数，对引用计数的增减需要同步，GIL可以确保在任何时候只有一个线程能够修改引用计数。</li><li>历史原因：GIL最初被引入时，多核cpu并不那么普及。（GIL在90年代引入，盛业多核cpu在2001发布。）</li><li>早期的c扩展和库并不是线程安全，GIL提供一种方式来确保这些库在多线程环境中安全使用，而无需大量修改。</li></ul><p><strong>如何解决了GIL存在的问题？</strong></p><ol><li>使用其他Python实现，jpython，ironpython</li><li>使用多进程</li><li>子解释器，创建多个解释器，每个解释器有自己的GIL</li></ol><h1 id="django"><a href="#django" class="headerlink" title="django"></a>django</h1><h2 id="1-django的设计思路是什么？"><a href="#1-django的设计思路是什么？" class="headerlink" title="1. django的设计思路是什么？"></a>1. django的设计思路是什么？</h2><p>dango的设计思路是提供一个全面、集成的框架，让开发者可以快速、快速地开发出健壮、安全、可维护的web应用。<br>几个关键点：</p><ol><li>MTV架构<ul><li>Model:数据结构，数据库操作</li><li>Template：在web页面中显示数据，定义了静态部分和动态部分的呈现方式</li><li>View: 如何处理用户的输入并返回适当的响应。</li></ul></li><li>DRY：鼓励代码重用</li><li>约定由于配置：允许开发者快速开始而无需进行大量配置。</li><li>简化开发任务：内置轻量级web服务器、自动化的数据库迁移工具，管理界面生成器，这些都可以简化开发任务</li><li>可扩展性: 使用模块化的设计，开发者可以轻松地添加自己的应用程序或使用第三方应用。</li></ol><p>松散耦合的体现</p><ol><li>视图和模板逻辑分开，视图负责处理业务逻辑和决定哪些数据需要显示，而模板负责如何显示这些数据，因为视图和模板逻辑分开，可以独立修改和测试。</li><li>鼓励开发者构造可重用的应用程序，例如可以为用户身份验证创建一个应用程序，可以在多个Django项目中重用，而不需要做大量的更改。</li></ol><p><strong>MTV与MVC的不同？</strong><br>主要讲一下MVC的各部分。<br>Model：一致，都是数据存储、检索和业务逻辑<br>View：如何将数据展示给用户，很多都是模板+数据<br>Controller：负责接收用户的请求，调用模型进程数据操作，然后选择使用哪个视图来显示结果给用户。</p><p>都是为了责任分离，django更强调模板，他只用于定义如何显示内容，而不涉及决定哪些内容要显示。</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="1-最近在看的一本书？讲下印象最深刻的地方？"><a href="#1-最近在看的一本书？讲下印象最深刻的地方？" class="headerlink" title="1. 最近在看的一本书？讲下印象最深刻的地方？"></a>1. 最近在看的一本书？讲下印象最深刻的地方？</h2><p>《代码整洁之道》<br>“最好额注释是不需要注释的代码”<br>“代码并不补偿糟糕的代码”<br>“当代码无法明确地传达某个意图或背后的原因时，注释是有用的，例如解释某个复杂算法的原理或者为什么采取非常规的做法。”<br>“避免误导性的代码，保证代码和注释一致，错误过时的注释比没有注释还操作”<br>“不要在注释中重复代码，比如对代码做字面翻译”<br>“函数和变量的良好命名可以减少对注释的需求。”</p>]]></content>
    
    
    
    <tags>
      
      <tag>面经</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>b站-实习-微服务开发-二面</title>
    <link href="/2023/09/21/b%E7%AB%99-%E5%AE%9E%E4%B9%A0-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91-%E4%BA%8C%E9%9D%A2/"/>
    <url>/2023/09/21/b%E7%AB%99-%E5%AE%9E%E4%B9%A0-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91-%E4%BA%8C%E9%9D%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>扣的比较细，需要对简历上写的原理了解的更深刻，比如说websocket header是怎么设计的？常见八股较多，但是有些说错了。</p><p><strong>难度</strong>：⭐⭐⭐☆☆<br><strong>学到的知识</strong>：⭐⭐⭐⭐⭐</p><h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><h2 id="1-http1-3分别解决了什么问题？如果在http3的场景下，从5G切换为无线网，会需要重新建立连接吗？"><a href="#1-http1-3分别解决了什么问题？如果在http3的场景下，从5G切换为无线网，会需要重新建立连接吗？" class="headerlink" title="1. http1-3分别解决了什么问题？如果在http3的场景下，从5G切换为无线网，会需要重新建立连接吗？"></a>1. http1-3分别解决了什么问题？如果在http3的场景下，从5G切换为无线网，会需要重新建立连接吗？</h2><p><strong>http1.1,http2,http3的演变</strong></p><ul><li>htt1.1相对http1：<ul><li>使用长连接改善了短连接的性能开销</li><li>支持管道通信，来解决队头阻塞</li></ul></li><li>http2相对http1.1：<ul><li>头部压缩</li><li>二进制格式，增加解析效率</li><li>并发传输：使用多个stream复用一条tcp连接的方式解决队头阻塞，一个tcp连接可以包含多个stream，每个stream里包含一个或多个message，message对应的是http1中的请求或响应，针对不同的http请求，使用stream id来区分，接收端通过stream id来有序的组装http消息，stream的帧可以是乱序的，故可以并发不同的stream – 这一块理解不深，mark一下，而且解决的是哪一端的队头阻塞？</li><li>服务器推送，服务器使用偶数的stream id，客户端使用奇数的stream id，主要用于服务器提前向客户端提供资源，以降低时延的场景。</li></ul></li><li>http3相对http2：<ul><li>tcp一旦丢包，就会阻塞所有的ttp请求，http3将tcp改为udp来解决队头阻塞，用quic协议来实现类似tcp的可靠传输。三个特点：<ul><li>无队头阻塞</li><li>更快的连接建立（tcp和ssl分层，但是quic和ssl不分层，3次握手取代6次握手）</li><li>连接迁移（http通过四元组确定tcp连接，所以ip地址变换需要重新连接，quic用连接id来标记断点，即使ip地址变化，只要保佑上下文，仍可以复用原连接）</li></ul></li></ul></li></ul><h2 id="2-websocket协议了解多少？头部的内容了解吗？"><a href="#2-websocket协议了解多少？头部的内容了解吗？" class="headerlink" title="2. websocket协议了解多少？头部的内容了解吗？"></a>2. websocket协议了解多少？头部的内容了解吗？</h2><p>websocket提供了在单个tcp连接上进行全双工通信的能力，与传统的http请求&#x2F;响应模型不同，websocket允许服务器端和客户端之间进行双向通信。</p><p><strong>websocket如何建立连接？</strong><br>先是tcp三次握手建立连接，然后统一使用http协议进行交互，如果想建立websocket连接，则要在http请求里带上一些特殊的header头：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>想升级协议<br>Connection: Upgrade<br><span class="hljs-regexp">//</span> 升级为WebSocket协议<br>Upgrade: WebSocket<br><span class="hljs-regexp">//</span> 随机生成的base64码<br>Sec-webSocket-Key: T2a6wZlAwhgQNqruZ2YUyg==\r\n<br></code></pre></td></tr></table></figure><p>如果服务器支持WebSocket协议，就走WebSocket握手流程，根据客户端生成的base64，用公开算法变成另一段字符串，放在Sec-WebSocket-Accept头中，并带上101 Switch Protocals状态码，整体响应如下</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">HTTP</span>/<span class="hljs-number">1</span>.<span class="hljs-number">1</span> <span class="hljs-number">101</span> Switching Protocols<br><span class="hljs-attribute">Sec</span>-WebSocket-Accept:iBJKv/ALIW2DobfoA4dmr3JHBCY=\r\n<br><span class="hljs-attribute">Upgrade</span>: WebSocket<br><span class="hljs-attribute">Connection</span>: Upgrade<br></code></pre></td></tr></table></figure><p>浏览器也用过同样的公开算法将base64,转成另一段字符串，如果和服务器穿回来的字符串一致，则验证通过。<br>后续可以使用websocket数据格式通信。</p><p><strong>WebSocket的消息格式</strong><br>WebSocket的数据包叫做帧，头部字段中有几个比较重要</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs vbnet"><span class="hljs-symbol">opcode:</span> 标志是什么类型的数据帧<br>    <span class="hljs-number">1</span>：<span class="hljs-type">string</span><br>    <span class="hljs-number">2</span>：<span class="hljs-type">byte</span><br>    <span class="hljs-number">8</span>: 关闭连接<br>payload：存放真正想要传输的数据的长度，单位是字节。有几个不同的payload，根据前一个payload的取值，决定要不要读下面的。<br>payload data：存放真正要传输额数据，根据payload字段去截取对应的数据。<br><br></code></pre></td></tr></table></figure><h1 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h1><h2 id="1-如何部署redis？是否使用了集群？谈谈对集群的理解？"><a href="#1-如何部署redis？是否使用了集群？谈谈对集群的理解？" class="headerlink" title="1. 如何部署redis？是否使用了集群？谈谈对集群的理解？"></a>1. 如何部署redis？是否使用了集群？谈谈对集群的理解？</h2><h2 id="2-redis如何处理哈希冲突？–mark，写的不对"><a href="#2-redis如何处理哈希冲突？–mark，写的不对" class="headerlink" title="2. redis如何处理哈希冲突？–mark，写的不对"></a>2. redis如何处理哈希冲突？–mark，写的不对</h2><p>使用的是开放寻址法。HashMap使用的链地址法。<br>开放寻址法：如果所需的位置已被占用，那么探测哈希表中其他位置，直到找到一个空的位置为止。<br>常见策略：</p><ol><li>线性探测：找下一个</li><li>二次探测：与线性探测类似，查找间隔是二次的，h(k) + 1^2, h(k) - 1^2, h(k) + 2^2, h(k) - 2^2</li><li>双重哈希<br>开放寻址法的好处是，不需要额外的数据结构（如链表）来存储冲突的键，坏处是，随之填充因子增加，冲突的可能性增加。所以通常需要在填充因子达到某个阈值时，对哈希表进行再哈希，创建一个更大的哈希表，并将所有的键移动到新表中。</li></ol><p><strong>redis是如何进行在hash的呢？</strong><br>为了避免rehash在数据迁移过程因拷贝数据造成耗时，影响redis性能，redis采用了渐进式再哈希，分多次进行迁移。<br>步骤如下：</p><ol><li>给哈希表2分配空间</li><li>rehash期间，哈希表新增、删除、查找或更新操作时，redis除了执行对应的操作，还会顺序将哈希表1中所有key-value迁移到哈希表2上。</li><li>随着客户端发起的哈希表操作请求数据增多，最终会在某个时间点把哈希表1的所有key-value迁移到哈希表2，完成rehash。<br>rehash期间，删除、查找和更新都会在这两个哈希表中进行操作。新增请求只会被保存到哈希表2上。</li></ol><p><strong>rehash的触发条件？</strong></p><ul><li>负载因子大于等于1，并且redis没有执行bgsave或bgrewiteaof命令，也就是没有执行rdb快照和aof重写时，就会rehash。</li><li>负载因子大于等于5时，哈希冲突严重，不论有没有执行rdb快照或aof重写，都会强制进行rehash。</li></ul><h2 id="3-zset的底层结构？"><a href="#3-zset的底层结构？" class="headerlink" title="3. zset的底层结构？"></a>3. zset的底层结构？</h2><p>简略回答。<br>跳表-&gt;多层索引-&gt;二分查找-&gt;o(logn)。<br>插入结点时，按照概率决定调整几层索引，来保持上层是下层的1&#x2F;2。</p><p><strong>mysql为什么用b+树，不用跳表呢？</strong></p><ol><li>稳定性：b+树根节点到叶子结点的路径长度是固定的，跳表头结点到目的节点的路径不固定，检索的value越大，磁盘io越多。</li><li>范围查询的效率：b+树的叶子结点通过双向链表连接，有利于范围查询，跳表虽然可以范围查询，但因为其层次结构，需要更多的指针跳转。</li><li>节点的大小：B+树的结点通常比跳表大，树的高度比较小，从而减少磁盘IO。而且跳表本身的目的是在内存中提供快速的操作，并非降低磁盘IO，如果存储多个数据项，需要更多的平衡逻辑，那他可能会变得和b+树一样复杂。</li></ol><h1 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h1><h2 id="1-nginx怎么转发？配置文件你是怎么写的？"><a href="#1-nginx怎么转发？配置文件你是怎么写的？" class="headerlink" title="1. nginx怎么转发？配置文件你是怎么写的？"></a>1. nginx怎么转发？配置文件你是怎么写的？</h2><p>转发是通过配置文件中的proxy_pass指令实现。<br>nginx的几个特点：</p><ol><li>事件驱动模型，是非阻塞IO，可以处理大量并发连接。</li><li>反向代理&amp;&amp;负载均衡，可以将客户端的请求转发到多个后端服务器，从而实现负载均衡，支持多种负载均衡策略：轮询，最少连接，IP哈希，并且定期检查后端服务器的健康状况，将不健康的服务器从负载均衡池中移除。</li><li>缓存：nginx可以缓存后端服务器的响应，来加速后续相同请求的处理速度，通过proxy_cache和相关指令实现。</li><li>连接持久化：支持客户端和服务器的连接持久化，减少建立和关闭连接的开销</li><li>SSL中断，nginx可以为后端服务器处理ssl握手，减轻后端服务器的压力。</li></ol><p>包含负载均衡的配置文件：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">http</span> &#123;<br>    <span class="hljs-comment"># 定义日志格式和日志文件的位置</span><br>    <span class="hljs-attribute">log_format</span> main <span class="hljs-string">&#x27;<span class="hljs-variable">$remote_addr</span> - <span class="hljs-variable">$remote_user</span> [<span class="hljs-variable">$time_local</span>] &quot;<span class="hljs-variable">$request</span>&quot; &#x27;</span><br>                     <span class="hljs-string">&#x27;<span class="hljs-variable">$status</span> <span class="hljs-variable">$body_bytes_sent</span> &quot;<span class="hljs-variable">$http_referer</span>&quot; &#x27;</span><br>                     <span class="hljs-string">&#x27;&quot;<span class="hljs-variable">$http_user_agent</span>&quot; &quot;<span class="hljs-variable">$http_x_forwarded_for</span>&quot;&#x27;</span>;<br>    <span class="hljs-attribute">access_log</span> /var/log/nginx/access.log main;<br><br>    <span class="hljs-comment"># 定义负载均衡的后端服务器组</span><br>    <span class="hljs-section">upstream</span> backend_servers &#123;<br>        <span class="hljs-comment"># 轮询策略（默认策略）</span><br>        <span class="hljs-attribute">server</span> backend1.example.com;<br>        <span class="hljs-attribute">server</span> backend2.example.com;<br><br>        <span class="hljs-comment"># 其他可选策略：</span><br>        <span class="hljs-comment"># 最少连接策略</span><br>        <span class="hljs-comment"># least_conn;</span><br><br>        <span class="hljs-comment"># IP 哈希策略，根据客户端 IP 地址进行哈希，确保特定客户端总是被转发到同一个后端服务器</span><br>        <span class="hljs-comment"># ip_hash;</span><br>    &#125;<br><br>    <span class="hljs-section">server</span> &#123;<br>        <span class="hljs-attribute">listen</span> <span class="hljs-number">80</span>; <span class="hljs-comment"># 监听的端口</span><br><br>        <span class="hljs-section">location</span> / &#123;<br>            <span class="hljs-comment"># 将请求转发到上面定义的后端服务器组</span><br>            <span class="hljs-attribute">proxy_pass</span> http://backend_servers;<br><br>            <span class="hljs-comment"># 设置请求和响应的头部信息</span><br>            <span class="hljs-attribute">proxy_set_header</span> Host <span class="hljs-variable">$host</span>;<br>            <span class="hljs-attribute">proxy_set_header</span> X-Real-IP <span class="hljs-variable">$remote_addr</span>;<br>            <span class="hljs-attribute">proxy_set_header</span> X-Forwarded-For <span class="hljs-variable">$proxy_add_x_forwarded_for</span>;<br><br>            <span class="hljs-comment"># 其他可选的代理设置</span><br>            <span class="hljs-attribute">proxy_connect_timeout</span> <span class="hljs-number">90</span>; <span class="hljs-comment"># 连接后端服务器的超时时间</span><br>            <span class="hljs-attribute">proxy_send_timeout</span> <span class="hljs-number">90</span>;    <span class="hljs-comment"># 向后端服务器发送请求的超时时间</span><br>            <span class="hljs-attribute">proxy_read_timeout</span> <span class="hljs-number">90</span>;    <span class="hljs-comment"># 读取后端服务器响应的超时时间</span><br><br>            <span class="hljs-attribute">proxy_buffer_size</span> <span class="hljs-number">4k</span>;     <span class="hljs-comment"># 设置读取响应头的缓冲区大小</span><br>            <span class="hljs-attribute">proxy_buffers</span> <span class="hljs-number">4</span> <span class="hljs-number">32k</span>;      <span class="hljs-comment"># 设置读取响应体的缓冲区数量和大小</span><br>            <span class="hljs-attribute">proxy_busy_buffers_size</span> <span class="hljs-number">64k</span>;<br>            <span class="hljs-attribute">proxy_temp_file_write_size</span> <span class="hljs-number">64k</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>介绍下正向代理和反向代理？</strong><br>正向代理：<br>位于客户端和互联网之间，客户端通过正向代理访问互联网上的资源。<br>用途：</p><ul><li>内容过滤：学校或企业通过正向代理来组织用户访问特定的网站</li><li>匿名访问：用户通过正向代理隐藏自己的ip</li><li>缓存：正向代理缓存经常访问的内容，加速访问速度</li><li>访问地域性内容：如果某些内容仅在特定国家或地区可用，可以使用该国家地区的正向代理来访问<br>工作方式：<br>客户端配置自己的网络设置，使得所有的网络请求通过正向代理服务器，代理服务器决定是否直接为客户端提供请求的内容，还是将请求转发到互联网上。</li></ul><p>反向代理<br>位于互联网和web服务器之间，客户端不直接访问web服务器，而是通过反向代理访问。<br>用途：</p><ul><li>负载均衡</li><li>ssl终端，反向代理可以处理ssl握手，减轻后端服务器压力</li><li>缓存，可以缓存来自后端服务器的响应，从而加速响应时间并减少后端服务器的负担</li><li>压缩，反向代理可以压缩服务器响应，从而加速数据传输</li><li>安全和匿名性：反向代理可以隐藏后端服务器的信息，从而提供额外的安全层<br>工作方式：<br>客户端认为它直接与反向代理服务器通信，但实际上反向代理服务器将请求转发到后端服务器，然后，反向代理从后端服务器接收响应并将其转发给客户端。</li></ul><h2 id="2-如何查看进程运行在哪些端口上？"><a href="#2-如何查看进程运行在哪些端口上？" class="headerlink" title="2. 如何查看进程运行在哪些端口上？"></a>2. 如何查看进程运行在哪些端口上？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs linux">//查看所有进程<br>lsof - i<br>netstat -tulnp<br>ss -tulnp<br><br>//查看指定端口上运行的进程<br>lsof -i :8080<br>netstat -tulnp | grep :8080<br>ss -tunlp | grep :8080<br><br></code></pre></td></tr></table></figure><h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h2 id="1-4000w的数据b-树有几层？"><a href="#1-4000w的数据b-树有几层？" class="headerlink" title="1. 4000w的数据b+树有几层？"></a>1. 4000w的数据b+树有几层？</h2><p>想要确定B+树的层数，需要确定两个方面，一是数据量，而是B+树的阶数。<br><strong>阶数如何估计呢？</strong><br>大概等于一页所能容纳的最大索引数量。<br>页的大小：innodb默认页的大小是16kb。<br>索引键的大小：int类型需要4字节，varchar(255)最差情况下需要255字节<br>在不考虑其他开销的情况，我们暂时选取100字节作为索引键。<br>那一页的索引树为，16*1024&#x2F;100 约为 100，所以阶数估为100。</p><p><strong>估算层数？</strong><br>B+树需要满足，根节点至少两个子节点，除根节点外每个结点至少m&#x2F;2个子节点，最多m个子节点。<br>考虑到希望高度最小，则k层的b+树容纳索引树为$$m^{(k-1)}$$<br>则有 $$160^{(k-1)} &gt;&#x3D; 4000w$$层数k约为4。</p><h2 id="2-对于唯一索引，innodb使用的索引是哈希，还是b-树？"><a href="#2-对于唯一索引，innodb使用的索引是哈希，还是b-树？" class="headerlink" title="2. 对于唯一索引，innodb使用的索引是哈希，还是b+树？"></a>2. 对于唯一索引，innodb使用的索引是哈希，还是b+树？</h2><p>无论唯一索引，还是非唯一索引，innodb都是使用的B+树作为主要索引结构。<br><strong>有无使用哈希索引的情况？</strong><br>当某些索引值被频繁访问时，innodb可以会为这些值建立哈希索引，以提交查找速度。这只是补充特性，主要索引结构还是b+树。</p><h2 id="3-b-树的好处是什么？"><a href="#3-b-树的好处是什么？" class="headerlink" title="3. b+树的好处是什么？"></a>3. b+树的好处是什么？</h2><p>简略回答</p><ol><li>每个节点可以存放多个索引，且仅在叶子结点存储数据，每个结点可以存储更多索引，使得树的整体高度更低，对应的磁盘IO也更少。</li><li>叶子节点之间串成双链表，提高排序和范围查询的效率。</li><li>自平衡+叶子结点存储数据或索引，查询性能比较稳定。（一致和可预测性对于数据库和文件系统来说很重要）</li></ol><h1 id="代码考察"><a href="#代码考察" class="headerlink" title="代码考察"></a>代码考察</h1><h2 id="1-写一个生产者、消费者模式？"><a href="#1-写一个生产者、消费者模式？" class="headerlink" title="1. 写一个生产者、消费者模式？"></a>1. 写一个生产者、消费者模式？</h2><p>借助java的容器阻塞队列，很容易就可以写出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestOne</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        BlockingQueue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;&gt;();<br><br>        <span class="hljs-comment">//消费者</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>                    <span class="hljs-type">Integer</span> <span class="hljs-variable">val</span> <span class="hljs-operator">=</span> queue.take();<br>                    System.out.println(<span class="hljs-string">&quot;消费者消费了:&quot;</span>+ val);<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;) .start();<br><br>        <span class="hljs-comment">//生产者</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;<span class="hljs-number">30</span>;i++)&#123;<br>                    queue.put(i);<br>                    System.out.println(<span class="hljs-string">&quot;生产者生产了：&quot;</span>+ i);<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;).start();<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果想体验是如何阻塞或唤醒的，自己写一个简易的阻塞队列即可。<br>关键点在于重写take和put方法，在队满、队空时的阻塞处理，详情见<a href="https://whiteblacken.github.io/2023/09/14/%E5%94%AF%E5%93%81%E4%BC%9A-%E5%AE%9E%E4%B9%A0-Java%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%84%E4%BB%B6%E5%BC%80%E5%8F%91-%E4%BA%8C%E9%9D%A2/">唯品会-实习-Java大数据组件开发-二面</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>面经</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>b站-实习-微服务开发-一面</title>
    <link href="/2023/09/20/b%E7%AB%99-%E5%AE%9E%E4%B9%A0-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91-%E4%B8%80%E9%9D%A2/"/>
    <url>/2023/09/20/b%E7%AB%99-%E5%AE%9E%E4%B9%A0-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91-%E4%B8%80%E9%9D%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>交流比较顺畅，问的问题难度较低，简历上一些组件还要多看看。</p><p><strong>难度</strong>：⭐⭐⭐☆☆<br><strong>学到的知识</strong>：⭐⭐⭐☆☆</p><h1 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h1><h2 id="1-celery的使用场景？daphne的使用场景？"><a href="#1-celery的使用场景？daphne的使用场景？" class="headerlink" title="1. celery的使用场景？daphne的使用场景？"></a>1. celery的使用场景？daphne的使用场景？</h2><p><strong>celery</strong><br>是分布式任务队列系统，允许执行并发的任务，执行后台任务或处理大量的任务</p><p>主要组件：</p><ul><li>client：向消息队列发送任务</li><li>broker：消息队列，如rabbitmq，redis</li><li>worker：负责执行任务的进程</li><li>result backend：用于存储任务的结果，可以是数据库、缓存系统或其他存储</li></ul><p>使用场景：</p><ol><li>后台任务</li><li>定时任务</li><li>大数据处理</li><li>并发执行</li></ol><p>与MQ的区别：<br>依赖于MQ来传递任务，但是提供了任务调度、结果存储、任务优先级、任务重试等高级功能。</p><p>自己用多线程来实现不可以吗？</p><ul><li>celery可以实现分布式并发，可以通过添加更多的worker结点来在不同的机器上处理更多任务</li><li>提供了更好的容错性，当一个worker失败时，任务可以重新排队并由其他worker处理，为失败处理和重试提供了机制。</li><li>celery无需自己去写任务调度、优先级、结果存储和任务重试等功能。</li></ul><p><strong>daphne</strong><br>django本身的开发服务器是使用传统的wsgi服务器，用于处理同步http请求，是python web应用和服务器之间的标准接口；而daphne是支持异步操作的asgi的服务器，其可以支持http2，以及websocket，且因为其异步性质，可以在单个进程中处理大量并发连接。<br>感觉像是BIO和NIO的区别。</p><h2 id="2-邮箱拦截器如何用redis做的？"><a href="#2-邮箱拦截器如何用redis做的？" class="headerlink" title="2. 邮箱拦截器如何用redis做的？"></a>2. 邮箱拦截器如何用redis做的？</h2><h2 id="3-聊天用了redis的哪些操作？"><a href="#3-聊天用了redis的哪些操作？" class="headerlink" title="3. 聊天用了redis的哪些操作？"></a>3. 聊天用了redis的哪些操作？</h2><h1 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h1><h2 id="1-redis和mysql的区别"><a href="#1-redis和mysql的区别" class="headerlink" title="1. redis和mysql的区别"></a>1. redis和mysql的区别</h2><ol><li>数据模型：redis是key-value数据库，mysql关系型数据库</li><li>持久性：redis主要是内存存储，也可以通过rdb和aof进行持久化，mysql通过事务来确保数据的完整性和一致性。</li><li>redis的事务保证了一个客户端的命令不会被其他客户端命令打断，隔离级别是串行化，但不提供持久化保证，mysql的事务一般默认为可重复读，并且在系统崩溃后，已提交的更改仍存在。两者的原子性概念不同。</li><li>性能和速度：基于内存的redis读写速度相较mysql高很多。</li><li>并发：redis是单线程，mysql支持多线程和处理多个并发查询。</li></ol><h2 id="2-redis和mysql的一致性怎么保证？"><a href="#2-redis和mysql的一致性怎么保证？" class="headerlink" title="2. redis和mysql的一致性怎么保证？"></a>2. redis和mysql的一致性怎么保证？</h2><p>两种情况：<br>因为二者的操作不是原子性，所以只能保证最终一致性，而非强一致性，一定要原子性，需要上锁，影响系统的吞吐量。</p><ol><li>先操作缓存<br>先删除缓存，再更新数据库。<br>存在问题：如果在删除缓存和更新数据库之间发送一个线程读取操作，会把未更新的数据读入redis中，造成数据不一致。<br>策略：延迟双删，经过一定的时间（几百ms），再删一次redis缓存。</li><li>先操作数据库<br>先更新数据库，数据库更新成功后，删除缓存。<br>存在问题：若是数据库更新成功，但是redis删除失败了，数据会不一致。<br>策略：引入重试机制。如果不想把操作嵌入到业务代码，可以通过阿里开源的cannal组件，去监听binlog，更新redis。（可以通过springboot应用来做）</li></ol><h1 id="场景题"><a href="#场景题" class="headerlink" title="场景题"></a>场景题</h1><h2 id="1-用户请求1G文件的转码，如何设计上传和下载？浏览器分片了解过吗？"><a href="#1-用户请求1G文件的转码，如何设计上传和下载？浏览器分片了解过吗？" class="headerlink" title="1. 用户请求1G文件的转码，如何设计上传和下载？浏览器分片了解过吗？"></a>1. 用户请求1G文件的转码，如何设计上传和下载？浏览器分片了解过吗？</h2><p>需要考虑效率、可靠性、用户体验、可扩展性。<br>基本的设计方案：</p><ol><li>文件上传</li></ol><ul><li>分块上传：将文件切成小块（如5MB或10MB），分别上传，若某块失败，则重传该块，而非整个文件。</li><li>并行上传：同时上传多个文件以提高上传速度</li><li>完整性校验：每上传一个块，可以使用MD5或其他哈希算法来验证其完整性。</li><li>合并文件：所有块上传完成后，服务器端将这些块合并成一个完整的文件。</li></ul><ol start="2"><li>文件转码</li></ol><ul><li>异步处理：转码是一个耗时的过程，应该异步进行，不让用户等待</li><li>任务队列：使用任务队列（RabbitMQ，Kafka，redis）来管理解码任务。</li><li>分布式转码</li><li>通知用户：转码完成后可以通过电子邮件、短信或站内通知来提醒用户。</li></ul><ol start="3"><li>文件下载</li></ol><ul><li>分块下载</li><li>并行下载</li><li>断点续传：下载中断时，用户可以从中断点继续下载。<ul><li>需要跟踪已传输的字节数，传输中断时，客户端应保存已传输的字节数。</li><li>恢复传输时，客户端需要向服务器发送给一个特殊的请求，从上次中断的位置开始传输。</li><li>服务器需要能支持这种特殊的请求，通过http的Range投实现，若一个文件前1000字节已经被下载，客户端可以发送给一个请求，其Range头的值为bytes&#x3D;1001-，告诉服务器端从第1001字节开始传输。（上传下载都可采用）</li><li>UI上要给用户提示，是恢复上传不是重新上传。</li></ul></li><li>完整性校验：下载完成后，验证文件的完整性，确保用户获得的是完整且未损坏的文件。</li></ul><ol start="4"><li>其他考虑</li></ol><ul><li>安全性：使用SSL加密上传和下载数据</li><li>存储策略：使用对象存储来存储大文件，因为他们为大文件提供了优化的存储和检索。</li><li>用户体验：提示，查看转码进度</li><li>日志和监控</li></ul><p><strong>浏览器分片？</strong><br>浏览器提供了一些File api和Blob api来帮助文件的分片。</p><p>大文件分片上传：</p><ol><li>读取文件从File对象读取，(&lt;input type&#x3D;”file”&gt;)来访问用户选择的文件。</li><li><strong>使用Blob.slice()方法将文件分割成多个小的数据块或分片。</strong></li><li>上传分片，使用XMLHttpRequest或Fetch api将其上传到服务器，可以为每个分片添加一个唯一的序号或id，以帮助服务器识别和重新组合文件。</li><li>后续中断处理和服务器组合和之前一样。</li></ol><p>大文件分片下载：</p><ol><li>根据需要，将请求文件分片</li><li><strong>浏览器收到文件的一个分片，使用Blob api将其存储起来，当所有的分片都下载完毕后，可以使用’Blob’构造函数将其组合成一个完整的文件Blob。</strong></li><li>使用URL.createObjectURL()方法为组合后的Blob创建一个url，并为该url提供一个下载链接，事用户可以下载完整文件。</li></ol><p>其他问题：</p><ol><li>需要服务器也支持</li><li>太小的分片会导致过多的网络请求，而太大的分片可能会导致某些网络问题。通常，分片大小可以设置为几MB.</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>面经</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络相关面试题</title>
    <link href="/2023/09/20/%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/2023/09/20/%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="1-Http协议的请求和响应格式"><a href="#1-Http协议的请求和响应格式" class="headerlink" title="1. Http协议的请求和响应格式"></a>1. Http协议的请求和响应格式</h1><h2 id="请求格式"><a href="#请求格式" class="headerlink" title="请求格式"></a>请求格式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 请求首行</span><br><span class="hljs-comment"> * 请求方法 + 请求目标 + HTTP版本</span><br><span class="hljs-comment"> * 常见的请求方法：get，post，put, patch, delete, head, options</span><br><span class="hljs-comment"> * /</span><br><span class="hljs-comment">POST / HTTP/1.1</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 请求体</span><br><span class="hljs-comment"> * key-value键值对组成，具体多少行，无要求</span><br><span class="hljs-comment"> * /</span><br><span class="hljs-comment">Host: localhost:8080</span><br><span class="hljs-comment">User-Agent: ...</span><br><span class="hljs-comment">Accept: ...</span><br><span class="hljs-comment">Accept-language: ...</span><br><span class="hljs-comment">Accept-Encoding: ...</span><br><span class="hljs-comment">Connection: keep-alive</span><br><span class="hljs-comment">Upgrade-Insecure-Requests: 1</span><br><span class="hljs-comment">Content-Type: ...</span><br><span class="hljs-comment">Content-length: 345</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 空行</span><br><span class="hljs-comment"> * 用于分隔请求头和请求正文</span><br><span class="hljs-comment"> * /</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 请求正文</span><br><span class="hljs-comment"> * 可以是字符串，可以是json格式</span><br><span class="hljs-comment"> * 浏览器提交给服务器的数据</span><br><span class="hljs-comment"> * /</span><br></code></pre></td></tr></table></figure><h2 id="响应格式"><a href="#响应格式" class="headerlink" title="响应格式"></a>响应格式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 响应首行</span><br><span class="hljs-comment"> * HTTP版本 + 响应状态 + 状态码解释</span><br><span class="hljs-comment"> * 常见的状态码：200,404,403，500，400,401,502，503</span><br><span class="hljs-comment"> * /</span><br><span class="hljs-comment">HTTP/1.1 403 Forbidden</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 响应体</span><br><span class="hljs-comment"> * key-value键值对组成，具体多少行，无要求</span><br><span class="hljs-comment"> * /</span><br><span class="hljs-comment">Server: Apache</span><br><span class="hljs-comment">Content-Type: ...</span><br><span class="hljs-comment">Date: ...</span><br><span class="hljs-comment">Keep-Alive: timeout=5.max=1000</span><br><span class="hljs-comment">Connection: Keep-Alive</span><br><span class="hljs-comment">Age: ..</span><br><span class="hljs-comment">X-Cache-Info: caching</span><br><span class="hljs-comment">Content-length: 345</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 空行</span><br><span class="hljs-comment"> * 用于分隔响应头和响应正文</span><br><span class="hljs-comment"> * /</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 响应正文</span><br><span class="hljs-comment"> * 服务器返回给浏览器的资源</span><br><span class="hljs-comment"> * 可能是html页面，图片资源，音频资源</span><br><span class="hljs-comment"> * /</span><br></code></pre></td></tr></table></figure><h1 id="2-ACK数据包，消耗TCP序号？"><a href="#2-ACK数据包，消耗TCP序号？" class="headerlink" title="2. ACK数据包，消耗TCP序号？"></a>2. ACK数据包，消耗TCP序号？</h1><p>短回答，三次握手中纯ack数据包，不消耗tcp序号</p><h1 id="3-TCP三次握手中可以携带应用层数据吗？"><a href="#3-TCP三次握手中可以携带应用层数据吗？" class="headerlink" title="3. TCP三次握手中可以携带应用层数据吗？"></a>3. TCP三次握手中可以携带应用层数据吗？</h1><p>第三次握手可以，psh+ack，捎带应答。</p><h1 id="4-TCP三次握手建立连接，如果服务器不进行accept接收新连接，最多可以三次握手完成多少个连接？"><a href="#4-TCP三次握手建立连接，如果服务器不进行accept接收新连接，最多可以三次握手完成多少个连接？" class="headerlink" title="4. TCP三次握手建立连接，如果服务器不进行accept接收新连接，最多可以三次握手完成多少个连接？"></a>4. TCP三次握手建立连接，如果服务器不进行accept接收新连接，最多可以三次握手完成多少个连接？</h1><p>这是由”已完成连接队列”的大小的决定的。<br>TCP三次握手建立连接时，在内核中进行，并根据握手状态区分为两个队列，一个是“未完成连接队列”，一个是“已完成连接队列”，而应用程序的accept方法就是从已完成连接队列中获取三次握手完成的链接。<br>如果不通过accept取出连接（状态由等待被接受-&gt;已经被接受并正在通信），那上限就是“已完成连接队列”的大小。</p><h1 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h1><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul><li><a href="https://www.bilibili.com/video/BV1Jr4y1R7Ug/?spm_id_from=333.999.0.0&vd_source=0de7a910c6389bd641e5d95811407d7d">https://www.bilibili.com/video/BV1Jr4y1R7Ug/?spm_id_from=333.999.0.0&amp;vd_source=0de7a910c6389bd641e5d95811407d7d</a></li><li><a href="https://www.xiaolincoding.com/network/3_tcp/tcp_interview.html">https://www.xiaolincoding.com/network/3_tcp/tcp_interview.html</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>面经</tag>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java并发编程-常见面试代码题</title>
    <link href="/2023/09/19/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E4%BB%A3%E7%A0%81%E9%A2%98/"/>
    <url>/2023/09/19/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E4%BB%A3%E7%A0%81%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="题目1"><a href="#题目1" class="headerlink" title="题目1"></a>题目1</h1><ul><li>题目描述<figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs subunit">两个线程循环打印1<span class="hljs-string">-100</span>。<br></code></pre></td></tr></table></figure></li><li>Code<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Exam1</span> &#123;<br>    <span class="hljs-comment">//保证线程共享且可见</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">//锁，任意一个对象即可</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-comment">// 线程1的逻辑</span><br>            <span class="hljs-keyword">while</span> (num &lt; <span class="hljs-number">100</span>) &#123;<br>                <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>                    <span class="hljs-keyword">while</span> (num % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;<br>                        <span class="hljs-keyword">try</span> &#123;<br>                            lock.wait();<br>                        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                            e.printStackTrace();<br>                        &#125;<br>                    &#125;<br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;打印了&quot;</span> + num++);<br>                    lock.notifyAll();<br>                &#125;<br>            &#125;<br>        &#125;).start();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-comment">// 线程2的逻辑</span><br>            <span class="hljs-keyword">while</span> (num &lt; <span class="hljs-number">100</span>) &#123;<br>                <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>                    <span class="hljs-keyword">while</span> (num % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;<br>                        <span class="hljs-keyword">try</span> &#123;<br>                            lock.wait();<br>                        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                            e.printStackTrace();<br>                        &#125;<br>                    &#125;<br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;打印了&quot;</span> + num++);<br>                    lock.notifyAll();<br>                &#125;<br>            &#125;<br>        &#125;).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>如果是三个线程循环打印0-100呢？修改下while的条件即可，实际上还是唤醒了所有阻塞进程，不过每个阻塞进程会去判断当前其是否可以继续运行。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Exam1</span> &#123;<br>    <span class="hljs-comment">//保证线程共享且可见</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">//锁，任意一个对象即可</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-comment">// 线程1的逻辑</span><br>            <span class="hljs-keyword">while</span> (num &lt; <span class="hljs-number">100</span>) &#123;<br>                <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>                    <span class="hljs-keyword">while</span> (num % <span class="hljs-number">3</span> != <span class="hljs-number">1</span>) &#123;<br>                        <span class="hljs-keyword">try</span> &#123;<br>                            lock.wait();<br>                        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                            e.printStackTrace();<br>                        &#125;<br>                    &#125;<br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;打印了&quot;</span> + num++);<br>                    lock.notifyAll();<br>                &#125;<br>            &#125;<br>        &#125;).start();<br><br>        <span class="hljs-comment">//...</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>循环打印abc，写法一样，修改下判断条件即可。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Exam1</span> &#123;<br>    <span class="hljs-comment">//保证线程共享且可见</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">char</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;c&#x27;</span>;<br>    <span class="hljs-comment">//锁，任意一个对象即可</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">char</span>[] list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[]&#123;<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>&#125;;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-comment">// 线程1的逻辑</span><br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>                    <span class="hljs-keyword">while</span> (str != <span class="hljs-string">&#x27;c&#x27;</span>) &#123;<br>                        <span class="hljs-keyword">try</span> &#123;<br>                            lock.wait();<br>                        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                            e.printStackTrace();<br>                        &#125;<br>                    &#125;<br>                    str = list[(num++) % <span class="hljs-number">3</span>];<br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;打印了&quot;</span> + str);<br>                    lock.notifyAll();<br>                &#125;<br>            &#125;<br>        &#125;).start();<br><br>       <span class="hljs-comment">//....</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>这样的写法是唤醒所有的线程，然后线程去根据当前共享变量的状态决定是否阻塞，能否修改唤醒指定的线程？<br>需要为每个线程提供单独的锁对象。<br><strong>这种方式会出现死锁，目前还不知道原因。</strong><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> JUCExam;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Exam2</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-keyword">synchronized</span> (lock1) &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        lock1.wait();<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                    System.out.println(<span class="hljs-string">&quot;线程1正在打印：A &quot;</span>);<br>                    <span class="hljs-keyword">synchronized</span> (lock2) &#123;<br>                        lock2.notify();<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;).start();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-keyword">synchronized</span> (lock2) &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        lock2.wait();<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                    System.out.println(<span class="hljs-string">&quot;线程2正在打印：B&quot;</span>);<br>                    <span class="hljs-keyword">synchronized</span> (lock3) &#123;<br>                        lock3.notify();<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;).start();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-keyword">synchronized</span> (lock3) &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        lock3.wait();<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                    System.out.println(<span class="hljs-string">&quot;线程3正在打印：C&quot;</span>);<br>                    <span class="hljs-keyword">synchronized</span> (lock1) &#123;<br>                        lock1.notify();<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;).start();<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">100</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">synchronized</span> (lock1) &#123; <span class="hljs-comment">//唤醒线程1</span><br>            lock1.notify();<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>面经</tag>
      
      <tag>手写代码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>百度-实习-java开发-一面（纯凉面）</title>
    <link href="/2023/09/19/%E7%99%BE%E5%BA%A6-%E5%AE%9E%E4%B9%A0-java%E5%BC%80%E5%8F%91-%E7%BA%AF%E5%87%89%E9%9D%A2/"/>
    <url>/2023/09/19/%E7%99%BE%E5%BA%A6-%E5%AE%9E%E4%B9%A0-java%E5%BC%80%E5%8F%91-%E7%BA%AF%E5%87%89%E9%9D%A2/</url>
    
    <content type="html"><![CDATA[<p>题目没做出来，最近懈怠了，docker、k8s了解过少。<br>[TOC]</p><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h2 id="1-字符串运算"><a href="#1-字符串运算" class="headerlink" title="1. 字符串运算"></a>1. 字符串运算</h2><p>题目描述：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs subunit">一个由数字和运算符组成的字符串的表达式，按不同优先级组合数字和运算符，计算并返回所有可能组合的结果。可以按任意顺序返回答案。<br><br>输入：2<span class="hljs-string">-1</span><span class="hljs-string">-1</span><br>输出：[0, 2]<br>解释：((2<span class="hljs-string">-1</span>)<span class="hljs-string">-1</span>) = 0<br>      (2-(1<span class="hljs-string">-1</span>)) = 2<br><br>注： 运算符仅包含+, -, *, 输入整数范围[0,99]<br></code></pre></td></tr></table></figure><p>Code:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Exam1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Exam1</span> <span class="hljs-variable">exam1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Exam1</span>();<br>        HashSet&lt;Integer&gt; res = exam1.diffWaysToCompute(<span class="hljs-string">&quot;2-1*1&quot;</span>);<br>        <span class="hljs-keyword">for</span> (Integer i : res) System.out.println(i);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> HashSet&lt;Integer&gt; <span class="hljs-title function_">diffWaysToCompute</span><span class="hljs-params">(String input)</span> &#123;<br>        HashSet&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; input.length(); i++) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> input.charAt(i);<br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;+&#x27;</span> || c == <span class="hljs-string">&#x27;-&#x27;</span> || c == <span class="hljs-string">&#x27;*&#x27;</span>) &#123;<br>                HashSet&lt;Integer&gt; left = diffWaysToCompute(input.substring(<span class="hljs-number">0</span>, i));<br>                HashSet&lt;Integer&gt; right = diffWaysToCompute(input.substring(i + <span class="hljs-number">1</span>));<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> l : left) &#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> r : right) &#123;<br>                        <span class="hljs-keyword">switch</span> (c) &#123;<br>                            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>:<br>                                res.add(l + r);<br>                                <span class="hljs-keyword">break</span>;<br>                            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span>:<br>                                res.add(l - r);<br>                                <span class="hljs-keyword">break</span>;<br>                            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;*&#x27;</span>:<br>                                res.add(l * r);<br>                                <span class="hljs-keyword">break</span>;<br><br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (res.isEmpty() &amp;&amp; isNumeric(input)) &#123;<br>                res.add(Integer.parseInt(input));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isNumeric</span><span class="hljs-params">(String str)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Integer.parseInt(str);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (NumberFormatException e) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-用两个栈来实现一个队列，完成队列的-Push-和-Pop-操作。"><a href="#2-用两个栈来实现一个队列，完成队列的-Push-和-Pop-操作。" class="headerlink" title="2. 用两个栈来实现一个队列，完成队列的 Push 和 Pop 操作。"></a>2. 用两个栈来实现一个队列，完成队列的 Push 和 Pop 操作。</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyQueue</span>&lt;E&gt; &#123;<br>    <span class="hljs-keyword">private</span> LinkedList&lt;E&gt; stack1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-keyword">private</span> LinkedList&lt;E&gt; stack2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        MyQueue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyQueue</span>&lt;&gt;();<br>        queue.push(<span class="hljs-number">1</span>);<br>        queue.push(<span class="hljs-number">2</span>);<br>        queue.push(<span class="hljs-number">3</span>);<br>        System.out.println(queue.pop());<br>        queue.push(<span class="hljs-number">4</span>);<br>        System.out.println(queue.pop());<br>        System.out.println(queue.pop());<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(E e)</span>&#123;<br>        stack1.add(e);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">pop</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span>(stack2.isEmpty())&#123;<br>            <span class="hljs-keyword">while</span>(!stack1.isEmpty())stack2.add(stack1.poll());<br>        &#125;<br>        <span class="hljs-keyword">return</span> stack2.poll();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><h2 id="1-常用的数据结构？HashMap如何处理并发？"><a href="#1-常用的数据结构？HashMap如何处理并发？" class="headerlink" title="1. 常用的数据结构？HashMap如何处理并发？"></a>1. 常用的数据结构？HashMap如何处理并发？</h2><h2 id="2-String是线程安全吗？String不可修改的好处是什么？StringBuffer和StringBuilder？"><a href="#2-String是线程安全吗？String不可修改的好处是什么？StringBuffer和StringBuilder？" class="headerlink" title="2. String是线程安全吗？String不可修改的好处是什么？StringBuffer和StringBuilder？"></a>2. String是线程安全吗？String不可修改的好处是什么？StringBuffer和StringBuilder？</h2><p>String是线程安全，因为String对象不可变，任何对String对象的修改操作，都会返回新的String对象。</p><p>字符串字面量在编译时会放入字符串常量池(String Pool),是java堆的一部分，用于存储所有的字符串字面量，这样做的目的是为了避免创建多个相同内容的字符串独享，从而节省内存，提高性能（仅查找，无需在堆上分配新的内存和字符串对象），安全（不可变，所以没有并发访问的问题）。</p><p>使用场景？</p><ol><li>可以允许String类型存储hashcode，若String对象的hashcode频繁被使用，比如在HashMap容器中，字符串不变，则hashcode不变，可以缓存来提高性能。</li><li>String被很多Java类库当做参数，比如网络连接地址URL，文件路径path，反射机制，假设String不是固定不变，会引起安全隐患。</li></ol><p>以下是对字符串字面量复用的验证：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 执行String a=&quot;aaa&quot;步骤如下：</span><br><span class="hljs-comment"> * 1. 检查字符串常量池中是否已经存在值为“aaa”的字符串</span><br><span class="hljs-comment"> * 2. 如果存在，则a指向那个字符串；</span><br><span class="hljs-comment"> * 3. 如果不存在，在字符串常量池中创建一个新的字符串，并让a指向他。</span><br><span class="hljs-comment">**/</span><br><span class="hljs-comment">//验证创建两个值相同的String字面量，其引用地址是否相同 </span><br><span class="hljs-type">String</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;aaa&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;aaa&quot;</span>;<br>System.out.println(a == b); <span class="hljs-comment">//返回true</span><br><br><span class="hljs-comment">//但是只有形如String a=&quot;aaa&quot;的字面量才可以，如果使用new String来创建，不可以</span><br><span class="hljs-type">String</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;aaa&quot;</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;bbb&quot;</span>);<br>System.out.println(c == d); <span class="hljs-comment">//返回false</span><br><br><span class="hljs-comment">// 可以通过intern()方式将string显示的放入字符串常量池，或者说获取字符串常量池中的引用</span><br>c = c.intern();<br>d = d.intern();<br><br><span class="hljs-comment">// 现在，s1和s2都指向字符串常量池中的同一个字符串</span><br>System.out.println(c == d); <span class="hljs-comment">// 输出：true</span><br><br></code></pre></td></tr></table></figure><p>StringBuffer和StringBuilder并非基于String，而是基于Char[],他们是可变的，所以存在线程安全问题，但是StringBuffer使用synchronized关键字来保证其线程安全，StringBuilder是线程不安全的。</p><p>实际上String也是基于Char[]，只不过其Char[]使用了final修饰。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span><br>    <span class="hljs-keyword">implements</span> <span class="hljs-title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;<br>    <span class="hljs-comment">/** The value is used for character storage. */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">char</span> value[];<br>    <span class="hljs-comment">//....</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>有了String，为什么还需要StringBuilder&#x2F;StringBuffer?</strong><br>String是不可变的，任何修改字符串的操作都会创建新的String对象，并且会涉及复制字符到新的对象，这些可能会带对象创建以及拷贝的开销，消耗更多的内存。<br>而StringBuilder和StringBuffer是可变的，在修改时频繁修改时可以降低以上开销，并且操作的可读性更好。</p><h1 id="部署相关"><a href="#部署相关" class="headerlink" title="部署相关"></a>部署相关</h1><h2 id="1-项目的部署策略？"><a href="#1-项目的部署策略？" class="headerlink" title="1. 项目的部署策略？"></a>1. 项目的部署策略？</h2><h2 id="2-搜索具体做了什么？只是调api吗？"><a href="#2-搜索具体做了什么？只是调api吗？" class="headerlink" title="2. 搜索具体做了什么？只是调api吗？"></a>2. 搜索具体做了什么？只是调api吗？</h2><h2 id="3-AI搜索的机器哪里来的？规模怎么样？"><a href="#3-AI搜索的机器哪里来的？规模怎么样？" class="headerlink" title="3. AI搜索的机器哪里来的？规模怎么样？"></a>3. AI搜索的机器哪里来的？规模怎么样？</h2><h2 id="4-论文做了什么？"><a href="#4-论文做了什么？" class="headerlink" title="4. 论文做了什么？"></a>4. 论文做了什么？</h2>]]></content>
    
    
    
    <tags>
      
      <tag>面经</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>生产者&amp;&amp;消费者</title>
    <link href="/2023/09/19/%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85/"/>
    <url>/2023/09/19/%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85/</url>
    
    <content type="html"><![CDATA[<p>用LinkedList实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SharedQueue</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">capacity</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>; <span class="hljs-comment">//队列最大长度</span><br>    <span class="hljs-keyword">private</span> LinkedList&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">SharedQueue</span> <span class="hljs-variable">sharedQueue</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SharedQueue</span>();<br><br>        <span class="hljs-comment">//一个消费者，持续消费</span><br>        <span class="hljs-type">Consumer</span> <span class="hljs-variable">consumer</span> <span class="hljs-operator">=</span> sharedQueue.<span class="hljs-keyword">new</span> <span class="hljs-title class_">Consumer</span>();<br>        consumer.start();<br><br>        <span class="hljs-comment">//10个生产者,生产者生产完一条消息就结束</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)&#123;<br>            <span class="hljs-type">Producer</span> <span class="hljs-variable">producer</span> <span class="hljs-operator">=</span> sharedQueue.<span class="hljs-keyword">new</span> <span class="hljs-title class_">Producer</span>();<br>            producer.start();<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//消费者</span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Consumer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-keyword">synchronized</span> (queue) &#123;<br>                    <span class="hljs-keyword">if</span> (queue.isEmpty()) &#123;<br>                        System.out.println(<span class="hljs-string">&quot;当前队列为空&quot;</span>);<br>                        <span class="hljs-keyword">try</span> &#123;<br>                            queue.wait();<br>                        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                            e.printStackTrace();<br>                            <span class="hljs-comment">//出现异常，手动唤醒</span><br>                            queue.notify();<br>                        &#125;<br>                    &#125;<span class="hljs-keyword">else</span>&#123;<br>                        <span class="hljs-type">Integer</span> <span class="hljs-variable">val</span> <span class="hljs-operator">=</span> queue.poll();<br>                        System.out.println(<span class="hljs-string">&quot;消费者从队列中取出了消息，取出了&quot;</span>+val);<br>                        queue.notify(); <span class="hljs-comment">//唤醒生产者</span><br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//生产者</span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Producer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">synchronized</span> (queue) &#123;<br>                <span class="hljs-keyword">if</span> (queue.size() &lt; capacity) &#123;<br>                    queue.add(queue.size() + <span class="hljs-number">1</span>);<br>                    System.out.println(<span class="hljs-string">&quot;生产者往队列中添加了消息，队列当前长度为&quot;</span>+queue.size());<br>                    queue.notify();<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        queue.wait();<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                        queue.notify();<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上的阻塞唤醒、上锁行为，实际上阻塞队列中已经实现了，下面直接使用阻塞队列api来实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SharedQueue</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">capacity</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>; <span class="hljs-comment">//队列最大长度</span><br>    <span class="hljs-keyword">private</span> BlockingQueue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBlockingQueue</span>&lt;&gt;(capacity);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//....</span><br>    &#125;<br><br>    <span class="hljs-comment">//消费者</span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Consumer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-type">Integer</span> <span class="hljs-variable">val</span> <span class="hljs-operator">=</span> queue.take();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//生产者</span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Producer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                queue.put(queue.size()+<span class="hljs-number">1</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>JAVA</tag>
      
      <tag>代码练习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络编程基础</title>
    <link href="/2023/09/18/%E4%B8%BB%E6%B5%81%E7%9A%84%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/"/>
    <url>/2023/09/18/%E4%B8%BB%E6%B5%81%E7%9A%84%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="网络的演变过程"><a href="#网络的演变过程" class="headerlink" title="网络的演变过程"></a>网络的演变过程</h1><ul><li>BIO</li><li>NIO</li><li>IO多路复用I(select&#x2F;poll)</li><li>IO多路复用II(epoll)</li><li>信号驱动IO</li><li>AIO(异步IO)</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://papergames.jobs.feishu.cn/referral/campus/m/position?token=MzsxNjk0MTQwNzQ2OTI3OzcyMzU5Mzk2MDMyOTQ4MTQyMTA7MA">https://papergames.jobs.feishu.cn/referral/campus/m/position?token=MzsxNjk0MTQwNzQ2OTI3OzcyMzU5Mzk2MDMyOTQ4MTQyMTA7MA</a></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>携程-秋招-一二面</title>
    <link href="/2023/09/16/%E6%90%BA%E7%A8%8B-%E7%A7%8B%E6%8B%9B-%E4%B8%80%E4%BA%8C%E9%9D%A2/"/>
    <url>/2023/09/16/%E6%90%BA%E7%A8%8B-%E7%A7%8B%E6%8B%9B-%E4%B8%80%E4%BA%8C%E9%9D%A2/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="综合类"><a href="#综合类" class="headerlink" title="综合类"></a>综合类</h1><h2 id="1-mysql如何提高并发量？连接池的常用大小？"><a href="#1-mysql如何提高并发量？连接池的常用大小？" class="headerlink" title="1. mysql如何提高并发量？连接池的常用大小？"></a>1. mysql如何提高并发量？连接池的常用大小？</h2><p>思考的点包括哪些？</p><ol><li><strong>硬件方面</strong>：<ul><li>使用SSD提高IO速度；</li><li>增加内存来提供更大的缓冲区，减少IO操作</li><li>多核处理器：提供更多的并行能力</li></ul></li><li><strong>MYSQL配置优化</strong><ul><li>调整innodb_buffer_pool_size（存储引擎的内存缓冲池大小），应调整为系统总内存的60%-80%</li><li>调整innodb_log_file_size，适当增大日志文件大小可以提高写入性能</li><li>使用持久连接：避免频繁建立和关闭连接</li></ul></li><li>查询优化：索引+避免复杂查询+优化数据表（optimize table）+数据库结构优化（消除数据冗余，使用更适当的数据类型）</li><li><strong>读写分离</strong></li><li><strong>数据库分片</strong></li><li><strong>连接池</strong>：复用数据库连接，减少建立和关闭连接的开销</li><li>引擎更换：不需要事务且读多写少，上MyISAM</li><li>避免锁竞争：通过代码优化和数据库设计，减少长期持有锁的情况</li></ol><h2 id="2-java程序如何提高并发量？"><a href="#2-java程序如何提高并发量？" class="headerlink" title="2. java程序如何提高并发量？"></a>2. java程序如何提高并发量？</h2><p>思考的点包括哪些？（数据库方面的参考上一个问题）</p><ol><li>多线程编程</li><li>减少线程争用和使用更适当的并发集合，比如减少全局变量和静态变量的过渡使用</li><li>垂直（单台机器加性能）和水平扩展（添加更多服务器以分摊负载），以及微服务分摊负载，负载均衡器来分发请求</li><li>JVM调整：调整堆大小和GC策略来减少垃圾回收暂停</li><li>使用中间件和外部消息系统：消息队列异步处理请求，缓存减少对数据库访问</li><li>避免阻塞，使用非阻塞IO或异步IO</li></ol><h2 id="3-java程序CPU占用100-，如何排查？"><a href="#3-java程序CPU占用100-，如何排查？" class="headerlink" title="3. java程序CPU占用100%，如何排查？"></a>3. java程序CPU占用100%，如何排查？</h2><p>大概思路：</p><ol><li>top确定CPU使用率，以及java进程的ID</li><li>使用jstack <pid> &gt; threadDump.txt 获得线程堆栈转储</li><li>分析threadDump.txt文件，查找runnable状态的线程</li><li>通过堆栈转储定位到具体的代码段，进行代码审查</li><li>排除外部因素：数据库响应缓慢，网络延迟，外部服务延迟</li></ol><p>VisualVM可以连接到运行中的jvm，其提供了采样器和探查器，可以定位导致高cpu使用率的代码段</p><h2 id="4-redis的使用方式？"><a href="#4-redis的使用方式？" class="headerlink" title="4. redis的使用方式？"></a>4. redis的使用方式？</h2><h2 id="5-索引优化的场景？（撕逼了很久）？"><a href="#5-索引优化的场景？（撕逼了很久）？" class="headerlink" title="5. 索引优化的场景？（撕逼了很久）？"></a>5. 索引优化的场景？（撕逼了很久）？</h2><h2 id="6-一亿的键值对（时间，访问量），内存中怎么存？"><a href="#6-一亿的键值对（时间，访问量），内存中怎么存？" class="headerlink" title="6. 一亿的键值对（时间，访问量），内存中怎么存？"></a>6. 一亿的键值对（时间，访问量），内存中怎么存？</h2><h2 id="7-本机缓存、分布式缓存、多级缓存的优劣势？"><a href="#7-本机缓存、分布式缓存、多级缓存的优劣势？" class="headerlink" title="7. 本机缓存、分布式缓存、多级缓存的优劣势？"></a>7. 本机缓存、分布式缓存、多级缓存的优劣势？</h2><table><thead><tr><th>类型</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>本机缓存</td><td>速度快：数据存储在应用程序同一台服务器上，不存在网络开销；无需额外网络配置或外部组件</td><td>受制于单个机器内存大小；不易扩展；服务器崩溃，缓存数据会丢失；多服务器环境中，每个服务器的本地缓存可能出现数据不一致的情况；</td></tr><tr><td>分布式缓存</td><td>水平扩展：可以容易地通过增加更多的服务器来扩展缓存容量；数据的持久性和可用性；</td><td>复杂性；存在网络延迟；需要更多的硬件资源和管理工作</td></tr><tr><td>多级缓存</td><td>灵活性:可以根据需要和访问模式调整每级缓存的大小和策略；高效率：经常访问的数据可以存储在本地缓存，较少访问的数据可以存储在分布式缓存中；高可用性：结合了本地缓存的速度和分布式缓存的扩展性</td><td>复杂性；一致性问题：在不同级别的缓存之间保持数据一致性可能比较复杂</td></tr></tbody></table><h2 id="8-top命令中的几个值的含义？（不知道他说的啥，就说了用户态、内核态、空闲态的cpu占用）"><a href="#8-top命令中的几个值的含义？（不知道他说的啥，就说了用户态、内核态、空闲态的cpu占用）" class="headerlink" title="8. top命令中的几个值的含义？（不知道他说的啥，就说了用户态、内核态、空闲态的cpu占用）"></a>8. top命令中的几个值的含义？（不知道他说的啥，就说了用户态、内核态、空闲态的cpu占用）</h2><h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><h2 id="1-介绍下TCP和UDP的区别？TCP如何实现可靠传输？"><a href="#1-介绍下TCP和UDP的区别？TCP如何实现可靠传输？" class="headerlink" title="1. 介绍下TCP和UDP的区别？TCP如何实现可靠传输？"></a>1. 介绍下TCP和UDP的区别？TCP如何实现可靠传输？</h2><h2 id="2-Restful-api常用的method？"><a href="#2-Restful-api常用的method？" class="headerlink" title="2. Restful api常用的method？"></a>2. Restful api常用的method？</h2><table><thead><tr><th>Method</th><th>描述</th></tr></thead><tbody><tr><td>GET</td><td>用于读取信息，幂等的</td></tr><tr><td>POST</td><td>用于创建新资源</td></tr><tr><td>PUT</td><td>更新会创建指定资源，幂等的</td></tr><tr><td>DELETE</td><td>用于删除指定的资源，幂等</td></tr><tr><td>PATCH</td><td>用于更新部分资源</td></tr><tr><td>HEAD</td><td>与get相同，但是只返回HTTP头部，不返回实体的主体</td></tr><tr><td>OPTIONS</td><td>用于描述目标资源的通信选项，返回该资源支持的HTTP方法</td></tr></tbody></table><p>PUT和PATCH方法的区别：</p><ol><li>意图：put幂等，主要目的是完全替换目标资源，也就是说，即使只改一个属性，也要提供完整的更新内容；patch用于部分更新目标资源，仅需提供资源中要修改的属性和新值，不一定是幂等的。</li><li>资源不存在时：put可能会创建一个新资源，patch会返回一个错误。</li><li>传输与安全性：put可以只传输修改部分，更搞笑，但是可能会产生安全性问题。</li></ol><h2 id="3-http状态码？403？"><a href="#3-http状态码？403？" class="headerlink" title="3. http状态码？403？"></a>3. http状态码？403？</h2><table>    <tr>        <th>分类</th>        <th>状态码</th>    </tr>    <tr>        <td rowspan="2">1xx(信息响应)</td>        <td>100 continue：服务器已经接收到请求的初始部分，并且客户端应继续请求，如果请求已经完成，则忽略</td>    </tr>    <tr>        <td>101 Switching Protocals：服务器了解并准确切换协议，例如从Http/1.1切换到WebSocket</td>    </tr>    <tr>        <td rowspan="3">2xx(成功）</td>        <td>200 OK：请求成功</td>    </tr>    <tr>        <td>201 Created: 请求已被实现，结果是创建了一个新的资源</td>    </tr>    <tr>        <td>204 No Content: 服务器已经成功处理请求，但是没有返回任何内容</td>    </tr>    <tr>        <td rowspan="3">3xx(重定向）</td>        <td>301 Moved Permanently：被请求的资源已永久移动到新的URL</td>    </tr>    <tr>        <td>302 Found：被请求的资源临时从不同的URI响应</td>    </tr>    <tr>        <td>304 Not Modified：该资源自从上次请求后没有任何修改</td>    </tr>    <tr>        <td rowspan="5"><Strong>4xx(客户端错误）</Strong></td>        <td>400 Bad Request：服务器不能或不会处理请求，由于客户端似乎有错误</td>    </tr>    <tr>        <td>401 Unauthorized：请求需要用户的身份验证</td>    </tr>    <tr>        <td><Strong>403 Forbidden：服务器理解客户端的请求，但拒绝执行他。</Strong>一般在权限不足或api调用超限时使用。</td>    </tr>    <tr>        <td>404 Not Found：请求的资源在服务器上未找到</td>    </tr>    <tr>        <td>429 Too Many Requests：用户在给定时间内发送了太多的请求</td>    </tr>    <tr>        <td rowspan="3"><Strong>5xx(服务器错误）</Strong></td>        <td>500 Internal Server Error：服务器遇到一个情况，不知道如何处理</td>    </tr>    <tr>        <td>502 Bad Gateway：服务器作为网关或代理，从上游服务器收到一个无效的响应。</td>    </tr>    <tr>        <td>503 Service Unavailable：服务器不准确处理请求，通常情况是服务器过载或正在维护</td>    </tr></table><h2 id="4-http的请求头"><a href="#4-http的请求头" class="headerlink" title="4. http的请求头"></a>4. http的请求头</h2><table><thead><tr><th>字段</th><th>描述</th></tr></thead><tbody><tr><td>accept</td><td>告知服务器客户端可以处理的媒体类型</td></tr><tr><td>accept-chatset</td><td>客户端可以理解的字符集，与文本的编码方式有关</td></tr><tr><td>accept-encoding</td><td>客户端可以处理的内容编码，与压缩方式有挂</td></tr><tr><td>accept-language</td><td>首选语言</td></tr><tr><td>Authorization</td><td>用于身份验证的凭证</td></tr><tr><td>Host</td><td>指定请求资源的internet主机和端口号</td></tr><tr><td>User-agent</td><td>描述发出请求的用户代理，描述请求来自哪种浏览器、操作系统或设备，版本，或其他信息，主要作用是允许内容提供者提供与特定浏览器或设备更兼容的内容。可能会被伪造。</td></tr></tbody></table><h2 id="5-你们为什么使用http来处理请求？"><a href="#5-你们为什么使用http来处理请求？" class="headerlink" title="5. 你们为什么使用http来处理请求？"></a>5. 你们为什么使用http来处理请求？</h2><ol><li>简单：文本协议，人类可读，开发者能快读理解。</li><li>无状态：请求独立，简化了服务器设计，并允许请求负载均衡。</li><li>广泛支持：几乎所有的编程语言和平台都有库和框架来处理http交互，并且web浏览器的普及，且主流web浏览器都使用http作为主要通信协议、</li><li>无需建立长连接：虽然http1.0和http1.1支持持久连接，但是大部分情况并不需要保持长时间连接，这对于节省服务器资源和处理并发请求非常有用。</li><li>安全性：https为网站和用户提供了加密和身份验证，保护数据在传输过程中的安全性。</li></ol><p>总结：简单、灵活、广泛受支持、并且能满足大多数web应用的需要。</p><h2 id="6-Http1-1有无队头阻塞，并发模式？keepalive？"><a href="#6-Http1-1有无队头阻塞，并发模式？keepalive？" class="headerlink" title="6. Http1.1有无队头阻塞，并发模式？keepalive？"></a>6. Http1.1有无队头阻塞，并发模式？keepalive？</h2><p>这里主要补充下http发展历史：</p><ul><li><p>http1.1相对http1.0的改进：</p><ul><li>使用长连接改善短连接造成的性能开销（keep-alive）</li><li>使用管道网络传输，只要一个请求发送出去，不必等其回来，就可以发送第二个请求出去，减少整体的响应时间，即解决发送方的队头阻塞问题（这个大部分场景下不支持）</li></ul></li><li><p>http1.1的问题：</p><ul><li>请求&#x2F;响应头部未压缩，首部信息越多延迟越大</li><li>发送冗余的首部，每次互相发送相同的首部造成浪费较多</li><li>服务器处理按请求顺序响应，如果服务器响应慢，客户端一直请求不到数据，会队头阻塞</li><li>没有请求优先级控制</li><li>请求只能从客户端开始，服务器只能被动响应</li></ul></li><li><p>http2相对http1.1的改进</p><ul><li>头部压缩：若同时发出多个请求，头一样或相似，会消除重复部分，使用hpack算法，维护头信息表，将字段入表，之后相同，则发送索引号。</li><li>二进制格式：头信息和数据体都使用二进制，计算机无需在明文和二进制之间转换</li><li>并发传输：解决队头阻塞问题，多个stream复用一个tcp连接，可乱序发送，服务器通过stream id区分，并组装成有序的http消息</li><li>服务器主动推送资源：双方都可以建立stream，客户端用奇数，服务器用偶数。主要用于服务器提前发送客户端可能需要的资源，减少时延和开销。</li></ul></li><li><p>http2的缺点：</p><ul><li>队头阻塞：stream看似解决http1的队头阻塞，但是无法解决发生在tcp层面的阻塞，tcp需要包有序，如果无序，则会将后续包放入缓冲区，一旦发生丢包，会出发重传，一个tcp连接中所有http请求都必须等待这个丢了的包被重传回来。（实际上是响应端的队头阻塞）</li></ul></li><li><p>http3相对http2的改进：</p><ul><li>将会发生阻塞的tcp换成了udp，并通过quic协议来实现类似tcp的可靠传输<ul><li>无队头阻塞：某个stream丢包，只阻塞这个stream，不影响其他stream</li><li>更快的连接建立：过去tcp和tls是分层的，需要分批次握手，而quic内部包含了tls，可以在一个rtt内（三次握手）完成连接简历和密钥写上</li><li>连接迁移：tcp使用四元组来确定一条tcp连接，若切换网络环境，IP地址变了，必须断开连接，重新建立（tcp和tsl分别握手+tcp慢启动，时延很高，迁移成本高），而quic使用连接id来分别标记双方，ip地址变化后，也可以无缝复用原连接，无需重连，没有卡顿。</li></ul></li></ul></li><li><p>http3的缺点：</p><ul><li>很多网络设备不知道quic，只知道udp，有的网络设备会丢弃udp。</li><li>普及缓慢</li></ul></li></ul><p>Keep-Alive是http1.1头部，与持久连接有关，持久连接希望在http请求在传输完数据后保持连接打开，以便之后的请求可以重用该连接，减少频繁建立和关闭连接带来的开销。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">http1</span>.<span class="hljs-number">1</span>的头部信息，http2中默认支持多路复用，以下头部字段不需要<br><br><span class="hljs-comment"># 代表打开持久连接</span><br><span class="hljs-attribute">connection</span>:keep-alive <br><br><span class="hljs-comment"># 保持打开状态5s，并且可以被重用1000次</span><br><span class="hljs-attribute">Keep</span>-Alive: timeout, max=<span class="hljs-number">1000</span><br></code></pre></td></tr></table></figure><h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><h2 id="1-介绍下哈希查找的过程？"><a href="#1-介绍下哈希查找的过程？" class="headerlink" title="1. 介绍下哈希查找的过程？"></a>1. 介绍下哈希查找的过程？</h2><h2 id="2-BIO和NIO"><a href="#2-BIO和NIO" class="headerlink" title="2. BIO和NIO"></a>2. BIO和NIO</h2><p>还需要更新<br>java中两种主要的IO处理方式，主要区别在于是否允许线程在等待数据时被阻塞。</p><ol><li>BIO（Blocking IO）<ul><li>阻塞模式：当线程调用read或write方法 ，该线程被阻塞，直到数据被读取或写入，或者发生某个异常，这意味着其他IO操作必须等待当前操作完成。</li><li>模型简单：模型简单，流程清晰</li><li>效率问题：每次IO都会导致线程被阻塞，如果请求并发量大，需要创建大量线程来处理IO，导致资源浪费和系统压力增加。</li></ul></li><li>NIO（Non-blocking IO）<ul><li>非阻塞模式：线程调用read，如果没有数据可读，线程可以继续执行其他任务，write同理。线程通常将非阻塞IO的空闲时间用于在其他IO通道上执行IO操作，所以单个线程可以管理多个数据输出。</li><li>缓冲区：NIO引入了缓冲区的概念，数据的读写都是基于缓冲区进行的，缓冲区实质上是一个数组</li><li>选择器：NIO引入了selector的概念，选择器可以监视多个IO通道，检查那个通道已经准备好了读写，使得一个线程可以管理多个通道。</li><li>灵活性增加，但是编程复杂度也增加。</li></ul></li></ol><h1 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h1><h2 id="1-IPv4转int，int转IPv4（手写）"><a href="#1-IPv4转int，int转IPv4（手写）" class="headerlink" title="1. IPv4转int，int转IPv4（手写）"></a>1. IPv4转int，int转IPv4（手写）</h2><h2 id="2-汉诺塔（手写）"><a href="#2-汉诺塔（手写）" class="headerlink" title="2. 汉诺塔（手写）"></a>2. 汉诺塔（手写）</h2><h2 id="3-排序算法？介绍下快排？"><a href="#3-排序算法？介绍下快排？" class="headerlink" title="3. 排序算法？介绍下快排？"></a>3. 排序算法？介绍下快排？</h2><h2 id="4-介绍下查找算法？"><a href="#4-介绍下查找算法？" class="headerlink" title="4. 介绍下查找算法？"></a>4. 介绍下查找算法？</h2><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>线性查找</td><td>逐项查找，时间复杂度O(n)</td></tr><tr><td>二分查找</td><td>列表需要有序，时间复杂度O(logn)</td></tr><tr><td>哈希表查找</td><td>将键转换为数组的索引，平均时间复杂度O(1),出现哈希冲突，最差时间复杂度为O(n)</td></tr><tr><td>插值查找</td><td>对二分查找的改进，适用于均匀分布的已排序数据集，根据查找的键值与查找范围的首尾键值的关系来估算要查找的键值在查询范围内的位置。（所以要数据分布均匀）</td></tr><tr><td>二叉搜索树查找</td><td>相对二分查找，更适合动态数据，插入删除相对数组容易，但可能存在不平衡问题</td></tr></tbody></table><p>还有二叉搜索树查找，平衡树查找，b树b+树查找，索引查找,跳表查询</p><h2 id="5-链表和数组？"><a href="#5-链表和数组？" class="headerlink" title="5. 链表和数组？"></a>5. 链表和数组？</h2>]]></content>
    
    
    
    <tags>
      
      <tag>面经</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>携程面经-搬运</title>
    <link href="/2023/09/15/%E6%90%BA%E7%A8%8B%E9%9D%A2%E7%BB%8F-%E6%90%AC%E8%BF%90/"/>
    <url>/2023/09/15/%E6%90%BA%E7%A8%8B%E9%9D%A2%E7%BB%8F-%E6%90%AC%E8%BF%90/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><h2 id="1-jvm内存"><a href="#1-jvm内存" class="headerlink" title="1. jvm内存"></a>1. jvm内存</h2><p>不细写了。</p><ul><li>线程共享：<ul><li>堆：存放对象实例，gc的主要区域，当内存泄露、分配大量大对象时会OOM</li><li>方法区：存放类的信息，元空间是其底层物理实现，当类加载过多，会产生OOM</li></ul></li><li>线程私有：<ul><li>java栈：存放基础数据类型和对象引用</li><li>本地方法栈：服务于其他语言的本地方法，和java栈一样，也有小概率发生OOM，场景是创建了太多的线程，每个线程都会都会分配一定的必要的内存空间，线程过多，则OOM。</li><li>程序计数器：字节码执行的行号指示器</li></ul></li></ul><h2 id="2-强引用，软引用，弱引用，虚引用"><a href="#2-强引用，软引用，弱引用，虚引用" class="headerlink" title="2. 强引用，软引用，弱引用，虚引用"></a>2. 强引用，软引用，弱引用，虚引用</h2><p>与垃圾回收机制有关，可以帮助程序员更加灵活的控制对象的生命周期。</p><table><thead><tr><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>强引用</td><td>只要对象有强引用与之关联，GC绝不对其回收；比方说Object obj &#x3D; new Object();</td></tr><tr><td>软引用</td><td>在内存紧张时会被回收</td></tr><tr><td>弱引用</td><td>比软引用生命周期更短，一旦jvm进行垃圾回收，与弱引用关联的对象都会被回收，不考虑其他引用情况，是一种积极的的回收策略；适用于不希望对象长时间活在内存的场景，例如WeekHashMap</td></tr><tr><td>虚引用</td><td>主要是用来跟踪对象被垃圾回收的状态，与其关联的对象总是被可垃圾回收，有虚引用关联，不影响其生命周期</td></tr></tbody></table><h2 id="3-线程池核心参数有哪些，keppalive参数有什么用？线程池的阻塞队列有哪些？"><a href="#3-线程池核心参数有哪些，keppalive参数有什么用？线程池的阻塞队列有哪些？" class="headerlink" title="3. 线程池核心参数有哪些，keppalive参数有什么用？线程池的阻塞队列有哪些？"></a>3. 线程池核心参数有哪些，keppalive参数有什么用？线程池的阻塞队列有哪些？</h2><p>线程池的核心参数：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>核心线程数</td><td></td></tr><tr><td>最大线程数</td><td></td></tr><tr><td>阻塞队列</td><td></td></tr><tr><td>KeepAliveTime</td><td>线程池中超过核心线程数的空闲线程的最大空闲时间，实际上getTask中poll方法的参数</td></tr><tr><td>unit</td><td>keepAliveTime的时间单位</td></tr><tr><td>ThreadFactory</td><td>创建现成的工厂</td></tr><tr><td>handler</td><td>线程池的拒绝策略</td></tr></tbody></table><p>阻塞队列有哪些？</p><table><thead><tr><th>队列</th><th>描述</th><th>使用场景</th></tr></thead><tbody><tr><td>ArrayBlockingQueue</td><td>数组支持的有界阻塞队列</td><td></td></tr><tr><td>LinkedBlockingQueue</td><td>链表支持的阻塞队列，可指定大小，不指定默认容量为Integer.MAX_VALUE</td><td></td></tr><tr><td>PriorityBlockingQueue</td><td>支持优先级的无界队列，需要定义比较器</td><td></td></tr><tr><td>SynchronousQueue</td><td>不存储元素，用于线程间数据交换</td><td></td></tr><tr><td>DelayedQueue</td><td>元素到期才能被取出，用于创建时间延迟的缓存场景</td><td>定时任务，周期性任务</td></tr><tr><td>LinkedBlockingQueue</td><td>双端版本的LinkedBlockingQueue</td><td></td></tr><tr><td>LinkedTransferQueue</td><td>链表支持的，生产者线程会等待消费者接收数据</td><td></td></tr></tbody></table><p>拒绝策略有哪些（简写）？</p><ol><li>抛出异常（默认）</li><li>静默处理</li><li>移除阻塞队列中队头的任务，插入新任务</li><li>调用者线程执行任务，算是个负反馈，来降低任务分发的频率</li></ol><h2 id="4-threadlocal是什么？有内存溢出风险吗？"><a href="#4-threadlocal是什么？有内存溢出风险吗？" class="headerlink" title="4. threadlocal是什么？有内存溢出风险吗？"></a>4. threadlocal是什么？有内存溢出风险吗？</h2><p>ThreadLocal是java提供的一个线程局部变量的工具，每个线程都有一个局部变量，可以通过ThreadLocal存取，不同线程之间相互独立。<br>内存泄露？<br>ThreadLocal的生命周期和线程绑定，所以在线程池这种，线程复用的场景，如果使用完不清理ThreadLocal的值，可能会导致内存泄露。</p><h1 id="5-什么是线程死锁？怎么解决或防止死锁？"><a href="#5-什么是线程死锁？怎么解决或防止死锁？" class="headerlink" title="5. 什么是线程死锁？怎么解决或防止死锁？"></a>5. 什么是线程死锁？怎么解决或防止死锁？</h1><p>线程死锁是指两个及两个以上的线程在执行过程中，由于竞争资源而导致的互相等待的现象，若无外力作用，他们都无法进行下去。<br>一种简单的情况是，两个线程分别占有一部分资源并等待对方释放自己所需要的资源。</p><p>死锁产生的四个条件<br>    * 互斥<br>    * 请求并保持<br>    * 不剥夺<br>    * 循环等待</p><p>解决或防止死锁的方法<br>    * 资源有序分配<br>    * 线程开始前分配所有必要资源<br>    * 一个线程请求资源得不到满足，则必须释放其占有的所有资源<br>    * 死锁的检测和解除<br>    * 超时与重试</p><h1 id="6-spring面向切片编程的实现原理，spring动态代理"><a href="#6-spring面向切片编程的实现原理，spring动态代理" class="headerlink" title="6. spring面向切片编程的实现原理，spring动态代理"></a>6. spring面向切片编程的实现原理，spring动态代理</h1><p>面向切片编程AOP是提取在应用程序中多个地方都有影响，且与主业务逻辑无关的功能，比如日志、事务管理等。<br>实现原理：spring容器实例化bean时，会查找定义的切面，并根据切面和通知创建响应的代理对象，这些代理对象将原始的bean包装在内，并在调用目标方法时执行相应的通知。<br>动态代理：代理对象包装目标对象，当代理对象的一个方法被调用时，他会执行相应的通知，然后再调用原始对象上的相应方法。</p><h2 id="7-哪些框架用了反射？反射会有什么问题？"><a href="#7-哪些框架用了反射？反射会有什么问题？" class="headerlink" title="7. 哪些框架用了反射？反射会有什么问题？"></a>7. 哪些框架用了反射？反射会有什么问题？</h2><p>使用反射的java框架：</p><ul><li>spring</li><li>hibernate</li><li>junit</li><li>javaBean</li><li>structs</li></ul><p>问题：</p><ul><li>性能：反射方法通常比非反射方法调用慢</li><li>安全：可能会破坏封装</li><li>类型的安全问题：反射不会进行类型检查，类型问题可能在运行时出现，会导致运行时异常</li></ul><p>使用反射创建实例的例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 类名</span><br><span class="hljs-type">String</span> <span class="hljs-variable">className</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;java.lang.String&quot;</span>;<br><span class="hljs-comment">// 通过反射获取类</span><br>Class&lt;?&gt; clazz = Class.forName(className);<br><span class="hljs-comment">// 创建实例</span><br><span class="hljs-type">Object</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> clazz.getDeclaredConstructor().newInstance();<br><span class="hljs-comment">// 打印实例</span><br>System.out.println(instance);<br></code></pre></td></tr></table></figure><h2 id="8-逃逸分析"><a href="#8-逃逸分析" class="headerlink" title="8. 逃逸分析"></a>8. 逃逸分析</h2><p>一种编译器器优化技术，主要目的是分析对象的动态作用于，确定对象是否可能逃逸出方法或者线程的作用域，进而决定如何更有效的分配和管理对象。</p><p>应用：</p><ol><li>栈上分配：java中对象通常在堆上分配，需要进行垃圾回收，如果逃逸分析发生一个对象只在一个方法作用域内有效，不会被其他才能线程引用，那么可以分配在栈上，从而避免在堆上分配和后续的垃圾回收。</li><li>锁消除：若对象不会被多线程共享，则可以消除不必要的锁操作。</li><li>锁粗化：如果连续多次对同一个对象进行同步，则可以将多次锁操作合并为一次，减少锁竞争。</li></ol><p>Java HotSpot VM，可以通过JVM参数来启用逃逸分析，虽然可以提高程序的性能，减少不必要的内存和锁开销，但是会导致编译时间增加。</p><h1 id="MySql"><a href="#MySql" class="headerlink" title="MySql"></a>MySql</h1><h2 id="1-mysql什么情况下会加行锁，什么情况加表锁"><a href="#1-mysql什么情况下会加行锁，什么情况加表锁" class="headerlink" title="1. mysql什么情况下会加行锁，什么情况加表锁"></a>1. mysql什么情况下会加行锁，什么情况加表锁</h2><p>如果使用的引擎是innodb的话，默认使用的是行锁。</p><ul><li>加表锁的情况<ul><li>执行DDL操作</li><li>sql语句导致无法预测要锁定哪些行，可能会使用表锁，比如说外键约束的场景</li><li>显式的使用lock table语句</li></ul></li><li>加行锁的情况<ul><li>where子句匹配到了主键或唯一索引</li><li>执行了范围查询、全表扫描、或不使用索引的查询，不过有可能会锁定大量行，接近全表的数据。</li><li>insert，update，delete语句中受影响的行</li><li>select … for update(排他锁)，select … lock in share mode(共享锁),会对所选行加行锁</li></ul></li></ul><h2 id="2-mysql索引结构，b-树相对于b树的改进，带来了哪些好处？"><a href="#2-mysql索引结构，b-树相对于b树的改进，带来了哪些好处？" class="headerlink" title="2. mysql索引结构，b+树相对于b树的改进，带来了哪些好处？"></a>2. mysql索引结构，b+树相对于b树的改进，带来了哪些好处？</h2><ol><li>b+树将数据全存储在叶子结点中，使得每个非叶子结点中可以存储更多的索引，树的整体高度降低，而树的高度和磁盘的IO次数相关，有效的降低了IO的开销，同时使得查询更加稳定。</li><li>b+树使用双向链表将叶子结点进行串联，提高了排序、范围查询等操作的效率。</li><li>b+树插入删除效率上更高，因为数据只存在于叶子节点，不必在整棵树上移动。</li></ol><h2 id="3-要对一个列做模糊查询，希望走索引，应该怎么做？"><a href="#3-要对一个列做模糊查询，希望走索引，应该怎么做？" class="headerlink" title="3. 要对一个列做模糊查询，希望走索引，应该怎么做？"></a>3. 要对一个列做模糊查询，希望走索引，应该怎么做？</h2><p>需要看查询的需求</p><ol><li>如果是模糊查询是以固定前缀开头，那直接对该列加索引或者前缀索引就可。</li><li>如果不以固定前缀开头<ul><li>使用全文索引  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> FULLTEXT INDEX idx_name <span class="hljs-keyword">ON</span> table_name(column_name);<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> table_name <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">MATCH</span>(column_name) AGAINST(<span class="hljs-string">&#x27;abc&#x27;</span>);<br></code></pre></td></tr></table></figure></li><li>使用搜索引擎，利用倒排索引的方式来。<ul><li>主要思想是：关键词-&gt;文档id的映射，对关键词索引和文档id分别做了优化，如关键词有序，且使用前缀树降低内存开销。文档id通过增量id，integer数组和bitmap的混合使用来降低硬盘开销。</li></ul></li></ul></li></ol><h2 id="4-SQL表有4个列，每个列加单独索引，然后查询语句里where条件4个列都有-的条件，问是否用到索引？用到的话是用了什么索引？"><a href="#4-SQL表有4个列，每个列加单独索引，然后查询语句里where条件4个列都有-的条件，问是否用到索引？用到的话是用了什么索引？" class="headerlink" title="4. SQL表有4个列，每个列加单独索引，然后查询语句里where条件4个列都有&#x3D;的条件，问是否用到索引？用到的话是用了什么索引？"></a>4. SQL表有4个列，每个列加单独索引，然后查询语句里where条件4个列都有&#x3D;的条件，问是否用到索引？用到的话是用了什么索引？</h2><p>会用到索引，优化器会使用其中他认为最优的索引来执行。</p><h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><ol><li>缓存穿透的解决策略<br>首先要区分三个概念</li></ol><table><thead><tr><th>类型</th><th>现象</th><th>原因</th></tr></thead><tbody><tr><td>缓存雪崩</td><td>大量的key在同一时间失效，导致请求大量打到数据库上，导致数据库宕机</td><td>过期时间可以加上随机数；可以在过期前主动更新缓存；</td></tr><tr><td>缓存击穿</td><td>热点数据的key失效，导致访问该热点数据的请求，打到数据库上</td><td>热点数据永不过期，利用后台线程进行数据更新；设置二级缓存，当一级缓存失效后，可以访问二级缓存；设置互斥锁，保证只有一个请求去访问数据库更新缓存，其他线程等待。</td></tr><tr><td>缓存穿透</td><td>访问一个数据库中不存在的key，会导致redis无法拦截请求，请求每次都打到数据库上</td><td>reids中可以存储一个null值，设置较短的过期时间；可以通过bitmap或者布隆过滤器来拦截请求</td></tr></tbody></table><h2 id="1-redis为什么快"><a href="#1-redis为什么快" class="headerlink" title="1. redis为什么快?"></a>1. redis为什么快?</h2><p>不细讲，不过要看看标准答案是什么</p><ol><li>内存操作vs磁盘操作</li><li>数据结构简单，且底层实现高效</li><li>处理用户请求时是单线程，避免了线程上下文切换的开销，也避免了处理数据竞争和死锁的开销。</li></ol><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h2 id="1-介绍快速排序、归并排序"><a href="#1-介绍快速排序、归并排序" class="headerlink" title="1. 介绍快速排序、归并排序"></a>1. 介绍快速排序、归并排序</h2><p>快排和归并都是分治的思想。<br>快排：选择基准-&gt;划分-&gt;递归处理子序列<br>归并排序（merged sort）：</p><ul><li>分解：将列表中每个元素放入单独的列表</li><li>递归排序：递归合并这些子列表以产生新的排序子列表</li><li>合并：反复合并这些子列表，直到只剩下一个已排序的列表。</li></ul><h1 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h1><h2 id="1-服务器内存溢出，cpu占用100-，这些怎么排查"><a href="#1-服务器内存溢出，cpu占用100-，这些怎么排查" class="headerlink" title="1. 服务器内存溢出，cpu占用100%，这些怎么排查"></a>1. 服务器内存溢出，cpu占用100%，这些怎么排查</h2><ol><li>查看系统日志，找相关的错误和警告</li><li>使用top和htop查看哪些进程&#x2F;线程在消耗大量cpu</li><li>使用perf，linux性能分析工具，可以查找到哪些函数或系统调用导致了高CPU使用</li><li>java应用的话，可以使用jstack来查看哪些线程或代码段导致了高的CPU使用</li><li>检查硬件故障</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>面经</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常见选型问题</title>
    <link href="/2023/09/15/%E5%B8%B8%E8%A7%81%E9%80%89%E5%9E%8B%E9%97%AE%E9%A2%98/"/>
    <url>/2023/09/15/%E5%B8%B8%E8%A7%81%E9%80%89%E5%9E%8B%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="1-为什么选择Meilisearch？"><a href="#1-为什么选择Meilisearch？" class="headerlink" title="1. 为什么选择Meilisearch？"></a>1. 为什么选择Meilisearch？</h1><p>这和我们项目的性质有关，我们是希望做出一个有少量用户的原型，以向投资者展示潜力。<br>在这个背景下，我们主要对比了Meilisearch和ES，<br>学习难度上：MeiliSearch的配置更简单，维护更简单，api也比较直观和简单<br>资源消耗上：meilisearch更轻量，消耗的内存和cpu资源更少<br>功能上：meilisearch仅是一个比较纯粹的搜索引擎，不具备es中机器学习插件、日志处理等功能，但对于我们来说够用。<br>与django的适配上：django集成Meilisearch的第三方库更完备<br>不过随着未来的项目增长，确实需要考虑迁移到es上。</p><h1 id="2-为什么选择websocket而不是http来实现聊天？"><a href="#2-为什么选择websocket而不是http来实现聊天？" class="headerlink" title="2. 为什么选择websocket而不是http来实现聊天？"></a>2. 为什么选择websocket而不是http来实现聊天？</h1><ol><li>tcp本身是全双工，但是常用的Http1.1,虽然基于tcp协议，但是本身是半双工的，对于聊天这种需要服务器主动推送数据到客户端的场景，不友好，所以需要使用支持全双工的websocket协议。</li><li>http1.1里，是请求-响应模型，虽然可以使用定时轮询，长轮询等方式实现服务推送，但是如果需要频繁交互的话，websocket消耗资源更少。</li><li>相对http，websocket头部信息更少，相同数量的消息在websocket上会产生更少的网络流量。</li><li>适合广播，能够很好的扩展到聊天室或群聊场景。</li></ol><p>扩展：http2.0引入了服务器的推送的特性，为什么不选择http2.0？</p><ol><li>推送的不同：http2.0的目的是解决服务器知道客户端需要的资源，进行提前发送，来减少往返时间和延迟的场景。例如，客户端请求一个html页面，服务端可能知道客户端会需要与之相关的css和js文件，可提前推送。相对比，websocket是真正的双向和实时通信，允许客户端和服务器之间任意时刻发送数据，不需要预测或以前知道对方需要什么。</li><li>兼容性：http2.0有些浏览器和服务器并不支持，特别是服务器推送功能，websocket的兼容性更好。</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>面经</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>索引创建实际遇到的问题-搬运</title>
    <link href="/2023/09/15/%E7%B4%A2%E5%BC%95%E5%88%9B%E5%BB%BA%E5%AE%9E%E9%99%85%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98-%E6%90%AC%E8%BF%90/"/>
    <url>/2023/09/15/%E7%B4%A2%E5%BC%95%E5%88%9B%E5%BB%BA%E5%AE%9E%E9%99%85%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98-%E6%90%AC%E8%BF%90/</url>
    
    <content type="html"><![CDATA[<h1 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h1><p>一张邀请绑定表，一个用户绑定了几十万个记录。<br>索引列为uid-用户的id，create_time-关系的创建时间。<br>查询需求比较简单：<br>根据创建时间倒序，取一页的记录</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> bind <span class="hljs-keyword">where</span> uid = xxx <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> create_time <span class="hljs-keyword">desc</span> <span class="hljs-keyword">limit</span> <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><ol><li><p>第一次查询比较慢，后续查询会变快，原因可能是第一次需要将几十万的数据页加载到Buffer pool，后续可以直接从内存中读取。</p></li><li><p>通过explain发现索引命中了创建时间，而非预期的uid，如果该用户上次绑定是在上个月，那他需要扫描这个所有的新增绑定，才能找到他的那10条数据。这样非常不稳定。</p></li><li><p>如果设置强制走uid索引（force index（id_uid）），explain中extra会显示出现了using file sort，这里是优化器不选择走uid索引的原因。因为即使只查询10条数据，但是需要把几十万条数据查出来以后进行排序。<br>如何影响优化优化器选择哪条索引呢？<br>主要有三种方式：</p><ul><li>force index(index_name)，强制优化器只使用指定的索引，如果该索引无法用于检索数据，MySQL将返回错误。 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> table_name force index(index_name) <span class="hljs-keyword">where</span> <span class="hljs-keyword">condition</span>;<br></code></pre></td></tr></table></figure></li><li>use index(index_name)，告诉查询优化器仅使用列出的索引来查找数据，如果没有列出索引，查询优化器将根据表中的数据选择一个。 <figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-built_in">table_name</span> <span class="hljs-keyword">using</span> <span class="hljs-keyword">index</span>(index_name) <span class="hljs-keyword">where</span> condition;<br></code></pre></td></tr></table></figure></li><li>ignore index(index_name),告诉优化器忽略列出的索引。查询优化器会考虑表中的其他索引，但不会考虑被忽略的那些。 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> table_name ignore index(index_name) <span class="hljs-keyword">where</span> <span class="hljs-keyword">condition</span>;<br></code></pre></td></tr></table></figure>其中force index和using index有什么区别吗？<br>force index列出的索引无法用来查询数据，则报错。<br>using index列出的索引无法用来查询数据时，则忽略这个提示。</li></ul></li><li><p>可以通过将create_time和uid建立联合索引的方式来做，但是生产环境数据比较大，增加这样的索引会增加不少的负担，并且如果想要最新的数据，除了时间，使用id倒序也可以，最后uid，id天然的形成了倒序的效果。</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>MYSQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>唯品会-实习-Java大数据组件开发-二面</title>
    <link href="/2023/09/14/%E5%94%AF%E5%93%81%E4%BC%9A-%E5%AE%9E%E4%B9%A0-Java%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%84%E4%BB%B6%E5%BC%80%E5%8F%91-%E4%BA%8C%E9%9D%A2/"/>
    <url>/2023/09/14/%E5%94%AF%E5%93%81%E4%BC%9A-%E5%AE%9E%E4%B9%A0-Java%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%84%E4%BB%B6%E5%BC%80%E5%8F%91-%E4%BA%8C%E9%9D%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>时间比较长，闲聊居多，会引导并且说错的会纠正，手写阻塞队列确实学到了一些东西</p><p><strong>难度</strong>：⭐⭐⭐☆☆<br><strong>学到的知识</strong>：⭐⭐⭐⭐⭐</p><h1 id="代码题"><a href="#代码题" class="headerlink" title="代码题"></a>代码题</h1><h2 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown">手写一个阻塞队列。<br>满足以下要求：<br><span class="hljs-bullet">1.</span> 有界<br><span class="hljs-bullet">2.</span> 实现读写函数<br><span class="hljs-bullet">3.</span> 使用模板<br><span class="hljs-bullet">4.</span> 考虑多线程并发读取<br></code></pre></td></tr></table></figure><h2 id="代码书写"><a href="#代码书写" class="headerlink" title="代码书写"></a>代码书写</h2><p>先了解一下java中的阻塞队列。<br>java的阻塞队列提供了线程安全的队列实现，其中的阻塞操作主要是为了确保在并发环境中数据安全添加和移除。’java.util.concurrent’包提供了多种阻塞队列的实现，这些阻塞队列在多线程编程，特别是生产者-消费者模型中非常有用。<br>多线程环境中，阻塞队列是一个非常有用的工具，因为他自动处理了大部分线程间同步的问题。<br>以下是主要的阻塞队列：</p><table><thead><tr><th>队列</th><th>介绍</th></tr></thead><tbody><tr><td>ArrayBlockingQueue</td><td>基于数据结构的有界阻塞队列</td></tr><tr><td>LinkedBlockingQueue</td><td>基于链表的可选容量（默认为Integer.MAX_VALUE)的阻塞队列。</td></tr><tr><td>PriorityBlockingQueue</td><td>支持优先级的无界阻塞队列，队列中的元素必须实现Comparable接口</td></tr><tr><td>SynchronousQueue</td><td>不存储元素的阻塞队列，每一个put操作必须等待一个take操作</td></tr><tr><td>DelayQueue</td><td>使用优先队列实现的无界阻塞函数，只有在延迟到期才能从中提取元素</td></tr><tr><td>LinkedTransferQueue</td><td>链表组成的队列，是TransferQueue接口的一个实现，并支持所有操作</td></tr><tr><td>LinkedBlockingDeque</td><td>双向阻塞队列，可以从两端插入或移除元素</td></tr></tbody></table><p>提供的操作</p><table><thead><tr><th>名称</th><th>作用</th></tr></thead><tbody><tr><td>put(e)</td><td>将元素添加到队列末尾，队满则等待</td></tr><tr><td>take()</td><td>从队列前端移除并返回元素，队空则等待</td></tr><tr><td>offer(e,timeout,timeunit)</td><td>尝试将元素添加到队列中，队满则等待指定时间</td></tr><tr><td>poll(timeout,timeunit)</td><td>从队头移并返回头部的元素，如果队列为空则等待指定时间</td></tr></tbody></table><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyBlockingQueue</span>&lt;E&gt; &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>    LinkedList&lt;E&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>(<span class="hljs-literal">true</span>); <span class="hljs-comment">//创建公平锁，来保证等待时间最长的线程获得锁</span><br>    <span class="hljs-type">Condition</span> <span class="hljs-variable">full</span> <span class="hljs-operator">=</span> lock.newCondition();<br>    <span class="hljs-type">Condition</span> <span class="hljs-variable">empty</span> <span class="hljs-operator">=</span> lock.newCondition();<br><br>    MyBlockingQueue(<span class="hljs-type">int</span> capacity) &#123;<br>        <span class="hljs-built_in">this</span>.CAPACITY = capacity;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(E e)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span> (queue.size() == CAPACITY) &#123;<br>                full.await();<br>            &#125;<br>            queue.add(e);<br>            <span class="hljs-keyword">if</span> (queue.size() == <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">//说明之前是0</span><br>                empty.signal();<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">take</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span> (queue.size() == <span class="hljs-number">0</span>) &#123;<br>                empty.await();<br>            &#125;<br>            <span class="hljs-type">E</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> queue.poll();<br>            System.out.println(<span class="hljs-string">&quot;get date:&quot;</span> + e + <span class="hljs-string">&quot; and queue-size:&quot;</span> + queue.size());<br>            <span class="hljs-keyword">if</span> (queue.size() == CAPACITY - <span class="hljs-number">1</span>) &#123;<br>                full.signal();<br>            &#125;<br>            <span class="hljs-keyword">return</span> e;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        MyBlockingQueue&lt;Integer&gt; blockingQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyBlockingQueue</span>&lt;&gt;(<span class="hljs-number">10</span>);<br><br>        <span class="hljs-comment">// 创建5个生产者线程</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">producerNum</span> <span class="hljs-operator">=</span> i;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                        <span class="hljs-type">int</span> <span class="hljs-variable">item</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) (Math.random() * <span class="hljs-number">100</span>);<br>                        blockingQueue.put(item);<br>                        System.out.println(<span class="hljs-string">&quot;Producer &quot;</span> + producerNum + <span class="hljs-string">&quot; put: &quot;</span> + item);<br>                        Thread.sleep(<span class="hljs-number">500</span>);  <span class="hljs-comment">// 模拟生产需要的时间</span><br>                    &#125;<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;).start();<br>        &#125;<br><br>        <span class="hljs-comment">// 创建5个消费者线程</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                        <span class="hljs-type">int</span> <span class="hljs-variable">item</span> <span class="hljs-operator">=</span> blockingQueue.take();<br>                        System.out.println(<span class="hljs-string">&quot;Consumed: &quot;</span> + item);<br>                        Thread.sleep(<span class="hljs-number">1000</span>);  <span class="hljs-comment">// 模拟消费需要的时间</span><br>                    &#125;<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;).start();<br>        &#125;<br><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>如果使用synchronized的关键字，有一个坑是，只有一个线程可以执行任何synchronized代码块。因此，如果一个线程正在执行put方法（它是一个synchronized方法），其他线程不能同时执行put或take方法，它们必须等待直到第一个线程退出synchronized块。即synchronized是对象级别的。当然，可以使用synchronized(someObject)来进行更细粒度的控制。</p><p>前面给出的代码中，因为使用的是同一个lock，实际上也是put和take也是互斥的。</p>]]></content>
    
    
    
    <tags>
      
      <tag>面经</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>美团-秋招-后端开发-一面</title>
    <link href="/2023/09/13/%E7%BE%8E%E5%9B%A2-%E7%A7%8B%E6%8B%9B-%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91-%E4%B8%80%E9%9D%A2/"/>
    <url>/2023/09/13/%E7%BE%8E%E5%9B%A2-%E7%A7%8B%E6%8B%9B-%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91-%E4%B8%80%E9%9D%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h2><ol><li>什么是幻读？写一个insert语句来说明间隙锁加在什么位置？<br>幻读：事务中多次查询，行集不同。<br>如何解决幻读？mvcc+间隙锁<ul><li>当前读：使用select … for update来对所选的行上排他锁。<ul><li>在事务开始使用它，当开始一个事务并打算查询某些可能更新某些行时，首先查询锁定这些行<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql">  <span class="hljs-keyword">START</span> TRANSACTION;<br>  <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> table_name <span class="hljs-keyword">where</span> id <span class="hljs-keyword">BETWEEN</span> <span class="hljs-number">1</span> <span class="hljs-keyword">AND</span> <span class="hljs-number">4</span> <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">UPDATE</span>;<br>  ```  <br><span class="hljs-operator">*</span> 后续查询，同一个事务中再次执行相同的<span class="hljs-keyword">select</span>查询，由于已经锁定了相关行，会看到相同的行集，不会出现幻读。<br><span class="hljs-operator">*</span> 执行更新，该事务的可以安全进行更新，记录锁会锁定<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>，间隙锁会锁定<span class="hljs-number">2</span>，故其他事务执行插入<span class="hljs-number">2</span>会失败。<br>  ```<span class="hljs-keyword">sql</span><br>  <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> table_name (id) <span class="hljs-keyword">VALUES</span>(<span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure></li><li>需要注意：<ul><li>确保事务不会长时间持有锁，以避免可能的死锁或长时间阻止其他事务访问被锁定的数据。</li><li>不能防止其他事务插入数据到查询范围之外。</li></ul></li><li>以上是在有索引的情况，如果没加索引，如何添加间隙锁？<ul><li>通常会做全表扫描，并对整张表做意向锁。<ul><li>意向锁：通知其他事务，有事务打算获取更精细级别的锁，这意味着其他事务如果想在这个表上获得排它锁，会被阻塞。</li><li>记录锁：只有满足条件的行，才会被加上记录锁。</li><li>间隙锁：由于count没有索引，所以无法加上明确的间隙锁。但是由于可能的全表扫描，实际上整个表都可能受到影响，导致新行插入也可能受到限制。如果查询的是具体的记录，不会锁定任何间隙。如果使用范围查询，则可能使用间隙锁。<strong>如果想想用范围查询并执行SELECT…FOR UPDATE操作，最好在涉及的列上加上索引。</strong></li></ul></li></ul></li></ul></li><li>快照读：通过MVCC解决幻读，在可重复读隔离级别下，事务在执行过程中看到的数据实际上是不变的。<ul><li>mvcc在事务开始后，执行第一个查询语句，会创建read view，后续的查询语句利用这个read view+undo log版本链找到事务开始时的数据，以保证在事务中每次查询的数据都一样。</li><li>MVCC已经这么好了，为什么还需要间隙锁？<ul><li>虽然事务B插入行，事务A不会出现幻读，但是事务A如果要在这个范围内插入数据，会和事务B的插入发生冲突。</li></ul></li></ul></li></ul></li></ol><p>MVCC+间隙锁就可以解决幻读了吗？<br>结论：很大程度上可以，但是没有完全解决。<br>场景一：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- T1时刻：仅有id 1-4的记录，事务A查询id=5，查询不到</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> t_stu <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">5</span>；<br><span class="hljs-comment">-- T2时刻：事务B插入id=5的记录</span><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_stu <span class="hljs-keyword">values</span>(<span class="hljs-number">5</span>,<span class="hljs-string">&#x27;qxy&#x27;</span>)；<br><span class="hljs-comment">-- T3时刻：事务A更新了id=5的记录，很违和</span><br><span class="hljs-keyword">update</span> t_stu <span class="hljs-keyword">set</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;qxy1&#x27;</span> <span class="hljs-keyword">where</span> id<span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br><span class="hljs-comment">-- T4时刻：事务A查询id=5，可以查询到</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> t_stu <span class="hljs-keyword">where</span> id<span class="hljs-operator">=</span> <span class="hljs-number">5</span>；<br></code></pre></td></tr></table></figure><p>场景二：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- T1时刻：事务A执行快照读，读出3条记录</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> t_test <span class="hljs-keyword">where</span> id <span class="hljs-operator">&gt;</span> <span class="hljs-number">100</span>;<br><span class="hljs-comment">-- T2时刻：事务B插入id=200的记录</span><br><span class="hljs-comment">-- T3时刻：事务A再执行当前读，会得到4条记录</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> t_test <span class="hljs-keyword">where</span> id <span class="hljs-operator">&gt;</span> <span class="hljs-number">100</span> <span class="hljs-keyword">for</span> <span class="hljs-keyword">update</span>;<br></code></pre></td></tr></table></figure><p>想要避免这类特殊场景下发生幻读，就要尽量在开启事务之后，尽快执行select…for update语句，目的就是为了避免T2时刻数据的插入。<br>2. 高并发写数据库的情况？</p><p>抛出去的剑又回来了，是不是间隙锁会导致高并发读写的出现性能问题？<br>参考腾讯一面-有遇到过因为隔离级别导致的问题啊？</p><h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><ol><li><p>jvm内存结构</p></li><li><p>OOM出现的情况<br>分不同的区域来讨论：</p><table><thead><tr><th>分类</th><th>描述</th><th>常见原因</th></tr></thead><tbody><tr><td>堆</td><td>应用程序创建太多对象，其长时间不被GC回收。</td><td>内存泄露、创建了大量的大对象、长久时间持有大量对象的引用</td></tr><tr><td>永久代-&gt;元空间（java 8）</td><td>为方法区提供物理内存，主要存放类的数据。直接在主机内存分配，不在java堆，但是受到本机可用内存的限制</td><td>大量类加载；元空间大小设置过小，通过指定-XX：MaxMetaspaceSize来调整；类加载泄露：频繁重新加载类或大量的动态代理生成；优化应用程序和库，减少应用程序加载的类和资源数量；升级或更改JVM</td></tr><tr><td>本地方法栈，java线程栈</td><td>过多的方法调用，超出栈的大小限制，可能会stackoverflow，也可能会oom。</td><td>创建太多线程，jvm无法为新的线程分配必要的内存</td></tr><tr><td>直接内存溢出</td><td>ByteBuffer.allocateDirect()分配内存是在java堆外，但是JVM进程的最大内存限制的约束</td><td></td></tr><tr><td>GC Overhead Limit Exceeded</td><td>特定的OOM错误，表示GC频繁运行但回收内存很少</td><td>长时间大量的小对象对创建和丢弃，导致GC频繁</td></tr></tbody></table></li></ol><p>java中什么情况下会使用直接内存？<br>使用ByteBuffer.allocateDirect()方法分配的内存，位于java堆之外，直接内存常用于IO操作，特别是NIO中，因为他可以减少java堆和本地IO操作之间复制数据的开销。<br>虽然直接内存位于Java对之外，但仍受到进程最大内存限制的约束，如果尝试分配超过限制的直接内存，则会报OOM。可以通过调整JVM的-XX：MaxDirectMemorySize来设置直接内存的最大值。</p><p>JVM参数中可以指定哪些区域的大小？<br>java堆、元空间、直接内存。但是仍然受到操作系统对进程总体内存的限制。<br>所以进程不论超出jvm限制，或者是超出操作系统的限制，都会造成OOM。</p><h2 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h2><ol><li>项目中redis部署的方式</li><li>redis为什么快</li><li>redis有哪些数据结构？讲下zset的底层结构？</li><li>redis和数据库不一致的情况？</li></ol><h2 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h2><ol><li>服务响应很慢，如何排查？如何定位到代码？<br>这个问题属实高频题，主要要理清思路。可以和排查数据库查询慢对比。<br>可以导致响应慢的原因：</li></ol><ul><li>数据库或外部依赖（远程服务，api调用，缓存服务器）</li><li>网络问题</li><li>系统资源</li><li>并发和线程管理</li><li>第三方框架导致的问题</li></ul><p>主要的排除步骤 –如果是django程序怎么检查，为什么我们的django程序没有遇到GC问题</p><ul><li>事件定性：确认报告的慢响应问题。验证是否所有用户和请求都受到了影响，还是只是某些特定场景。对比历史数据，确定是持续存在的问题还是突发事件。</li><li>监控和日志审查：看监控面板或使用top命令，查看是否有高的CPU使用、内存耗尽或异常垃圾收集行为。查阅应用日志，找出异常、错误或者其他可以信息。如果有，查看垃圾收集日志，检查频繁或长时间的GC事件。</li><li>检查网络和外部服务：ping、traceroute看网络延迟；检查与外部服务和数据库的交互，确保响应正常</li><li>应用性能分析：使用jvisualVM，jConsole去看jvm的性能指标，分析线程转储，看是否有阻塞、死锁或其他线程相关问题。</li><li>数据库查询：如果应用依赖于数据库，看数据库的慢查询日志。</li><li>代码：回顾最近的代码更改 以及 查看配置文件或环境设置，有无不合理的限制或配置。</li><li>重现问题：在测试环境中尝试重现。</li><li>使用APM工具找出瓶颈和性能下降的具体位置</li><li>检查硬件和资源：看是否有硬盘故障或RAM故障，查看其他与应用相关的系统资源，如磁盘IO、网络带宽。</li><li>系统级检查：查看操作系统日志</li></ul><h2 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h2><ol><li>项目难点？</li></ol><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ol><li>为什么选择这家公司？</li><li>为什么不找暑期实习？</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>阿里国际-0911-笔试</title>
    <link href="/2023/09/12/%E9%98%BF%E9%87%8C%E5%9B%BD%E9%99%85-0911-%E7%AC%94%E8%AF%95/"/>
    <url>/2023/09/12/%E9%98%BF%E9%87%8C%E5%9B%BD%E9%99%85-0911-%E7%AC%94%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h2 id="题目要求："><a href="#题目要求：" class="headerlink" title="题目要求："></a>题目要求：</h2><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs excel">小红喜欢看电影，对不同的电影有不同的期待值。<br>每天上映一部电影，随着上映时间的增加，小红的期待会减少。<br>小红只在奇数天看电影，且不会重复看同一个电影，求<span class="hljs-built_in">n</span>天内看电影能获得的最大期待。<br></code></pre></td></tr></table></figure><h2 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h2><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">6 </span><span class="hljs-number">1</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">4</span> <span class="hljs-number">9</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><h2 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h2><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">13 </span>  <br></code></pre></td></tr></table></figure><h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs subunit">总共6天，期待值每过1天降低1.<br>小红可以在1 3 5天看电影。<br>第一天：期待值最大的电影值为1.<br>第三天：电影的期待分别为1,4,期待值最大为4<br>第五天：电影的期待分别为<span class="hljs-string">-1</span>,8,4,期待值最大为8<br>故结果为 1<span class="hljs-string">+4</span><span class="hljs-string">+8</span>=13<br></code></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>堆问题</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> heapq<br><br>n, d = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>arr = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split()))<br><br><span class="hljs-comment"># 利用堆：满足每次需要取出最值，并剔除</span><br><span class="hljs-comment"># 需要的是最大堆，python仅最小堆，故对元素取反</span><br>res = <span class="hljs-number">0</span><br>heap = []<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>    <span class="hljs-keyword">if</span> i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>:  <span class="hljs-comment"># 说是奇数天，其实是偶数</span><br>        <span class="hljs-comment"># 只是保持相对关系，实际的期望之后再求</span><br>        expect, idx = heapq.heappushpop(heap, (-arr[i] - d * i, i))  <span class="hljs-comment"># 不想回头，所以每过一天分量+d，一定是递增，不然那每一天都加个d还有啥用</span><br>        res += -expect - i * d  <span class="hljs-comment"># res += - (expect + (d * idx)) - (i - idx) * d  先把多删的不上，再把期望按经过的时间衰退</span><br>    <span class="hljs-keyword">else</span>:  <span class="hljs-comment"># 偶数天也要放进来，只是不输出就行</span><br>        heapq.heappush(heap, (-arr[i] - d * i, i))<br><br><span class="hljs-built_in">print</span>(res)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>笔试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>拼多多-0910-笔试</title>
    <link href="/2023/09/10/%E6%8B%BC%E5%A4%9A%E5%A4%9A-0910-%E7%AC%94%E8%AF%95/"/>
    <url>/2023/09/10/%E6%8B%BC%E5%A4%9A%E5%A4%9A-0910-%E7%AC%94%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h2 id="题目要求："><a href="#题目要求：" class="headerlink" title="题目要求："></a>题目要求：</h2><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">小明需要在m分钟内修或更换<span class="hljs-built_in">n</span>个零件，会给出每个零件修的耗时ai、修的价格bi、更换的耗时ci、更换的价格di。<br>请计算在m分钟能否修复（修或更换均可）<span class="hljs-built_in">n</span>个零件，如何可以，输出最小的成本<br></code></pre></td></tr></table></figure><h2 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h2><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">3 </span><span class="hljs-number">18</span>        # n个零件， 时间上限为m<br><span class="hljs-symbol">9 </span><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">11</span>    # 第一个零件的 修耗时，修成本，更换耗时，更换成本<br><span class="hljs-symbol">8 </span><span class="hljs-number">4</span> <span class="hljs-number">3</span> <span class="hljs-number">10</span>    # 第二个零件 ...<br><span class="hljs-symbol">10 </span><span class="hljs-number">6</span> <span class="hljs-number">5</span> <span class="hljs-number">12</span>   # 第三个零件 ...<br></code></pre></td></tr></table></figure><h2 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h2><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">23 </span>         # 价格<br></code></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>背包问题</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 处理输入</span><br>n, m = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>parts = []<br><span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>    a, b, c, d = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>    parts.append((a, b, c, d))<br><br>min_time = <span class="hljs-built_in">sum</span>(x[<span class="hljs-number">2</span>] <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> parts)<br><span class="hljs-keyword">if</span> min_time &gt; m:  <span class="hljs-comment"># 如果全换不修是否能满足要求</span><br>    <span class="hljs-built_in">print</span>(-<span class="hljs-number">1</span>)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-comment"># 转换成0-1背包问题,挑选从换-&gt;修的零件,尽可能多的选取价格降低最多的方式</span><br>    bag_weight = m - min_time  <span class="hljs-comment"># 最多可以更换weight的重量</span><br>    weights = [x[<span class="hljs-number">0</span>] - x[<span class="hljs-number">2</span>] <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> parts]<br>    values = [x[<span class="hljs-number">3</span>] - x[<span class="hljs-number">1</span>] <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> parts]<br>    <span class="hljs-comment"># dp[i][j] 在可选范围为前i个,背包容量为j</span><br>    dp = [[<span class="hljs-number">0</span>] * (bag_weight + <span class="hljs-number">1</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n + <span class="hljs-number">1</span>)]<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n + <span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(bag_weight + <span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">if</span> i * j == <span class="hljs-number">0</span>:<br>                dp[i][j] = <span class="hljs-number">0</span><br>                <span class="hljs-keyword">continue</span><br>            <span class="hljs-keyword">if</span> j - weights[i - <span class="hljs-number">1</span>] &lt; <span class="hljs-number">0</span>:  <span class="hljs-comment"># 没法选</span><br>                dp[i][j] = dp[i - <span class="hljs-number">1</span>][j]<br>            <span class="hljs-keyword">else</span>:<br>                dp[i][j] = <span class="hljs-built_in">max</span>(<br>                    dp[i - <span class="hljs-number">1</span>][j],  <span class="hljs-comment"># 不选</span><br>                    dp[i - <span class="hljs-number">1</span>][j - weights[i - <span class="hljs-number">1</span>]] + values[i - <span class="hljs-number">1</span>]  <span class="hljs-comment"># 选</span><br>                )<br>    res = <span class="hljs-built_in">sum</span>(x[<span class="hljs-number">3</span>] <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> parts) - dp[n][bag_weight]<br>    <span class="hljs-built_in">print</span>(res)<br></code></pre></td></tr></table></figure><p>申请了一个二维的dp数组，空间复杂度为O(m*n),无法通过测试用例。其实不是m，不过也是一个时间，比m小，对应代码中的m-min_time。<br>dp[i][j]只依赖于dp[i-1][*],所以可以使用滚动数据，将空间复杂度降为O(2*m)。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 仅展示修改部分</span><br>dp = [[<span class="hljs-number">0</span>] * (bag_weight + <span class="hljs-number">1</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>)] <br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n + <span class="hljs-number">1</span>):<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(bag_weight + <span class="hljs-number">1</span>):<br>        now, pre = i % <span class="hljs-number">2</span>, (i - <span class="hljs-number">1</span>) % <span class="hljs-number">2</span><br>        <span class="hljs-keyword">if</span> i * j == <span class="hljs-number">0</span>:<br>            dp[now][j] = <span class="hljs-number">0</span><br>            <span class="hljs-keyword">continue</span><br>        <span class="hljs-keyword">if</span> j - weights[i - <span class="hljs-number">1</span>] &lt; <span class="hljs-number">0</span>:  <span class="hljs-comment"># 没法选</span><br>            dp[now][j] = dp[pre][j]<br>        <span class="hljs-keyword">else</span>:<br>            dp[now][j] = <span class="hljs-built_in">max</span>(<br>                dp[pre][j],  <span class="hljs-comment"># 不选</span><br>                dp[pre][j - weights[i - <span class="hljs-number">1</span>]] + values[i - <span class="hljs-number">1</span>]  <span class="hljs-comment"># 选</span><br>            )<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>笔试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>J.U.C</title>
    <link href="/2023/09/10/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <url>/2023/09/10/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<blockquote><p>先依葫芦画瓢，再深入理解<br>[TOC]</p></blockquote><h1 id="1-什么是协程？"><a href="#1-什么是协程？" class="headerlink" title="1. 什么是协程？"></a>1. 什么是协程？</h1><h1 id="2-什么是超线程？"><a href="#2-什么是超线程？" class="headerlink" title="2. 什么是超线程？"></a>2. 什么是超线程？</h1><h1 id="3-如何设置合理的线程数？"><a href="#3-如何设置合理的线程数？" class="headerlink" title="3. 如何设置合理的线程数？"></a>3. 如何设置合理的线程数？</h1><p>目标是：最大化利用CPU的情况下，减少线程切换的开销</p><ul><li>高并发，低耗时，建议少线程</li><li>低并发，高耗时，建议多线程</li><li>高并发，高耗时，分析任务类型，增加排队，加大线程数</li></ul><h1 id="4-什么是匿名类？什么是函数式接口？"><a href="#4-什么是匿名类？什么是函数式接口？" class="headerlink" title="4. 什么是匿名类？什么是函数式接口？"></a>4. 什么是匿名类？什么是函数式接口？</h1><h1 id="5-run-和start"><a href="#5-run-和start" class="headerlink" title="5. run()和start()"></a>5. run()和start()</h1><p>run方法是同步方法，由主线程执行，并未开启新线程。<br>run可以无限执行，start只能执行一次（illegalThreadStateException）。</p><p>还有getName，setName，sleep，interrupt，yield，getPriority（1-10，默认是5），setPriority等方法。<br>sleep(0)先进入阻塞态（不过因为是0ms，所以直接进就绪态），yield进入就绪态。<br>yield之后，优先级更高的线程更有可能获得cpu时间片。yield根据jvm和操作系统不同，行为可能不同。<br>interrupt方法只是通知线程需要中断，做了个标记，并不会立刻中断。<br>public static boolean interrupted() 判断是否中断，并清除标记。<br>public boolean isInterrupted() 判断是否被中断，不清楚标记。<br>sleep过程如果使用interrupt，会抛出InterruptedException异常，捕获该异常会清除标记，需要在catch中再次使用interrupt来标记。<br>join：主线程等待子线程完成<br>setDaemon：设置守护进程，只要所有用户线程退出后，守护进程<strong>立马</strong>结束，不论执行到哪。<br>应用：垃圾回收器；tomcat用来接收外部请求的线程。<br>isDaemon<br>getState：new，runnable，waiting（sleep，join，wait），timed_waiting（带计时的sleep，join，wait），blocked（锁相关），terminated</p><h1 id="6-线程的创建方式"><a href="#6-线程的创建方式" class="headerlink" title="6. 线程的创建方式"></a>6. 线程的创建方式</h1><ol><li>实现Runnable接口的run方法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Runnable方式运行&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">MyRunnable</span> <span class="hljs-variable">myRunnable</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyRunnable</span>();<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(myRunnable);<br>        thread1.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>继承Thread类并重新run方法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//受限于java的单继承，如果继承了Thread类，无法继承其他类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Thread方式运行&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>().start();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></li><li>使用FutureTask方法（实现Callable接口）<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCallable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Callable</span>&lt;String&gt; &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Callable接口方式运行&quot;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        FutureTask&lt;String&gt; futureTask = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyCallable</span>());<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(futureTask);<br>        thread.start();<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> futureTask.get();<br>            System.out.println(result);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">catch</span> (ExecutionException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h1 id="7-线程池的作用"><a href="#7-线程池的作用" class="headerlink" title="7. 线程池的作用"></a>7. 线程池的作用</h1><p>容纳多个线程的容器，其中的线程可以反复使用，省去了频繁创建线程对象的操作，无需反复创建线程而消耗过多的资源。<br>主要优势：</p><ul><li>降低资源消耗：防止了反复创建销毁</li><li>提高响应速度：任务不需要等待线程创建</li><li>提高线程的可管理性：防止无限制创建</li></ul><h2 id="为什么要在finally里关闭线程池？"><a href="#为什么要在finally里关闭线程池？" class="headerlink" title="为什么要在finally里关闭线程池？"></a>为什么要在finally里关闭线程池？</h2><p>占用系统资源，内存泄露，主线程不会退出。</p><p>threadPool.shutdown();等待正在执行的，以及阻塞队列中任务执行完。<br>threadPool.shutdownNow();等正在执行的任务后即关闭线程。<br>这两种方式使用interrupt，给是给个中断标志，并不会决定线程关闭，由线程内部自己处理。<br>两者的区别只是看是否依据阻塞队列是否为空。</p><p>threadPool.isTerminated();可以用于判断线程池是否真正停止了。</p><h2 id="execute-方法和submit-有什么区别？"><a href="#execute-方法和submit-有什么区别？" class="headerlink" title="execute()方法和submit()有什么区别？"></a>execute()方法和submit()有什么区别？</h2><ol><li>参数<br>execute只接收runnable，submit指出runnable,callable，可以直接返回FutureTask对象。</li><li>异常<br>execute会在子线程中抛出异常，主线程捕捉不到。submit不会立刻抛出异常，而是将异常暂时存起来，等调用Future.get()方法才会抛出，并且可以在主线程中捕捉到。</li></ol><h2 id="线程池的创建顺序"><a href="#线程池的创建顺序" class="headerlink" title="线程池的创建顺序"></a>线程池的创建顺序</h2><p>实际的执行顺序，并不一致，比如阻塞队列中的任务和最大线程数量创建线程所执行的任务。</p><pre><code class=" mermaid">graph TDA[判断核心线程数量是否已满]A --&gt;|是| B[判断阻塞队列是否已满]A --&gt;|否| C[创建线程执行任务]B --&gt;|否| D[加入阻塞队列]B --&gt;|是| E[判断最大线程数量是否已满]E --&gt;|是| F[执行拒绝策略]E --&gt;|否| G[创建线程]</code></pre><p>线程依赖阻塞队列来保活。</p><p>？什么是阻塞队列，什么是非阻塞队列？</p><p>拒绝策略</p><ol><li>抛异常-默认</li><li>调用者线程自己去执行，相当于反馈机制，减缓新任务的提交速度</li><li>抛弃最老的任务-阻塞队列中</li><li>直接静默抛弃</li></ol><p>可以实现RejectedExecutionHandler接口，自定义拒绝策略。</p><p>线程淘汰策略</p><ol><li>正常退出<br>假设m个线程，核心线程数为n，其中m&gt;n,阻塞队列无任务，需要淘汰m-n个线程。<br>淘汰通过getTask方法，当getTask为null时对应的线程消失，当上述场景不满足时，阻塞队列实际上一直调用的是take方法，进行无限阻塞，而满足时会进行poll超时阻塞。<br>m个线程需要通过CAS去竞争，竞争成功的m-n个线程会执行poll()方法，超时后，getTask返回null，剩余的n个线程则在没有新任务时无限阻塞。<br>核心线程和临时线程本质上没区别，看最后保留了哪些，哪些就是核心线程。<br>所以线程池参数的超时时间，就是用来设置poll方法超时阻塞的时间。</li><li>异常退出<br>线程抛异常退出后，线程池会addWork()创建一个新的线程。<br>为什么不捕获异常，直接让线程执行下一个任务呢？<br>为了统一的异常处理器setUncaughtExceptionHandler，所以需要抛出异常，异常抛出后，线程异常退出。</li></ol><h2 id="tomcat中的线程池"><a href="#tomcat中的线程池" class="headerlink" title="tomcat中的线程池"></a>tomcat中的线程池</h2><p>JUC的线程池构造方法本身并不创建线程，只是创建一个线程工厂。而tomcat中线程池的构造方法有一个preStartAllCoreThread()方法，用于提前创建所有的核心线程。</p><h1 id="8-线程安全问题"><a href="#8-线程安全问题" class="headerlink" title="8. 线程安全问题"></a>8. 线程安全问题</h1><p>线程并发对共享数据进行读写，造成数据混乱。<br>线程安全的三特性：</p><ul><li>原子性<ul><li>synchronized</li><li>atomic</li></ul></li><li>可见性<ul><li>synchronized</li><li>voliate</li></ul></li><li>有序性</li></ul><h2 id="9-JMM"><a href="#9-JMM" class="headerlink" title="9. JMM"></a>9. JMM</h2><p>JAVA多线程内存模型。<br>多线程对共享变量操作实际上是操作每个线程工作内存中的副本。</p><p>缓存一致性协议（MESI）<br>多个CPU从主内存读取同一个数据到各自的高速缓存，当其中某个cpu修改了缓存里的数据，该数据会马上同步回主内存，其他cpu通过总线嗅探机制可以感知到数据的变化从而将自己的缓存里的数据失效。</p><p>volatile是如何使缓存一致的？<br>volatile底层主要是通过汇编lock前缀指令，他会锁定这块内存区域的缓存（缓存行锁定），并写回到主内存。<br>而intel 64架构中lock指令会执行以下操作：<br>    1. 立即将当前缓存行中的数据写回系统内存<br>    2. 写回操作会引起其他CPU里缓存该内存地址的数据无效（MESI协议）<br>    3. 提供内存屏障，使得lock前后指令不能重排序。</p><p>指令重排序：在不影响单线程程序执行结果的前提下，计算机为了最大限度发挥机器性能，会对机器指令重排序优化。</p><pre><code class=" mermaid">graph LRA[源代码]B[编译器优化重排序]C[指令级优化重排序]D[内存系统重排序]E[最终执行指令序列]A --&gt;BB --&gt;CC --&gt;DD --&gt;E</code></pre><p>bilibili在使用vpn时，视频会播放不了</p><p>对象的创建流程</p><pre><code class=" mermaid">graph LRA[开始]B[类加载检查]C[已经加载]D[分配内存]E[未加载]F[加载类]G[初始化零值]H[设置对象头]I[执行init方法]J[结束]A --&gt; BB --&gt; |已经加载| CB --&gt; |未加载| EC --&gt; DE --&gt; F --&gt; DD --&gt; GG --&gt; HH --&gt; II --&gt; J</code></pre><p>内存屏障<br>如果在两行代码中加上内存屏障，则底层不会对其进行重排序。</p><h2 id="10-锁"><a href="#10-锁" class="headerlink" title="10. 锁"></a>10. 锁</h2><h3 id="1-乐观锁-悲观锁"><a href="#1-乐观锁-悲观锁" class="headerlink" title="1. 乐观锁&amp;&amp;悲观锁"></a>1. 乐观锁&amp;&amp;悲观锁</h3><p>锁的类型，并非具体的实现。</p><table><thead><tr><th>类型</th><th>描述</th><th>缺点</th><th>实现</th></tr></thead><tbody><tr><td>悲观锁</td><td>一种同步机制，假设多个事务在并发执行会发生冲突，因此事务开始时就预先获取所需的锁，确保在事务执行期间，其他事务不能访问被锁定的数据，适合于并发量大，写操作多的情况</td><td>降低并发度</td><td>synchronized，lock</td></tr><tr><td>乐观锁</td><td>认为在使用数据时不会有别的线程修改数据，所以不加锁，只是在更新数据的时候去判断之前是否有线程更新了数据。</td><td>循环时间长时开销很大；ABA问题(加标记，加版本号)</td><td>CAS</td></tr></tbody></table><p>自旋锁&amp;&amp;互斥锁</p><ul><li>自旋锁：<ul><li>借鉴CAS思想，指当一个线程在获取锁时，如果锁已经被其他线程获取，那么线程将循环等待，不断判断锁是否能被成功获取，直到获取锁才会退出循环。</li><li>与互斥锁相似，都是为了解决对某项资源的互斥使用。</li><li>但是互斥锁会让没得到锁资源的线程进入blocked状态，而后在争夺到锁资源后恢复runnable状态，这期中涉及到用户态和内核态的转换，代价较高。</li><li>自旋锁不会引起调用者阻塞，如果自旋锁已经被别的执行单元保持，调用者就一直循环在那里看该自旋锁的保持者是否已经释放了锁。</li><li>不适合锁占用时间比较久的情况。</li></ul></li></ul><h2 id="2-synchronized锁升级"><a href="#2-synchronized锁升级" class="headerlink" title="2. synchronized锁升级"></a>2. synchronized锁升级</h2><p>JDK 1.6之前，java内置锁是重量级锁,效率低下，需要由jvm用户态切换到操作系统管程来实现互斥。<br>自旋锁一直在用户态，无需切换。</p><p><strong>管程（Monitor）</strong><br>监视器，用于管理共享变量以及对共享变量操作的过程，让他们支持并发，操作系统中称为管程，java中称为对象锁。</p><p><strong>锁升级的目的</strong><br>为了提高锁的获取与释放效率，对synchronized实现进行了优化，锁的级别随着<br>竞争情况逐渐升级，而且不可降级。</p><p><strong>级别（从低到高）</strong><br>无锁-&gt;偏向锁（线程本身再次请求锁）-&gt;轻量级锁（不同线程交替请求锁，自旋）-&gt;重量级锁。</p><h2 id="3-synchronized-ReentrantLock"><a href="#3-synchronized-ReentrantLock" class="headerlink" title="3. synchronized&amp;&amp;ReentrantLock"></a>3. synchronized&amp;&amp;ReentrantLock</h2><ul><li>ReentrantLock需手工加锁和解锁，但是粒度和使用更灵活。</li><li>synchronized是java内置关键字，由c++实现，lock是java类。</li><li>ReentrantLock可以判断是否获取到了锁。 </li><li>ReentrantLock提供锁申请等待限时。<ul><li>lock1.tryLock();</li><li>lock1.tryLock(2, TimeUnit.SECONDS);</li></ul></li><li>ReetrantLock获取锁的过程是可以被打断的。</li></ul><p>总结：<br>synchronized：可重入、不可中断、非公平<br>lock：可重入、可中断、可公平</p><h2 id="4-公平锁和非公平锁"><a href="#4-公平锁和非公平锁" class="headerlink" title="4. 公平锁和非公平锁"></a>4. 公平锁和非公平锁</h2><p>大部分情况下，锁的申请都是非公平的。<br>synchronized是非公平锁，ReentrantLock有公平和非公平模式。<br>非公平锁更能充分的利用CPU时间片，减少CPU空闲状态时间；减少线程切换的开销（刚释放锁的线程再次获取同步状态的概率非常大）。但可能导致锁饥饿。<br>非公平锁能够带来更高额吞吐量。</p><h2 id="5-共享锁和排它锁"><a href="#5-共享锁和排它锁" class="headerlink" title="5. 共享锁和排它锁"></a>5. 共享锁和排它锁</h2><p>多个读进程并没有线程并没有线程安全问题。<br>所以引入了共享锁（读锁）和排它锁（写锁）。<br>读锁：多个读线程共享，阻塞写线程。<br>写锁：写线程独享。</p>]]></content>
    
    
    
    <tags>
      
      <tag>JAVA</tag>
      
      <tag>并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>阿里国际-秋招-java开发-一面/简历面</title>
    <link href="/2023/09/09/%E9%98%BF%E9%87%8C%E5%9B%BD%E9%99%85-%E7%A7%8B%E6%8B%9B-java%E5%BC%80%E5%8F%91-%E4%B8%80%E9%9D%A2-%E7%AE%80%E5%8E%86%E9%9D%A2/"/>
    <url>/2023/09/09/%E9%98%BF%E9%87%8C%E5%9B%BD%E9%99%85-%E7%A7%8B%E6%8B%9B-java%E5%BC%80%E5%8F%91-%E4%B8%80%E9%9D%A2-%E7%AE%80%E5%8E%86%E9%9D%A2/</url>
    
    <content type="html"><![CDATA[<blockquote><p>总评：java基础知识回答不好；介绍平时在读的书，最喜欢的课程这类题目，可以提前准备下。</p></blockquote><h2 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h2><h3 id="1-介绍下切面编程？"><a href="#1-介绍下切面编程？" class="headerlink" title="1. 介绍下切面编程？"></a>1. 介绍下切面编程？</h3><ul><li>将程序中的横切关注点（比如日志、事务管理、安全）与主业务分离开，开发者可以独立开发主业务逻辑，而不必关系与主业务逻辑不直接相关的代码。</li><li>代码重用</li><li>提高可维护性</li><li>灵活性：轻松的添加或删除切面，不影响主业务逻辑</li></ul><p>总结：更关注主业务逻辑，将业务不相关代码模块化，并与主业务分离，提高了代码的可重用性和可维护性。<br>场景:日志、事务、权限检查、性能监控、异常处理</p><h3 id="2-介绍下JAVA的内存管理？"><a href="#2-介绍下JAVA的内存管理？" class="headerlink" title="2. 介绍下JAVA的内存管理？"></a>2. 介绍下JAVA的内存管理？</h3><ol><li>内存分区</li></ol><table><thead><tr><th>名称</th><th>作用</th><th>特性</th></tr></thead><tbody><tr><td>堆</td><td>存放对象实例</td><td>线程共享；需要GC</td></tr><tr><td>方法区</td><td>存放类信息，静态代码段，静态变量，jit即时编译产生的代码段</td><td>线程共享</td></tr><tr><td>线程栈</td><td>存放局部变量和引用变量</td><td>线程私有</td></tr><tr><td>本地方法栈</td><td>服务于本地方法调用</td><td>线程私有</td></tr><tr><td>程序计数器</td><td>记录字节码运行的位置</td><td>线程私有</td></tr></tbody></table><ol start="2"><li>垃圾回收<br>依赖GC来回收不再引用的对象。<br>如何区分对象是否被应用：引用计数和可达性分析<br>常见垃圾回收算法<ul><li>标记-清除：会导致碎片化</li><li>复制：空间折半</li><li>标记-整理：移动开销大<br>常见的垃圾回收器</li><li>serial collector:特点是Stop the word，且单线程</li><li>parallel Collector：stop the world，但是多线程</li><li>CMS：为解决stw问题，但是未完全解决</li><li>G1：改进CMS</li></ul></li><li>对象分配<br>对象首先在新生代，特别是eden，eden满了进行young gc。<br>存活时间长的对象，进入老年代，老年代满了进行full gc。<br>防止了频繁移动长生命周期的对象带来的开销。</li><li>内存泄露<br>现象：不再使用的对象却不被回收。<br>原因：长生命周期对象持有短生命周期对象的引用。<br>例子：<ul><li>static修饰的集合类</li><li>未显式close的数据库连接、网络和io操作</li><li>集合中的对象属性修改后无法被remove</li><li>释放对象时未删除监听器</li><li>内部类</li><li>单例对象持有外部引用（单例对象以静态变量形式存在）</li></ul></li></ol><h3 id="3-JAVA类加载的过程？双亲委派机制？"><a href="#3-JAVA类加载的过程？双亲委派机制？" class="headerlink" title="3. JAVA类加载的过程？双亲委派机制？"></a>3. JAVA类加载的过程？双亲委派机制？</h3><p>当一个类加载器收到类加载请求，不会自己去加载，而是委派给父类加载器。<br>如果父类加载器无法完成加载（所请求的类不在其搜索路径下），子加载器尝试自己去加载。<br>是一个递归的过程。</p><p>加载器自顶向下分别为：</p><ol><li>Bootstrap classloader：加载jre核心库，如java.lang</li><li>Extention ClassLoader：加载jre&#x2F;lib&#x2F;ext或系统变量java.ext.dirs执行位置的类库</li><li>Application ClassLoader：加载用户路径（classpath）上指定的类库。</li><li>自定义类加载器：开发者通过集成java.lang.ClassLoader来创建自己的类加载器</li></ol><p><strong>扩展1：需要打破双亲委派机制的场景?</strong><br><strong>扩展2：如何打破双亲委派机制？</strong></p><h3 id="4-介绍下红黑树"><a href="#4-介绍下红黑树" class="headerlink" title="4. 介绍下红黑树"></a>4. 介绍下红黑树</h3><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><h3 id="1-键入url到页面渲染的过程？-高频题"><a href="#1-键入url到页面渲染的过程？-高频题" class="headerlink" title="1. 键入url到页面渲染的过程？(高频题)"></a>1. 键入url到页面渲染的过程？(高频题)</h3><ol><li>从url中提取域名和静态资源</li><li>通过DNS服务器，将域名转换为IP地址，过程是：浏览器缓存-&gt;查hosts-&gt;本地DNS服务器缓存-&gt;询问根域名服务器，获得顶级域名服务器-&gt;询问顶级域名服务器，获得权威域名服务器-&gt;询问权威域名服务器，获得IP.</li><li>得到IP以后，调用socket方法，通过tcp或udp进行传递，tcp使用IP协议栈进行传递，其中IP负责在不同网络中路由，ARP将IP翻译为MAC地址，在目标局域网中找到目标主机。</li><li>找到目标主机原路返还。</li></ol><h3 id="2-介绍下TCP滑动窗口"><a href="#2-介绍下TCP滑动窗口" class="headerlink" title="2. 介绍下TCP滑动窗口"></a>2. 介绍下TCP滑动窗口</h3><p>流量控制的核心机制。<br>发送方的窗口由接收方窗口和网络拥塞情况动态调整。<br>发送方发送一些数据并得到确认，会向前滑动，从而可以发送更多的数据。相应的，接收方接收了数据并发送相应的确认后，接收窗口也向前滑动。<br>如果接收方缓冲区被填满，会设置窗口发小为0来告知发送方停止发数据。<br>当网络拥塞时，发送方也会减少其窗口，来减少发送数据量，在网络条件改善后，在逐步增加。如快恢复和快重传。</p><p>重传机制：超时重传-&gt;快重传-&gt;SACK<br><strong>扩展1：假设接收方窗口为10，接收到的序列是1,3,4,5,2,6，会怎么样？</strong><br>接收到seq&#x3D;1，会发送ack&#x3D;2<br>接收到3,4,5，会继续发送ack&#x3D;2，且将3,4,5放入缓冲区<br>接收到2，从缓存区中取出3,4,5，并按照正确的顺序传递给上层应用，发送ack&#x3D;6，<br>接收6，发送ack&#x3D;7<br>保证了即使在数据包乱序的情况，也能确保数据按正确的顺序被上层应用接收。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="1-介绍下最近在读的书，以及给你的启发？"><a href="#1-介绍下最近在读的书，以及给你的启发？" class="headerlink" title="1. 介绍下最近在读的书，以及给你的启发？"></a>1. 介绍下最近在读的书，以及给你的启发？</h3>]]></content>
    
    
    
    <tags>
      
      <tag>面经</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>得物-秋招-java开发-一面</title>
    <link href="/2023/09/09/%E5%BE%97%E7%89%A9-%E7%A7%8B%E6%8B%9B-java%E5%BC%80%E5%8F%91-%E4%B8%80%E9%9D%A2/"/>
    <url>/2023/09/09/%E5%BE%97%E7%89%A9-%E7%A7%8B%E6%8B%9B-java%E5%BC%80%E5%8F%91-%E4%B8%80%E9%9D%A2/</url>
    
    <content type="html"><![CDATA[<blockquote><p>题目很简单，但是关于java的知识太薄弱了</p></blockquote><h2 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h2><h3 id="1-面向对象的特性？多态的实现方式？"><a href="#1-面向对象的特性？多态的实现方式？" class="headerlink" title="1. 面向对象的特性？多态的实现方式？"></a>1. 面向对象的特性？多态的实现方式？</h3><ol><li>继承</li><li>封装</li><li>多态<ul><li>方法重载（同名不同参）：编译时多态</li><li>方法重写（继承后override）：运行时多态</li></ul></li></ol><h3 id="2-接口和抽象类的区别？"><a href="#2-接口和抽象类的区别？" class="headerlink" title="2. 接口和抽象类的区别？"></a>2. 接口和抽象类的区别？</h3><table><thead><tr><th>特性</th><th>接口</th><th>抽象</th></tr></thead><tbody><tr><td>数量</td><td>可实现多个</td><td>只能继承一个</td></tr><tr><td>含非抽象方法</td><td></td><td>√</td></tr><tr><td>可以被实例化</td><td></td><td>√</td></tr><tr><td>可以有构造函数</td><td></td><td>√</td></tr><tr><td>可以有成员变量</td><td></td><td>√</td></tr><tr><td>访问修饰符</td><td>仅为public</td><td>抽象方法可为public和protected</td></tr><tr><td>使用场景</td><td>仅提供公共方法协议，不考虑实现</td><td>为一系列类提供公共的状态来实现</td></tr></tbody></table><h3 id="3-String类是否可以继承？如果创建了路径完全一样的String，会有什么区别？"><a href="#3-String类是否可以继承？如果创建了路径完全一样的String，会有什么区别？" class="headerlink" title="3. String类是否可以继承？如果创建了路径完全一样的String，会有什么区别？"></a>3. String类是否可以继承？如果创建了路径完全一样的String，会有什么区别？</h3><p>String类不可以被继承，其被final修饰。<br>final修饰的特点：（以下情况编译不通过）</p><ol><li>final修饰的类不能被继承</li><li>final修饰的方法不能被重写</li><li>final修饰的变量赋值后不可修改</li></ol><p>创建了路径完全一样的String类会怎么样？</p><ol><li>编译不通过</li><li>即使编译通过，类加载器也会默认加载java类库的java.lang.String。（除非自定义类加载器）</li><li>即使创建了同一个包中的类，也不能访问String类的包级私有成员（不加修饰符的默认访问级别）<br>目的是为了确保核心类库不会被恶意代码覆盖和修改。</li></ol><h3 id="4-JAVA创建对象有几种方法？"><a href="#4-JAVA创建对象有几种方法？" class="headerlink" title="4. JAVA创建对象有几种方法？"></a>4. JAVA创建对象有几种方法？</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-number">1.</span> <span class="hljs-keyword">new</span><br>ClassName obj = <span class="hljs-keyword">new</span> <span class="hljs-constructor">ClassName()</span>;<br><span class="hljs-number">2.</span> newInstance + 反射<br><span class="hljs-comment">//只能调用无参构造函数</span><br>ClassName obj = (ClassName)<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Class</span>.</span></span><span class="hljs-keyword">for</span><span class="hljs-constructor">Name(<span class="hljs-string">&quot;ClassName&quot;</span>)</span>.<span class="hljs-keyword">new</span><span class="hljs-constructor">Instance()</span>;<br><span class="hljs-number">3.</span> Constructor的newInstance方法<br><span class="hljs-comment">//也是反射，可带参数</span><br>Constructor&lt;ClassName&gt; constructor = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ClassName</span>.</span></span><span class="hljs-keyword">class</span>.get<span class="hljs-constructor">Constructor(String.<span class="hljs-params">class</span>,<span class="hljs-params">int</span>.<span class="hljs-params">class</span>)</span>;<br>ClassName obj = constructor.<span class="hljs-keyword">new</span><span class="hljs-constructor">Instance(<span class="hljs-string">&quot;John&quot;</span>,25)</span>;<br><span class="hljs-number">4.</span> clone方法，需要类实现Cloneable方法<br>ClassName obj1 = <span class="hljs-keyword">new</span> <span class="hljs-constructor">ClassName()</span>;<br>ClassName obj2 = (ClassName)obj1.clone<span class="hljs-literal">()</span>;<br><span class="hljs-number">5.</span> 反序列化<br><span class="hljs-comment">//从流中读取对象，使用反序列化构建</span><br>ObjectInputStream inStream = <span class="hljs-keyword">new</span> <span class="hljs-constructor">ObjectInputStream(<span class="hljs-params">anInputStream</span>)</span>;<br>ClassName obj = (ClassName)inStream.read<span class="hljs-constructor">Object()</span>;<br><span class="hljs-number">6.</span> 工厂模式<br><span class="hljs-comment">//提供一个接口或方法来创建对象，不需要客户端知道具体要创建哪个类的实例。</span><br><span class="hljs-comment">//一个常见的使用场景：数据库连接的创建</span><br></code></pre></td></tr></table></figure><h3 id="5-HashMap-get一个值的过程？为什么冲突用链表，而不用数组？"><a href="#5-HashMap-get一个值的过程？为什么冲突用链表，而不用数组？" class="headerlink" title="5. HashMap get一个值的过程？为什么冲突用链表，而不用数组？"></a>5. HashMap get一个值的过程？为什么冲突用链表，而不用数组？</h3><p>get值，hashCode-&gt;equals<br>为什么用链表存储冲突结点？</p><ol><li>数组需提前分配空间，可能会面临扩容问题</li><li>链表转红黑树更简单</li></ol><p><strong>扩展1：HashMap的key值可以是可变对象吗？</strong><br>可以，HashMap的key值可以是任何对象。但是可能会产生数据丢失和不一致。<br>并且自己需要定义hashCode和equals方法，一旦修改了equals，需要相应修改hashCode方法。</p><p><strong>扩展2：如果我不重写hashCode和equals方法，直接将对象放入HashSet，依据什么去重？</strong><br>是否指向内存中同一个对象。</p><p><strong>扩展3：python中的dict的key值可以是可变对象吗？</strong><br>不可以，需要满足可哈希，可变对象hash值会变化。（而java中的hashmap可以使用任何类型做key值）<br>其他和java中hashmap类似，自定义对象去重，使用__hash__(),<strong>eq</strong>()来判断。</p><h3 id="6-介绍下threadlocal"><a href="#6-介绍下threadlocal" class="headerlink" title="6. 介绍下threadlocal"></a>6. 介绍下threadlocal</h3><p>线程局部变量的类，每个线程自己的独立的变量副本。<br>用于保存线程的相关状态。<br>有内存泄露的风险，如果线程是线程池中的持久线程，用完ThreadLocal未使用remove方法，会导致内存泄露。</p><h3 id="7-介绍下synchronized和atomic"><a href="#7-介绍下synchronized和atomic" class="headerlink" title="7. 介绍下synchronized和atomic"></a>7. 介绍下synchronized和atomic</h3><p>主要围绕着上锁不上锁，阐述以下几点：</p><ol><li>不同并发程度下的开销</li><li>适用范围</li></ol><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h3 id="1-深分页问题如何解决？"><a href="#1-深分页问题如何解决？" class="headerlink" title="1. 深分页问题如何解决？"></a>1. 深分页问题如何解决？</h3><h2 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h2><h3 id="1-文本如何转成结构化信息的？"><a href="#1-文本如何转成结构化信息的？" class="headerlink" title="1. 文本如何转成结构化信息的？"></a>1. 文本如何转成结构化信息的？</h3><p>正则表达式，可以用于提取邮箱，手机号。<br>newspaper，识别大段文本。</p>]]></content>
    
    
    
    <tags>
      
      <tag>面经</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>腾讯-秋招-后台开发-一面</title>
    <link href="/2023/09/09/%E8%85%BE%E8%AE%AF-%E7%A7%8B%E6%8B%9B-%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91-%E4%B8%80%E9%9D%A2/"/>
    <url>/2023/09/09/%E8%85%BE%E8%AE%AF-%E7%A7%8B%E6%8B%9B-%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91-%E4%B8%80%E9%9D%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h3 id="1-如果数据查询突然很慢，如何排查？"><a href="#1-如果数据查询突然很慢，如何排查？" class="headerlink" title="1. 如果数据查询突然很慢，如何排查？"></a>1. 如果数据查询突然很慢，如何排查？</h3><p>可能引起的原因：</p><ol><li>数据量增大，本身sql书写不合理，或者没加索引，或者索引失效（分布发生了变化，导致执行计划认为全表扫描更快），或者索引碎片化，或者页分裂</li><li>大量的并发请求，服务器资源占用升高</li><li>受到类似DDos攻击</li><li>锁和阻塞，某些查询或任务锁定了资源</li><li>数据库在进行维护任务</li><li>网络问题</li><li>硬件设施出问题，或磁盘空间不足</li></ol><h3 id="2-mysql的锁有哪些？什么情况下会加表锁？什么情况下加间隙锁？"><a href="#2-mysql的锁有哪些？什么情况下会加表锁？什么情况下加间隙锁？" class="headerlink" title="2. mysql的锁有哪些？什么情况下会加表锁？什么情况下加间隙锁？"></a>2. mysql的锁有哪些？什么情况下会加表锁？什么情况下加间隙锁？</h3><p>innodb加表锁的几种情况：</p><ol><li>全表扫描，或count(*)</li><li>可能违反外键约束的情况。比如删除数据，但是因为外键，要全表扫描另外一张表中是否有违反约束的记录。–不靠谱，外键会加索引</li><li>DDL操作，mysql5.6开始，引入了在线DDL，可以在不锁定全表的情况下哎，进行更新。以下操作可以在线ddl：添加索引、删除索引、更改列的默认值，列的重命名，添加删除外键约束。其他在限定条件下可以在线的操作：添加列（5.7不允许not null，8.0有摩尔恩之也行），删除（如果不是主键的一部分的话），更改列的类型（varchar(10)-&gt;varchar(20)可以，int-&gt;char不行）</li><li>锁升级，行锁累积，升级为表锁来减少锁的管理开销</li><li>明确的锁表请求，lock tables（默认加写锁）</li></ol><p>间隙锁用于锁定两个记录之间的间隙，确保在锁定期间，其他事务不能在这个间隙插入新的记录，来防止幻读。<br>innodb加间隙锁的情况：</p><ol><li>范围查询</li><li>唯一索引检查，插入记录冲突时</li><li>外键约束检查</li><li>插入操作</li></ol><h3 id="3-隔离级别有哪些？因为隔离级别导致问题的情况遇到过吗？"><a href="#3-隔离级别有哪些？因为隔离级别导致问题的情况遇到过吗？" class="headerlink" title="3. 隔离级别有哪些？因为隔离级别导致问题的情况遇到过吗？"></a>3. 隔离级别有哪些？因为隔离级别导致问题的情况遇到过吗？</h3><h3 id="4-怎么知道是否使用了索引？"><a href="#4-怎么知道是否使用了索引？" class="headerlink" title="4. 怎么知道是否使用了索引？"></a>4. 怎么知道是否使用了索引？</h3><p>explain</p><h3 id="5-聚簇索引和非聚簇索引的区别？"><a href="#5-聚簇索引和非聚簇索引的区别？" class="headerlink" title="5. 聚簇索引和非聚簇索引的区别？"></a>5. 聚簇索引和非聚簇索引的区别？</h3><h3 id="6-为什么用B-树？"><a href="#6-为什么用B-树？" class="headerlink" title="6. 为什么用B+树？"></a>6. 为什么用B+树？</h3><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><h3 id="1-三次握手，客户端的ack丢失会怎么用？"><a href="#1-三次握手，客户端的ack丢失会怎么用？" class="headerlink" title="1. 三次握手，客户端的ack丢失会怎么用？"></a>1. 三次握手，客户端的ack丢失会怎么用？</h3><p>server重发syn+ack报文，3次失败后断开半连接状态。</p><h3 id="2-实际使用过socket吗"><a href="#2-实际使用过socket吗" class="headerlink" title="2. 实际使用过socket吗"></a>2. 实际使用过socket吗</h3><h2 id="java"><a href="#java" class="headerlink" title="java"></a>java</h2><h3 id="1-介绍下垃圾回收算法？"><a href="#1-介绍下垃圾回收算法？" class="headerlink" title="1. 介绍下垃圾回收算法？"></a>1. 介绍下垃圾回收算法？</h3><h3 id="2-jvm调优的经验？"><a href="#2-jvm调优的经验？" class="headerlink" title="2. jvm调优的经验？"></a>2. jvm调优的经验？</h3><h3 id="3-类加载器？双亲委派机制？什么时候要打破双亲委派机制？"><a href="#3-类加载器？双亲委派机制？什么时候要打破双亲委派机制？" class="headerlink" title="3. 类加载器？双亲委派机制？什么时候要打破双亲委派机制？"></a>3. 类加载器？双亲委派机制？什么时候要打破双亲委派机制？</h3><h2 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h2><h3 id="1-基本数据结构？讲讲跳表？"><a href="#1-基本数据结构？讲讲跳表？" class="headerlink" title="1. 基本数据结构？讲讲跳表？"></a>1. 基本数据结构？讲讲跳表？</h3><h2 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h2><h3 id="1-如何排查占用资源的内存？"><a href="#1-如何排查占用资源的内存？" class="headerlink" title="1. 如何排查占用资源的内存？"></a>1. 如何排查占用资源的内存？</h3><h3 id="2-如果jvm的xml设为4GB，通过top发现其占用不止4GB，是因为什么？"><a href="#2-如果jvm的xml设为4GB，通过top发现其占用不止4GB，是因为什么？" class="headerlink" title="2. 如果jvm的xml设为4GB，通过top发现其占用不止4GB，是因为什么？"></a>2. 如果jvm的xml设为4GB，通过top发现其占用不止4GB，是因为什么？</h3><p>xml限制了堆内存的大小，但是其他内存区也有开销。</p>]]></content>
    
    
    
    <tags>
      
      <tag>面经</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>小红书-实习-DBA-一面</title>
    <link href="/2023/09/08/%E5%B0%8F%E7%BA%A2%E4%B9%A6-%E5%AE%9E%E4%B9%A0-DBA-%E4%B8%80%E9%9D%A2/"/>
    <url>/2023/09/08/%E5%B0%8F%E7%BA%A2%E4%B9%A6-%E5%AE%9E%E4%B9%A0-DBA-%E4%B8%80%E9%9D%A2/</url>
    
    <content type="html"><![CDATA[<blockquote><p>总评：基础知识的细节没记清楚，回答错误；结巴太多；介绍项目的时候，不够吸引人；</p></blockquote><h2 id="系统"><a href="#系统" class="headerlink" title="系统"></a>系统</h2><h3 id="1-进程间的通信方式？"><a href="#1-进程间的通信方式？" class="headerlink" title="1. 进程间的通信方式？"></a>1. 进程间的通信方式？</h3><blockquote><p>首先每个进程的用户地址空间是独立的，但内核空间是共享的，所有进程间通信必须通过内核，所以以下机制都是内核通过的。</p></blockquote><p>有以下几种：</p><ol><li><p>管道<br>单向传输，若是相关通信，需要创建两个管道<br>管道的通信效率低，不适合进程间频繁的交换数据，大小受限。<br>好处是简单，而且很容易知道管道中的数据被另一个进程读取了。<br>匿名管道仅支持父子进程之间通信（因为原理是fork创建子进程时，复制父进程的文件描述符。）；命名管道，支持不相关进程间的通信。<br>特殊文件，只存在与内存中。<br>写入和读取数据均从内核中获取，遵循先入先出。<br>总结下管道的特点：</p><ul><li>单向</li><li>有限缓冲区</li><li>数据无结构性</li><li>不支持广播和多播</li><li>生命周期和创建他的进程绑定</li><li>通常用于有亲缘关系的进程间通信</li></ul></li><li><p>消息队列<br>消息队列相对管道效率高，是保存在内核中的消息链表，使用一个个独立的消息体发送（用户自定义的数据类型）。<br>生命周期随内核，没有释放或没有关闭OS，则会一直存在。<br>存在问题：</p><ul><li>消息不及时</li><li>附件大小有限制，不适合大数据传输（一条消息的最大长度和一个队列的最大长度）</li><li>存在用户态与内核态之间的数据拷贝开销，读写时都存在。（管道也是）</li></ul></li><li><p>共享内存<br>如果不想在用户态和内核态之间进行消息拷贝，则直接使用共享内存。<br>正常情况下的内存管理，采用的虚拟内存技术，每个进程都有自己独立的虚拟内存空间，即使虚拟地址一致，也映射到不同的物理内存地址。<br>共享内存：拿出一块虚拟地址空间，映射到相同的物理内存。<br>速度快，无需拷贝。<br>竞争造成数据错乱</p></li><li><p>信号<br>异常情况下的工作模式，需要信号来通知进程。<br>是进程间通信机制中唯一的<strong>异步</strong>通信机制。<br>来源：</p><ul><li>硬件来源（键盘ctrl+c）</li><li>软件来源（kill命令）<br>一旦信号产生，用户进程可以有以下几种处理方式：</li><li>执行默认操作，由linux规定</li><li>捕捉信号，自定义处理</li><li>忽略信号，但是sigkill，segstop无法捕捉和胡月，用于中断或结束进程</li></ul></li><li><p>socket<br>用于不同主机间的通信。（同主机也行）</p></li></ol><p>如信号量也可以用于实现同步和互斥</p><h3 id="2-进程的状态及其转换？"><a href="#2-进程的状态及其转换？" class="headerlink" title="2. 进程的状态及其转换？"></a>2. 进程的状态及其转换？</h3><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><h3 id="1-从键入url到显示页面的过程？"><a href="#1-从键入url到显示页面的过程？" class="headerlink" title="1. 从键入url到显示页面的过程？"></a>1. 从键入url到显示页面的过程？</h3><ul><li>解析url：拿到域名和要请求的资源</li><li>查询域名对应的IP地址：DNS服务，客户端向本地DNS服务器发出DNS请求-&gt;若缓存中有，直接返回IP，若没有，查询根域名服务器-&gt;根域名服务器会指出（.com)属于哪个顶级域名服务器-&gt;顶级域名服务器会指出(<a href="http://www.server.com)属于哪个权威域名服务器,权威域名服务器负责解析,然后将结果返回本地dns,本地dns返回客户端./">www.server.com)属于哪个权威域名服务器，权威域名服务器负责解析，然后将结果返回本地DNS，本地DNS返回客户端。</a><br>不过实际上，因为缓存的存在，浏览器先查自身缓存-&gt;没有就去问操作系统缓存-&gt;没有则去查hosts文件-&gt;没有则去问本地dns</li><li>获得IP地址后，依托协议栈进行传输，浏览器调用socket库来委托协议栈工作，包括传输层呢哥的tcp和udp协议，他们都会使用IP协议来进行网络包的收发，IP协议还包含ICMP和ARP，分别用于告知网络包传输过程中产生的错误以及控制信息、根据IP查询以太网MAC地址。IP下层的网卡驱动程序，控制网卡，网卡负责完成实际的收发操作。</li></ul><h3 id="2-四次挥手？如何同步？"><a href="#2-四次挥手？如何同步？" class="headerlink" title="2. 四次挥手？如何同步？"></a>2. 四次挥手？如何同步？</h3><p>序号（seq）和确认号（ack）</p><h2 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h2><h3 id="1-linux的常见命令"><a href="#1-linux的常见命令" class="headerlink" title="1. linux的常见命令"></a>1. linux的常见命令</h3><p>ls,cd,pwd,cp,mv,rm,touch,cat<br>grep,wc<br>ps,top,kill,pkill<br>ping,ipconfig,ssh,wget,curl,netstart<br>df,free<br>chmod,su,sudo,chown</p><h2 id="算法题"><a href="#算法题" class="headerlink" title="算法题"></a>算法题</h2><h3 id="1-逆转字符串：’hello中国nihao’"><a href="#1-逆转字符串：’hello中国nihao’" class="headerlink" title="1. 逆转字符串：’hello中国nihao’"></a>1. 逆转字符串：’hello中国nihao’</h3><p>UTF-8编码中中文占用3个字符，特殊中文字符4个字节。<br>不过这题，python和java都能直接输出。<br>不知道这个题出了有啥意义。</p><h2 id="其他类"><a href="#其他类" class="headerlink" title="其他类"></a>其他类</h2><h3 id="1-挑一个比较出彩的项目介绍下？"><a href="#1-挑一个比较出彩的项目介绍下？" class="headerlink" title="1. 挑一个比较出彩的项目介绍下？"></a>1. 挑一个比较出彩的项目介绍下？</h3><p>讲的很长，但是不吸引人，言简意赅一点</p><h3 id="2-学过哪些专业课？"><a href="#2-学过哪些专业课？" class="headerlink" title="2. 学过哪些专业课？"></a>2. 学过哪些专业课？</h3><p>有点忘了，记下几个。<br>高级软件开发技术，web软件开发，软件过程管理<br>机器学习，高级机器学习，强化学习</p>]]></content>
    
    
    
    <tags>
      
      <tag>面经</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
